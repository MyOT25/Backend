
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Actor
 * 
 */
export type Actor = $Result.DefaultSelection<Prisma.$ActorPayload>
/**
 * Model Musical
 * 
 */
export type Musical = $Result.DefaultSelection<Prisma.$MusicalPayload>
/**
 * Model Theater
 * 
 */
export type Theater = $Result.DefaultSelection<Prisma.$TheaterPayload>
/**
 * Model Seat
 * 
 */
export type Seat = $Result.DefaultSelection<Prisma.$SeatPayload>
/**
 * Model Community
 * 
 */
export type Community = $Result.DefaultSelection<Prisma.$CommunityPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model Subscribe
 * 
 */
export type Subscribe = $Result.DefaultSelection<Prisma.$SubscribePayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model ViewingRecord
 * 
 */
export type ViewingRecord = $Result.DefaultSelection<Prisma.$ViewingRecordPayload>
/**
 * Model PostLike
 * 
 */
export type PostLike = $Result.DefaultSelection<Prisma.$PostLikePayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model Answer
 * 
 */
export type Answer = $Result.DefaultSelection<Prisma.$AnswerPayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model Casting
 * 
 */
export type Casting = $Result.DefaultSelection<Prisma.$CastingPayload>
/**
 * Model UserCommunity
 * 
 */
export type UserCommunity = $Result.DefaultSelection<Prisma.$UserCommunityPayload>
/**
 * Model MusicalCommunity
 * 
 */
export type MusicalCommunity = $Result.DefaultSelection<Prisma.$MusicalCommunityPayload>
/**
 * Model MultiProfile
 * 
 */
export type MultiProfile = $Result.DefaultSelection<Prisma.$MultiProfilePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ImageOrVideo: {
  image: 'image',
  video: 'video'
};

export type ImageOrVideo = (typeof ImageOrVideo)[keyof typeof ImageOrVideo]


export const Category: {
  highlight: 'highlight',
  media: 'media',
  memorybook: 'memorybook'
};

export type Category = (typeof Category)[keyof typeof Category]

}

export type ImageOrVideo = $Enums.ImageOrVideo

export const ImageOrVideo: typeof $Enums.ImageOrVideo

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.actor`: Exposes CRUD operations for the **Actor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actors
    * const actors = await prisma.actor.findMany()
    * ```
    */
  get actor(): Prisma.ActorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.musical`: Exposes CRUD operations for the **Musical** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Musicals
    * const musicals = await prisma.musical.findMany()
    * ```
    */
  get musical(): Prisma.MusicalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.theater`: Exposes CRUD operations for the **Theater** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Theaters
    * const theaters = await prisma.theater.findMany()
    * ```
    */
  get theater(): Prisma.TheaterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seat`: Exposes CRUD operations for the **Seat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seats
    * const seats = await prisma.seat.findMany()
    * ```
    */
  get seat(): Prisma.SeatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.community`: Exposes CRUD operations for the **Community** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communities
    * const communities = await prisma.community.findMany()
    * ```
    */
  get community(): Prisma.CommunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscribe`: Exposes CRUD operations for the **Subscribe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscribes
    * const subscribes = await prisma.subscribe.findMany()
    * ```
    */
  get subscribe(): Prisma.SubscribeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viewingRecord`: Exposes CRUD operations for the **ViewingRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewingRecords
    * const viewingRecords = await prisma.viewingRecord.findMany()
    * ```
    */
  get viewingRecord(): Prisma.ViewingRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postLike`: Exposes CRUD operations for the **PostLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostLikes
    * const postLikes = await prisma.postLike.findMany()
    * ```
    */
  get postLike(): Prisma.PostLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.answer`: Exposes CRUD operations for the **Answer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answer.findMany()
    * ```
    */
  get answer(): Prisma.AnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.casting`: Exposes CRUD operations for the **Casting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Castings
    * const castings = await prisma.casting.findMany()
    * ```
    */
  get casting(): Prisma.CastingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCommunity`: Exposes CRUD operations for the **UserCommunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCommunities
    * const userCommunities = await prisma.userCommunity.findMany()
    * ```
    */
  get userCommunity(): Prisma.UserCommunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.musicalCommunity`: Exposes CRUD operations for the **MusicalCommunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MusicalCommunities
    * const musicalCommunities = await prisma.musicalCommunity.findMany()
    * ```
    */
  get musicalCommunity(): Prisma.MusicalCommunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.multiProfile`: Exposes CRUD operations for the **MultiProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MultiProfiles
    * const multiProfiles = await prisma.multiProfile.findMany()
    * ```
    */
  get multiProfile(): Prisma.MultiProfileDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Post: 'Post',
    Comment: 'Comment',
    Review: 'Review',
    Actor: 'Actor',
    Musical: 'Musical',
    Theater: 'Theater',
    Seat: 'Seat',
    Community: 'Community',
    Setting: 'Setting',
    Tag: 'Tag',
    Image: 'Image',
    Subscribe: 'Subscribe',
    Follow: 'Follow',
    ViewingRecord: 'ViewingRecord',
    PostLike: 'PostLike',
    Question: 'Question',
    Answer: 'Answer',
    Region: 'Region',
    Casting: 'Casting',
    UserCommunity: 'UserCommunity',
    MusicalCommunity: 'MusicalCommunity',
    MultiProfile: 'MultiProfile'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "post" | "comment" | "review" | "actor" | "musical" | "theater" | "seat" | "community" | "setting" | "tag" | "image" | "subscribe" | "follow" | "viewingRecord" | "postLike" | "question" | "answer" | "region" | "casting" | "userCommunity" | "musicalCommunity" | "multiProfile"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Actor: {
        payload: Prisma.$ActorPayload<ExtArgs>
        fields: Prisma.ActorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          findFirst: {
            args: Prisma.ActorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          findMany: {
            args: Prisma.ActorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>[]
          }
          create: {
            args: Prisma.ActorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          createMany: {
            args: Prisma.ActorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          update: {
            args: Prisma.ActorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          deleteMany: {
            args: Prisma.ActorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActorPayload>
          }
          aggregate: {
            args: Prisma.ActorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActor>
          }
          groupBy: {
            args: Prisma.ActorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActorCountArgs<ExtArgs>
            result: $Utils.Optional<ActorCountAggregateOutputType> | number
          }
        }
      }
      Musical: {
        payload: Prisma.$MusicalPayload<ExtArgs>
        fields: Prisma.MusicalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MusicalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MusicalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          findFirst: {
            args: Prisma.MusicalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MusicalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          findMany: {
            args: Prisma.MusicalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>[]
          }
          create: {
            args: Prisma.MusicalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          createMany: {
            args: Prisma.MusicalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MusicalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          update: {
            args: Prisma.MusicalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          deleteMany: {
            args: Prisma.MusicalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MusicalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MusicalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          aggregate: {
            args: Prisma.MusicalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMusical>
          }
          groupBy: {
            args: Prisma.MusicalGroupByArgs<ExtArgs>
            result: $Utils.Optional<MusicalGroupByOutputType>[]
          }
          count: {
            args: Prisma.MusicalCountArgs<ExtArgs>
            result: $Utils.Optional<MusicalCountAggregateOutputType> | number
          }
        }
      }
      Theater: {
        payload: Prisma.$TheaterPayload<ExtArgs>
        fields: Prisma.TheaterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TheaterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TheaterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TheaterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TheaterPayload>
          }
          findFirst: {
            args: Prisma.TheaterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TheaterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TheaterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TheaterPayload>
          }
          findMany: {
            args: Prisma.TheaterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TheaterPayload>[]
          }
          create: {
            args: Prisma.TheaterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TheaterPayload>
          }
          createMany: {
            args: Prisma.TheaterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TheaterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TheaterPayload>
          }
          update: {
            args: Prisma.TheaterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TheaterPayload>
          }
          deleteMany: {
            args: Prisma.TheaterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TheaterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TheaterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TheaterPayload>
          }
          aggregate: {
            args: Prisma.TheaterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTheater>
          }
          groupBy: {
            args: Prisma.TheaterGroupByArgs<ExtArgs>
            result: $Utils.Optional<TheaterGroupByOutputType>[]
          }
          count: {
            args: Prisma.TheaterCountArgs<ExtArgs>
            result: $Utils.Optional<TheaterCountAggregateOutputType> | number
          }
        }
      }
      Seat: {
        payload: Prisma.$SeatPayload<ExtArgs>
        fields: Prisma.SeatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          findFirst: {
            args: Prisma.SeatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          findMany: {
            args: Prisma.SeatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>[]
          }
          create: {
            args: Prisma.SeatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          createMany: {
            args: Prisma.SeatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SeatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          update: {
            args: Prisma.SeatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          deleteMany: {
            args: Prisma.SeatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          aggregate: {
            args: Prisma.SeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeat>
          }
          groupBy: {
            args: Prisma.SeatGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeatCountArgs<ExtArgs>
            result: $Utils.Optional<SeatCountAggregateOutputType> | number
          }
        }
      }
      Community: {
        payload: Prisma.$CommunityPayload<ExtArgs>
        fields: Prisma.CommunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findFirst: {
            args: Prisma.CommunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findMany: {
            args: Prisma.CommunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          create: {
            args: Prisma.CommunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          createMany: {
            args: Prisma.CommunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          update: {
            args: Prisma.CommunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          deleteMany: {
            args: Prisma.CommunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          aggregate: {
            args: Prisma.CommunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunity>
          }
          groupBy: {
            args: Prisma.CommunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      Subscribe: {
        payload: Prisma.$SubscribePayload<ExtArgs>
        fields: Prisma.SubscribeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscribeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscribePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscribeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscribePayload>
          }
          findFirst: {
            args: Prisma.SubscribeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscribePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscribeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscribePayload>
          }
          findMany: {
            args: Prisma.SubscribeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscribePayload>[]
          }
          create: {
            args: Prisma.SubscribeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscribePayload>
          }
          createMany: {
            args: Prisma.SubscribeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubscribeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscribePayload>
          }
          update: {
            args: Prisma.SubscribeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscribePayload>
          }
          deleteMany: {
            args: Prisma.SubscribeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscribeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscribeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscribePayload>
          }
          aggregate: {
            args: Prisma.SubscribeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscribe>
          }
          groupBy: {
            args: Prisma.SubscribeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscribeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscribeCountArgs<ExtArgs>
            result: $Utils.Optional<SubscribeCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      ViewingRecord: {
        payload: Prisma.$ViewingRecordPayload<ExtArgs>
        fields: Prisma.ViewingRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewingRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewingRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRecordPayload>
          }
          findFirst: {
            args: Prisma.ViewingRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewingRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRecordPayload>
          }
          findMany: {
            args: Prisma.ViewingRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRecordPayload>[]
          }
          create: {
            args: Prisma.ViewingRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRecordPayload>
          }
          createMany: {
            args: Prisma.ViewingRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ViewingRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRecordPayload>
          }
          update: {
            args: Prisma.ViewingRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRecordPayload>
          }
          deleteMany: {
            args: Prisma.ViewingRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewingRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ViewingRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRecordPayload>
          }
          aggregate: {
            args: Prisma.ViewingRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViewingRecord>
          }
          groupBy: {
            args: Prisma.ViewingRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewingRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewingRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ViewingRecordCountAggregateOutputType> | number
          }
        }
      }
      PostLike: {
        payload: Prisma.$PostLikePayload<ExtArgs>
        fields: Prisma.PostLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          findFirst: {
            args: Prisma.PostLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          findMany: {
            args: Prisma.PostLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>[]
          }
          create: {
            args: Prisma.PostLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          createMany: {
            args: Prisma.PostLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PostLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          update: {
            args: Prisma.PostLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          deleteMany: {
            args: Prisma.PostLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          aggregate: {
            args: Prisma.PostLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostLike>
          }
          groupBy: {
            args: Prisma.PostLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostLikeCountArgs<ExtArgs>
            result: $Utils.Optional<PostLikeCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Answer: {
        payload: Prisma.$AnswerPayload<ExtArgs>
        fields: Prisma.AnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findFirst: {
            args: Prisma.AnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findMany: {
            args: Prisma.AnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          create: {
            args: Prisma.AnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          createMany: {
            args: Prisma.AnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          update: {
            args: Prisma.AnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          deleteMany: {
            args: Prisma.AnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          aggregate: {
            args: Prisma.AnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswer>
          }
          groupBy: {
            args: Prisma.AnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnswerCountArgs<ExtArgs>
            result: $Utils.Optional<AnswerCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      Casting: {
        payload: Prisma.$CastingPayload<ExtArgs>
        fields: Prisma.CastingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CastingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CastingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingPayload>
          }
          findFirst: {
            args: Prisma.CastingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CastingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingPayload>
          }
          findMany: {
            args: Prisma.CastingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingPayload>[]
          }
          create: {
            args: Prisma.CastingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingPayload>
          }
          createMany: {
            args: Prisma.CastingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CastingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingPayload>
          }
          update: {
            args: Prisma.CastingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingPayload>
          }
          deleteMany: {
            args: Prisma.CastingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CastingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CastingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingPayload>
          }
          aggregate: {
            args: Prisma.CastingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCasting>
          }
          groupBy: {
            args: Prisma.CastingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CastingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CastingCountArgs<ExtArgs>
            result: $Utils.Optional<CastingCountAggregateOutputType> | number
          }
        }
      }
      UserCommunity: {
        payload: Prisma.$UserCommunityPayload<ExtArgs>
        fields: Prisma.UserCommunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCommunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCommunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommunityPayload>
          }
          findFirst: {
            args: Prisma.UserCommunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCommunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommunityPayload>
          }
          findMany: {
            args: Prisma.UserCommunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommunityPayload>[]
          }
          create: {
            args: Prisma.UserCommunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommunityPayload>
          }
          createMany: {
            args: Prisma.UserCommunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserCommunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommunityPayload>
          }
          update: {
            args: Prisma.UserCommunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommunityPayload>
          }
          deleteMany: {
            args: Prisma.UserCommunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCommunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserCommunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommunityPayload>
          }
          aggregate: {
            args: Prisma.UserCommunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCommunity>
          }
          groupBy: {
            args: Prisma.UserCommunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCommunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCommunityCountArgs<ExtArgs>
            result: $Utils.Optional<UserCommunityCountAggregateOutputType> | number
          }
        }
      }
      MusicalCommunity: {
        payload: Prisma.$MusicalCommunityPayload<ExtArgs>
        fields: Prisma.MusicalCommunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MusicalCommunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalCommunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MusicalCommunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalCommunityPayload>
          }
          findFirst: {
            args: Prisma.MusicalCommunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalCommunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MusicalCommunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalCommunityPayload>
          }
          findMany: {
            args: Prisma.MusicalCommunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalCommunityPayload>[]
          }
          create: {
            args: Prisma.MusicalCommunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalCommunityPayload>
          }
          createMany: {
            args: Prisma.MusicalCommunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MusicalCommunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalCommunityPayload>
          }
          update: {
            args: Prisma.MusicalCommunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalCommunityPayload>
          }
          deleteMany: {
            args: Prisma.MusicalCommunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MusicalCommunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MusicalCommunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalCommunityPayload>
          }
          aggregate: {
            args: Prisma.MusicalCommunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMusicalCommunity>
          }
          groupBy: {
            args: Prisma.MusicalCommunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<MusicalCommunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.MusicalCommunityCountArgs<ExtArgs>
            result: $Utils.Optional<MusicalCommunityCountAggregateOutputType> | number
          }
        }
      }
      MultiProfile: {
        payload: Prisma.$MultiProfilePayload<ExtArgs>
        fields: Prisma.MultiProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultiProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultiProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiProfilePayload>
          }
          findFirst: {
            args: Prisma.MultiProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultiProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiProfilePayload>
          }
          findMany: {
            args: Prisma.MultiProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiProfilePayload>[]
          }
          create: {
            args: Prisma.MultiProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiProfilePayload>
          }
          createMany: {
            args: Prisma.MultiProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MultiProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiProfilePayload>
          }
          update: {
            args: Prisma.MultiProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiProfilePayload>
          }
          deleteMany: {
            args: Prisma.MultiProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MultiProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MultiProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiProfilePayload>
          }
          aggregate: {
            args: Prisma.MultiProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMultiProfile>
          }
          groupBy: {
            args: Prisma.MultiProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultiProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultiProfileCountArgs<ExtArgs>
            result: $Utils.Optional<MultiProfileCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    post?: PostOmit
    comment?: CommentOmit
    review?: ReviewOmit
    actor?: ActorOmit
    musical?: MusicalOmit
    theater?: TheaterOmit
    seat?: SeatOmit
    community?: CommunityOmit
    setting?: SettingOmit
    tag?: TagOmit
    image?: ImageOmit
    subscribe?: SubscribeOmit
    follow?: FollowOmit
    viewingRecord?: ViewingRecordOmit
    postLike?: PostLikeOmit
    question?: QuestionOmit
    answer?: AnswerOmit
    region?: RegionOmit
    casting?: CastingOmit
    userCommunity?: UserCommunityOmit
    musicalCommunity?: MusicalCommunityOmit
    multiProfile?: MultiProfileOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    posts: number
    comments: number
    reviews: number
    postLikes: number
    questions: number
    answers: number
    subscriptions: number
    viewings: number
    follows: number
    followers: number
    multiProfiles: number
    userCommunities: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    postLikes?: boolean | UserCountOutputTypeCountPostLikesArgs
    questions?: boolean | UserCountOutputTypeCountQuestionsArgs
    answers?: boolean | UserCountOutputTypeCountAnswersArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    viewings?: boolean | UserCountOutputTypeCountViewingsArgs
    follows?: boolean | UserCountOutputTypeCountFollowsArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    multiProfiles?: boolean | UserCountOutputTypeCountMultiProfilesArgs
    userCommunities?: boolean | UserCountOutputTypeCountUserCommunitiesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscribeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountViewingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewingRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMultiProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiProfileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCommunityWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
    postLikes: number
    images: number
    reviews: number
    tags: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    postLikes?: boolean | PostCountOutputTypeCountPostLikesArgs
    images?: boolean | PostCountOutputTypeCountImagesArgs
    reviews?: boolean | PostCountOutputTypeCountReviewsArgs
    tags?: boolean | PostCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountPostLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type ActorCountOutputType
   */

  export type ActorCountOutputType = {
    posts: number
    castings: number
  }

  export type ActorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | ActorCountOutputTypeCountPostsArgs
    castings?: boolean | ActorCountOutputTypeCountCastingsArgs
  }

  // Custom InputTypes
  /**
   * ActorCountOutputType without action
   */
  export type ActorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActorCountOutputType
     */
    select?: ActorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActorCountOutputType without action
   */
  export type ActorCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * ActorCountOutputType without action
   */
  export type ActorCountOutputTypeCountCastingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastingWhereInput
  }


  /**
   * Count Type MusicalCountOutputType
   */

  export type MusicalCountOutputType = {
    castings: number
    viewings: number
    communities: number
  }

  export type MusicalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    castings?: boolean | MusicalCountOutputTypeCountCastingsArgs
    viewings?: boolean | MusicalCountOutputTypeCountViewingsArgs
    communities?: boolean | MusicalCountOutputTypeCountCommunitiesArgs
  }

  // Custom InputTypes
  /**
   * MusicalCountOutputType without action
   */
  export type MusicalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCountOutputType
     */
    select?: MusicalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MusicalCountOutputType without action
   */
  export type MusicalCountOutputTypeCountCastingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastingWhereInput
  }

  /**
   * MusicalCountOutputType without action
   */
  export type MusicalCountOutputTypeCountViewingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewingRecordWhereInput
  }

  /**
   * MusicalCountOutputType without action
   */
  export type MusicalCountOutputTypeCountCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MusicalCommunityWhereInput
  }


  /**
   * Count Type TheaterCountOutputType
   */

  export type TheaterCountOutputType = {
    musicals: number
    seats: number
  }

  export type TheaterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    musicals?: boolean | TheaterCountOutputTypeCountMusicalsArgs
    seats?: boolean | TheaterCountOutputTypeCountSeatsArgs
  }

  // Custom InputTypes
  /**
   * TheaterCountOutputType without action
   */
  export type TheaterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TheaterCountOutputType
     */
    select?: TheaterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TheaterCountOutputType without action
   */
  export type TheaterCountOutputTypeCountMusicalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MusicalWhereInput
  }

  /**
   * TheaterCountOutputType without action
   */
  export type TheaterCountOutputTypeCountSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatWhereInput
  }


  /**
   * Count Type CommunityCountOutputType
   */

  export type CommunityCountOutputType = {
    userCommunities: number
    musicalCommunities: number
  }

  export type CommunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCommunities?: boolean | CommunityCountOutputTypeCountUserCommunitiesArgs
    musicalCommunities?: boolean | CommunityCountOutputTypeCountMusicalCommunitiesArgs
  }

  // Custom InputTypes
  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCountOutputType
     */
    select?: CommunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountUserCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCommunityWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountMusicalCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MusicalCommunityWhereInput
  }


  /**
   * Count Type SettingCountOutputType
   */

  export type SettingCountOutputType = {
    posts: number
  }

  export type SettingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | SettingCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * SettingCountOutputType without action
   */
  export type SettingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingCountOutputType
     */
    select?: SettingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SettingCountOutputType without action
   */
  export type SettingCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    posts: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | TagCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    answers: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
  }


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    theaters: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    theaters?: boolean | RegionCountOutputTypeCountTheatersArgs
  }

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountTheatersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TheaterWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    settingId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    settingId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    loginId: string | null
    settingId: number | null
    username: string | null
    password: string | null
    email: string | null
    nickname: string | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    bio: string | null
    birthDate: Date | null
    isSubscribed: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    loginId: string | null
    settingId: number | null
    username: string | null
    password: string | null
    email: string | null
    nickname: string | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    bio: string | null
    birthDate: Date | null
    isSubscribed: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    loginId: number
    settingId: number
    username: number
    password: number
    email: number
    nickname: number
    profileImage: number
    createdAt: number
    updatedAt: number
    bio: number
    birthDate: number
    isSubscribed: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    settingId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    settingId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    loginId?: true
    settingId?: true
    username?: true
    password?: true
    email?: true
    nickname?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
    bio?: true
    birthDate?: true
    isSubscribed?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    loginId?: true
    settingId?: true
    username?: true
    password?: true
    email?: true
    nickname?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
    bio?: true
    birthDate?: true
    isSubscribed?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    loginId?: true
    settingId?: true
    username?: true
    password?: true
    email?: true
    nickname?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
    bio?: true
    birthDate?: true
    isSubscribed?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    loginId: string
    settingId: number
    username: string | null
    password: string | null
    email: string
    nickname: string | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    bio: string | null
    birthDate: Date | null
    isSubscribed: boolean | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loginId?: boolean
    settingId?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    nickname?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bio?: boolean
    birthDate?: boolean
    isSubscribed?: boolean
    setting?: boolean | SettingDefaultArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    postLikes?: boolean | User$postLikesArgs<ExtArgs>
    questions?: boolean | User$questionsArgs<ExtArgs>
    answers?: boolean | User$answersArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    viewings?: boolean | User$viewingsArgs<ExtArgs>
    follows?: boolean | User$followsArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    multiProfiles?: boolean | User$multiProfilesArgs<ExtArgs>
    userCommunities?: boolean | User$userCommunitiesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    loginId?: boolean
    settingId?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    nickname?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bio?: boolean
    birthDate?: boolean
    isSubscribed?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loginId" | "settingId" | "username" | "password" | "email" | "nickname" | "profileImage" | "createdAt" | "updatedAt" | "bio" | "birthDate" | "isSubscribed", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    setting?: boolean | SettingDefaultArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    postLikes?: boolean | User$postLikesArgs<ExtArgs>
    questions?: boolean | User$questionsArgs<ExtArgs>
    answers?: boolean | User$answersArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    viewings?: boolean | User$viewingsArgs<ExtArgs>
    follows?: boolean | User$followsArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    multiProfiles?: boolean | User$multiProfilesArgs<ExtArgs>
    userCommunities?: boolean | User$userCommunitiesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      setting: Prisma.$SettingPayload<ExtArgs>
      posts: Prisma.$PostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      postLikes: Prisma.$PostLikePayload<ExtArgs>[]
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      answers: Prisma.$AnswerPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscribePayload<ExtArgs>[]
      viewings: Prisma.$ViewingRecordPayload<ExtArgs>[]
      follows: Prisma.$FollowPayload<ExtArgs>[]
      followers: Prisma.$FollowPayload<ExtArgs>[]
      multiProfiles: Prisma.$MultiProfilePayload<ExtArgs>[]
      userCommunities: Prisma.$UserCommunityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      loginId: string
      settingId: number
      username: string | null
      password: string | null
      email: string
      nickname: string | null
      profileImage: string | null
      createdAt: Date | null
      updatedAt: Date | null
      bio: string | null
      birthDate: Date | null
      isSubscribed: boolean | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    setting<T extends SettingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SettingDefaultArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postLikes<T extends User$postLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$postLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends User$questionsArgs<ExtArgs> = {}>(args?: Subset<T, User$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    answers<T extends User$answersArgs<ExtArgs> = {}>(args?: Subset<T, User$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscribePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewings<T extends User$viewingsArgs<ExtArgs> = {}>(args?: Subset<T, User$viewingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewingRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    follows<T extends User$followsArgs<ExtArgs> = {}>(args?: Subset<T, User$followsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    multiProfiles<T extends User$multiProfilesArgs<ExtArgs> = {}>(args?: Subset<T, User$multiProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userCommunities<T extends User$userCommunitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$userCommunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly loginId: FieldRef<"User", 'String'>
    readonly settingId: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly nickname: FieldRef<"User", 'String'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly bio: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly isSubscribed: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.postLikes
   */
  export type User$postLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    cursor?: PostLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * User.questions
   */
  export type User$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * User.answers
   */
  export type User$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    cursor?: AnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscribe
     */
    select?: SubscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscribe
     */
    omit?: SubscribeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscribeInclude<ExtArgs> | null
    where?: SubscribeWhereInput
    orderBy?: SubscribeOrderByWithRelationInput | SubscribeOrderByWithRelationInput[]
    cursor?: SubscribeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscribeScalarFieldEnum | SubscribeScalarFieldEnum[]
  }

  /**
   * User.viewings
   */
  export type User$viewingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
    where?: ViewingRecordWhereInput
    orderBy?: ViewingRecordOrderByWithRelationInput | ViewingRecordOrderByWithRelationInput[]
    cursor?: ViewingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewingRecordScalarFieldEnum | ViewingRecordScalarFieldEnum[]
  }

  /**
   * User.follows
   */
  export type User$followsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.multiProfiles
   */
  export type User$multiProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiProfile
     */
    select?: MultiProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiProfile
     */
    omit?: MultiProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiProfileInclude<ExtArgs> | null
    where?: MultiProfileWhereInput
    orderBy?: MultiProfileOrderByWithRelationInput | MultiProfileOrderByWithRelationInput[]
    cursor?: MultiProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultiProfileScalarFieldEnum | MultiProfileScalarFieldEnum[]
  }

  /**
   * User.userCommunities
   */
  export type User$userCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
    where?: UserCommunityWhereInput
    orderBy?: UserCommunityOrderByWithRelationInput | UserCommunityOrderByWithRelationInput[]
    cursor?: UserCommunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCommunityScalarFieldEnum | UserCommunityScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
    likeCount: number | null
    commentCount: number | null
    repost: number | null
    bookmark: number | null
    viewCount: number | null
    musicalId: number | null
    actorId: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
    likeCount: number | null
    commentCount: number | null
    repost: number | null
    bookmark: number | null
    viewCount: number | null
    musicalId: number | null
    actorId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
    title: string | null
    content: string | null
    category: string | null
    like: string | null
    likeCount: number | null
    commentCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    repost: number | null
    bookmark: number | null
    communityGroup: string | null
    viewCount: number | null
    tag: string | null
    mediaType: $Enums.ImageOrVideo | null
    isPinned: boolean | null
    tabCategory: $Enums.Category | null
    isShared: boolean | null
    musicalId: number | null
    actorId: number | null
    extraField: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
    title: string | null
    content: string | null
    category: string | null
    like: string | null
    likeCount: number | null
    commentCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    repost: number | null
    bookmark: number | null
    communityGroup: string | null
    viewCount: number | null
    tag: string | null
    mediaType: $Enums.ImageOrVideo | null
    isPinned: boolean | null
    tabCategory: $Enums.Category | null
    isShared: boolean | null
    musicalId: number | null
    actorId: number | null
    extraField: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    userId: number
    settingId: number
    communityId: number
    title: number
    content: number
    category: number
    like: number
    likeCount: number
    commentCount: number
    createdAt: number
    updatedAt: number
    repost: number
    bookmark: number
    communityGroup: number
    viewCount: number
    tag: number
    mediaType: number
    isPinned: number
    tabCategory: number
    isShared: number
    musicalId: number
    actorId: number
    extraField: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
    communityId?: true
    likeCount?: true
    commentCount?: true
    repost?: true
    bookmark?: true
    viewCount?: true
    musicalId?: true
    actorId?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
    communityId?: true
    likeCount?: true
    commentCount?: true
    repost?: true
    bookmark?: true
    viewCount?: true
    musicalId?: true
    actorId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
    communityId?: true
    title?: true
    content?: true
    category?: true
    like?: true
    likeCount?: true
    commentCount?: true
    createdAt?: true
    updatedAt?: true
    repost?: true
    bookmark?: true
    communityGroup?: true
    viewCount?: true
    tag?: true
    mediaType?: true
    isPinned?: true
    tabCategory?: true
    isShared?: true
    musicalId?: true
    actorId?: true
    extraField?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
    communityId?: true
    title?: true
    content?: true
    category?: true
    like?: true
    likeCount?: true
    commentCount?: true
    createdAt?: true
    updatedAt?: true
    repost?: true
    bookmark?: true
    communityGroup?: true
    viewCount?: true
    tag?: true
    mediaType?: true
    isPinned?: true
    tabCategory?: true
    isShared?: true
    musicalId?: true
    actorId?: true
    extraField?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
    communityId?: true
    title?: true
    content?: true
    category?: true
    like?: true
    likeCount?: true
    commentCount?: true
    createdAt?: true
    updatedAt?: true
    repost?: true
    bookmark?: true
    communityGroup?: true
    viewCount?: true
    tag?: true
    mediaType?: true
    isPinned?: true
    tabCategory?: true
    isShared?: true
    musicalId?: true
    actorId?: true
    extraField?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    userId: number
    settingId: number
    communityId: number
    title: string | null
    content: string | null
    category: string | null
    like: string | null
    likeCount: number | null
    commentCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    repost: number | null
    bookmark: number | null
    communityGroup: string | null
    viewCount: number | null
    tag: string | null
    mediaType: $Enums.ImageOrVideo | null
    isPinned: boolean | null
    tabCategory: $Enums.Category | null
    isShared: boolean | null
    musicalId: number | null
    actorId: number | null
    extraField: string | null
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    settingId?: boolean
    communityId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    like?: boolean
    likeCount?: boolean
    commentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    repost?: boolean
    bookmark?: boolean
    communityGroup?: boolean
    viewCount?: boolean
    tag?: boolean
    mediaType?: boolean
    isPinned?: boolean
    tabCategory?: boolean
    isShared?: boolean
    musicalId?: boolean
    actorId?: boolean
    extraField?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    actor?: boolean | Post$actorArgs<ExtArgs>
    setting?: boolean | SettingDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    postLikes?: boolean | Post$postLikesArgs<ExtArgs>
    images?: boolean | Post$imagesArgs<ExtArgs>
    reviews?: boolean | Post$reviewsArgs<ExtArgs>
    tags?: boolean | Post$tagsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>



  export type PostSelectScalar = {
    id?: boolean
    userId?: boolean
    settingId?: boolean
    communityId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    like?: boolean
    likeCount?: boolean
    commentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    repost?: boolean
    bookmark?: boolean
    communityGroup?: boolean
    viewCount?: boolean
    tag?: boolean
    mediaType?: boolean
    isPinned?: boolean
    tabCategory?: boolean
    isShared?: boolean
    musicalId?: boolean
    actorId?: boolean
    extraField?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "settingId" | "communityId" | "title" | "content" | "category" | "like" | "likeCount" | "commentCount" | "createdAt" | "updatedAt" | "repost" | "bookmark" | "communityGroup" | "viewCount" | "tag" | "mediaType" | "isPinned" | "tabCategory" | "isShared" | "musicalId" | "actorId" | "extraField", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    actor?: boolean | Post$actorArgs<ExtArgs>
    setting?: boolean | SettingDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    postLikes?: boolean | Post$postLikesArgs<ExtArgs>
    images?: boolean | Post$imagesArgs<ExtArgs>
    reviews?: boolean | Post$reviewsArgs<ExtArgs>
    tags?: boolean | Post$tagsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      actor: Prisma.$ActorPayload<ExtArgs> | null
      setting: Prisma.$SettingPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      postLikes: Prisma.$PostLikePayload<ExtArgs>[]
      images: Prisma.$ImagePayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      settingId: number
      communityId: number
      title: string | null
      content: string | null
      category: string | null
      like: string | null
      likeCount: number | null
      commentCount: number | null
      createdAt: Date | null
      updatedAt: Date | null
      repost: number | null
      bookmark: number | null
      communityGroup: string | null
      viewCount: number | null
      tag: string | null
      mediaType: $Enums.ImageOrVideo | null
      isPinned: boolean | null
      tabCategory: $Enums.Category | null
      isShared: boolean | null
      musicalId: number | null
      actorId: number | null
      extraField: string | null
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    actor<T extends Post$actorArgs<ExtArgs> = {}>(args?: Subset<T, Post$actorArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    setting<T extends SettingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SettingDefaultArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postLikes<T extends Post$postLikesArgs<ExtArgs> = {}>(args?: Subset<T, Post$postLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends Post$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Post$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Post$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Post$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Post$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Post$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly userId: FieldRef<"Post", 'Int'>
    readonly settingId: FieldRef<"Post", 'Int'>
    readonly communityId: FieldRef<"Post", 'Int'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly category: FieldRef<"Post", 'String'>
    readonly like: FieldRef<"Post", 'String'>
    readonly likeCount: FieldRef<"Post", 'Int'>
    readonly commentCount: FieldRef<"Post", 'Int'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly repost: FieldRef<"Post", 'Int'>
    readonly bookmark: FieldRef<"Post", 'Int'>
    readonly communityGroup: FieldRef<"Post", 'String'>
    readonly viewCount: FieldRef<"Post", 'Int'>
    readonly tag: FieldRef<"Post", 'String'>
    readonly mediaType: FieldRef<"Post", 'ImageOrVideo'>
    readonly isPinned: FieldRef<"Post", 'Boolean'>
    readonly tabCategory: FieldRef<"Post", 'Category'>
    readonly isShared: FieldRef<"Post", 'Boolean'>
    readonly musicalId: FieldRef<"Post", 'Int'>
    readonly actorId: FieldRef<"Post", 'Int'>
    readonly extraField: FieldRef<"Post", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.actor
   */
  export type Post$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    where?: ActorWhereInput
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.postLikes
   */
  export type Post$postLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    cursor?: PostLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * Post.images
   */
  export type Post$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Post.reviews
   */
  export type Post$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Post.tags
   */
  export type Post$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
    content: string | null
    createdAt: Date | null
    anonymous: boolean | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
    content: string | null
    createdAt: Date | null
    anonymous: boolean | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    settingId: number
    communityId: number
    content: number
    createdAt: number
    anonymous: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    settingId?: true
    communityId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    settingId?: true
    communityId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    settingId?: true
    communityId?: true
    content?: true
    createdAt?: true
    anonymous?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    settingId?: true
    communityId?: true
    content?: true
    createdAt?: true
    anonymous?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    settingId?: true
    communityId?: true
    content?: true
    createdAt?: true
    anonymous?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    postId: number
    userId: number
    settingId: number
    communityId: number
    content: string | null
    createdAt: Date | null
    anonymous: boolean | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    settingId?: boolean
    communityId?: boolean
    content?: boolean
    createdAt?: boolean
    anonymous?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>



  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    settingId?: boolean
    communityId?: boolean
    content?: boolean
    createdAt?: boolean
    anonymous?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "settingId" | "communityId" | "content" | "createdAt" | "anonymous", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      userId: number
      settingId: number
      communityId: number
      content: string | null
      createdAt: Date | null
      anonymous: boolean | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly postId: FieldRef<"Comment", 'Int'>
    readonly userId: FieldRef<"Comment", 'Int'>
    readonly settingId: FieldRef<"Comment", 'Int'>
    readonly communityId: FieldRef<"Comment", 'Int'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly anonymous: FieldRef<"Comment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    settingId: number | null
    theaterId: number | null
    key: number | null
    postId: number | null
    rating: number | null
    likeCount: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    userId: number | null
    settingId: number | null
    theaterId: number | null
    key: number | null
    postId: number | null
    rating: number | null
    likeCount: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    userId: number | null
    settingId: number | null
    theaterId: number | null
    key: number | null
    postId: number | null
    content: string | null
    rating: number | null
    spoiler: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    liked: string | null
    likeCount: number | null
    comment: string | null
    imageUrl: string | null
    reported: boolean | null
    watchDate: Date | null
    watchTime: Date | null
    extraField2: string | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    settingId: number | null
    theaterId: number | null
    key: number | null
    postId: number | null
    content: string | null
    rating: number | null
    spoiler: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    liked: string | null
    likeCount: number | null
    comment: string | null
    imageUrl: string | null
    reported: boolean | null
    watchDate: Date | null
    watchTime: Date | null
    extraField2: string | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    settingId: number
    theaterId: number
    key: number
    postId: number
    content: number
    rating: number
    spoiler: number
    createdAt: number
    updatedAt: number
    liked: number
    likeCount: number
    comment: number
    imageUrl: number
    reported: number
    watchDate: number
    watchTime: number
    extraField2: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
    theaterId?: true
    key?: true
    postId?: true
    rating?: true
    likeCount?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
    theaterId?: true
    key?: true
    postId?: true
    rating?: true
    likeCount?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
    theaterId?: true
    key?: true
    postId?: true
    content?: true
    rating?: true
    spoiler?: true
    createdAt?: true
    updatedAt?: true
    liked?: true
    likeCount?: true
    comment?: true
    imageUrl?: true
    reported?: true
    watchDate?: true
    watchTime?: true
    extraField2?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
    theaterId?: true
    key?: true
    postId?: true
    content?: true
    rating?: true
    spoiler?: true
    createdAt?: true
    updatedAt?: true
    liked?: true
    likeCount?: true
    comment?: true
    imageUrl?: true
    reported?: true
    watchDate?: true
    watchTime?: true
    extraField2?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
    theaterId?: true
    key?: true
    postId?: true
    content?: true
    rating?: true
    spoiler?: true
    createdAt?: true
    updatedAt?: true
    liked?: true
    likeCount?: true
    comment?: true
    imageUrl?: true
    reported?: true
    watchDate?: true
    watchTime?: true
    extraField2?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: number
    userId: number
    settingId: number
    theaterId: number
    key: number
    postId: number | null
    content: string | null
    rating: number | null
    spoiler: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    liked: string | null
    likeCount: number | null
    comment: string | null
    imageUrl: string | null
    reported: boolean | null
    watchDate: Date | null
    watchTime: Date | null
    extraField2: string | null
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    settingId?: boolean
    theaterId?: boolean
    key?: boolean
    postId?: boolean
    content?: boolean
    rating?: boolean
    spoiler?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    liked?: boolean
    likeCount?: boolean
    comment?: boolean
    imageUrl?: boolean
    reported?: boolean
    watchDate?: boolean
    watchTime?: boolean
    extraField2?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | Review$postArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>



  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    settingId?: boolean
    theaterId?: boolean
    key?: boolean
    postId?: boolean
    content?: boolean
    rating?: boolean
    spoiler?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    liked?: boolean
    likeCount?: boolean
    comment?: boolean
    imageUrl?: boolean
    reported?: boolean
    watchDate?: boolean
    watchTime?: boolean
    extraField2?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "settingId" | "theaterId" | "key" | "postId" | "content" | "rating" | "spoiler" | "createdAt" | "updatedAt" | "liked" | "likeCount" | "comment" | "imageUrl" | "reported" | "watchDate" | "watchTime" | "extraField2", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | Review$postArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      settingId: number
      theaterId: number
      key: number
      postId: number | null
      content: string | null
      rating: number | null
      spoiler: boolean | null
      createdAt: Date | null
      updatedAt: Date | null
      liked: string | null
      likeCount: number | null
      comment: string | null
      imageUrl: string | null
      reported: boolean | null
      watchDate: Date | null
      watchTime: Date | null
      extraField2: string | null
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends Review$postArgs<ExtArgs> = {}>(args?: Subset<T, Review$postArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'Int'>
    readonly userId: FieldRef<"Review", 'Int'>
    readonly settingId: FieldRef<"Review", 'Int'>
    readonly theaterId: FieldRef<"Review", 'Int'>
    readonly key: FieldRef<"Review", 'Int'>
    readonly postId: FieldRef<"Review", 'Int'>
    readonly content: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly spoiler: FieldRef<"Review", 'Boolean'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
    readonly liked: FieldRef<"Review", 'String'>
    readonly likeCount: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly imageUrl: FieldRef<"Review", 'String'>
    readonly reported: FieldRef<"Review", 'Boolean'>
    readonly watchDate: FieldRef<"Review", 'DateTime'>
    readonly watchTime: FieldRef<"Review", 'DateTime'>
    readonly extraField2: FieldRef<"Review", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.post
   */
  export type Review$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Actor
   */

  export type AggregateActor = {
    _count: ActorCountAggregateOutputType | null
    _avg: ActorAvgAggregateOutputType | null
    _sum: ActorSumAggregateOutputType | null
    _min: ActorMinAggregateOutputType | null
    _max: ActorMaxAggregateOutputType | null
  }

  export type ActorAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
    key: number | null
    fk: number | null
  }

  export type ActorSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
    key: number | null
    fk: number | null
  }

  export type ActorMinAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
    key: number | null
    name: string | null
    image: string | null
    profile: string | null
    snsLink: string | null
    fk: number | null
  }

  export type ActorMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    settingId: number | null
    communityId: number | null
    key: number | null
    name: string | null
    image: string | null
    profile: string | null
    snsLink: string | null
    fk: number | null
  }

  export type ActorCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    settingId: number
    communityId: number
    key: number
    name: number
    image: number
    profile: number
    snsLink: number
    fk: number
    _all: number
  }


  export type ActorAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    settingId?: true
    communityId?: true
    key?: true
    fk?: true
  }

  export type ActorSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    settingId?: true
    communityId?: true
    key?: true
    fk?: true
  }

  export type ActorMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    settingId?: true
    communityId?: true
    key?: true
    name?: true
    image?: true
    profile?: true
    snsLink?: true
    fk?: true
  }

  export type ActorMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    settingId?: true
    communityId?: true
    key?: true
    name?: true
    image?: true
    profile?: true
    snsLink?: true
    fk?: true
  }

  export type ActorCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    settingId?: true
    communityId?: true
    key?: true
    name?: true
    image?: true
    profile?: true
    snsLink?: true
    fk?: true
    _all?: true
  }

  export type ActorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actor to aggregate.
     */
    where?: ActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: ActorOrderByWithRelationInput | ActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actors
    **/
    _count?: true | ActorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActorMaxAggregateInputType
  }

  export type GetActorAggregateType<T extends ActorAggregateArgs> = {
        [P in keyof T & keyof AggregateActor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActor[P]>
      : GetScalarType<T[P], AggregateActor[P]>
  }




  export type ActorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActorWhereInput
    orderBy?: ActorOrderByWithAggregationInput | ActorOrderByWithAggregationInput[]
    by: ActorScalarFieldEnum[] | ActorScalarFieldEnum
    having?: ActorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActorCountAggregateInputType | true
    _avg?: ActorAvgAggregateInputType
    _sum?: ActorSumAggregateInputType
    _min?: ActorMinAggregateInputType
    _max?: ActorMaxAggregateInputType
  }

  export type ActorGroupByOutputType = {
    id: number
    postId: number
    userId: number
    settingId: number
    communityId: number
    key: number
    name: string | null
    image: string | null
    profile: string | null
    snsLink: string | null
    fk: number | null
    _count: ActorCountAggregateOutputType | null
    _avg: ActorAvgAggregateOutputType | null
    _sum: ActorSumAggregateOutputType | null
    _min: ActorMinAggregateOutputType | null
    _max: ActorMaxAggregateOutputType | null
  }

  type GetActorGroupByPayload<T extends ActorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActorGroupByOutputType[P]>
            : GetScalarType<T[P], ActorGroupByOutputType[P]>
        }
      >
    >


  export type ActorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    settingId?: boolean
    communityId?: boolean
    key?: boolean
    name?: boolean
    image?: boolean
    profile?: boolean
    snsLink?: boolean
    fk?: boolean
    posts?: boolean | Actor$postsArgs<ExtArgs>
    castings?: boolean | Actor$castingsArgs<ExtArgs>
    _count?: boolean | ActorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actor"]>



  export type ActorSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    settingId?: boolean
    communityId?: boolean
    key?: boolean
    name?: boolean
    image?: boolean
    profile?: boolean
    snsLink?: boolean
    fk?: boolean
  }

  export type ActorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "settingId" | "communityId" | "key" | "name" | "image" | "profile" | "snsLink" | "fk", ExtArgs["result"]["actor"]>
  export type ActorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Actor$postsArgs<ExtArgs>
    castings?: boolean | Actor$castingsArgs<ExtArgs>
    _count?: boolean | ActorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ActorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Actor"
    objects: {
      posts: Prisma.$PostPayload<ExtArgs>[]
      castings: Prisma.$CastingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      userId: number
      settingId: number
      communityId: number
      key: number
      name: string | null
      image: string | null
      profile: string | null
      snsLink: string | null
      fk: number | null
    }, ExtArgs["result"]["actor"]>
    composites: {}
  }

  type ActorGetPayload<S extends boolean | null | undefined | ActorDefaultArgs> = $Result.GetResult<Prisma.$ActorPayload, S>

  type ActorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActorCountAggregateInputType | true
    }

  export interface ActorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Actor'], meta: { name: 'Actor' } }
    /**
     * Find zero or one Actor that matches the filter.
     * @param {ActorFindUniqueArgs} args - Arguments to find a Actor
     * @example
     * // Get one Actor
     * const actor = await prisma.actor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActorFindUniqueArgs>(args: SelectSubset<T, ActorFindUniqueArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Actor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActorFindUniqueOrThrowArgs} args - Arguments to find a Actor
     * @example
     * // Get one Actor
     * const actor = await prisma.actor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActorFindUniqueOrThrowArgs>(args: SelectSubset<T, ActorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Actor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorFindFirstArgs} args - Arguments to find a Actor
     * @example
     * // Get one Actor
     * const actor = await prisma.actor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActorFindFirstArgs>(args?: SelectSubset<T, ActorFindFirstArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Actor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorFindFirstOrThrowArgs} args - Arguments to find a Actor
     * @example
     * // Get one Actor
     * const actor = await prisma.actor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActorFindFirstOrThrowArgs>(args?: SelectSubset<T, ActorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Actors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actors
     * const actors = await prisma.actor.findMany()
     * 
     * // Get first 10 Actors
     * const actors = await prisma.actor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actorWithIdOnly = await prisma.actor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActorFindManyArgs>(args?: SelectSubset<T, ActorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Actor.
     * @param {ActorCreateArgs} args - Arguments to create a Actor.
     * @example
     * // Create one Actor
     * const Actor = await prisma.actor.create({
     *   data: {
     *     // ... data to create a Actor
     *   }
     * })
     * 
     */
    create<T extends ActorCreateArgs>(args: SelectSubset<T, ActorCreateArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Actors.
     * @param {ActorCreateManyArgs} args - Arguments to create many Actors.
     * @example
     * // Create many Actors
     * const actor = await prisma.actor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActorCreateManyArgs>(args?: SelectSubset<T, ActorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Actor.
     * @param {ActorDeleteArgs} args - Arguments to delete one Actor.
     * @example
     * // Delete one Actor
     * const Actor = await prisma.actor.delete({
     *   where: {
     *     // ... filter to delete one Actor
     *   }
     * })
     * 
     */
    delete<T extends ActorDeleteArgs>(args: SelectSubset<T, ActorDeleteArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Actor.
     * @param {ActorUpdateArgs} args - Arguments to update one Actor.
     * @example
     * // Update one Actor
     * const actor = await prisma.actor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActorUpdateArgs>(args: SelectSubset<T, ActorUpdateArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Actors.
     * @param {ActorDeleteManyArgs} args - Arguments to filter Actors to delete.
     * @example
     * // Delete a few Actors
     * const { count } = await prisma.actor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActorDeleteManyArgs>(args?: SelectSubset<T, ActorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actors
     * const actor = await prisma.actor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActorUpdateManyArgs>(args: SelectSubset<T, ActorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Actor.
     * @param {ActorUpsertArgs} args - Arguments to update or create a Actor.
     * @example
     * // Update or create a Actor
     * const actor = await prisma.actor.upsert({
     *   create: {
     *     // ... data to create a Actor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actor we want to update
     *   }
     * })
     */
    upsert<T extends ActorUpsertArgs>(args: SelectSubset<T, ActorUpsertArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Actors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorCountArgs} args - Arguments to filter Actors to count.
     * @example
     * // Count the number of Actors
     * const count = await prisma.actor.count({
     *   where: {
     *     // ... the filter for the Actors we want to count
     *   }
     * })
    **/
    count<T extends ActorCountArgs>(
      args?: Subset<T, ActorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActorAggregateArgs>(args: Subset<T, ActorAggregateArgs>): Prisma.PrismaPromise<GetActorAggregateType<T>>

    /**
     * Group by Actor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActorGroupByArgs['orderBy'] }
        : { orderBy?: ActorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Actor model
   */
  readonly fields: ActorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Actor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Actor$postsArgs<ExtArgs> = {}>(args?: Subset<T, Actor$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    castings<T extends Actor$castingsArgs<ExtArgs> = {}>(args?: Subset<T, Actor$castingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Actor model
   */
  interface ActorFieldRefs {
    readonly id: FieldRef<"Actor", 'Int'>
    readonly postId: FieldRef<"Actor", 'Int'>
    readonly userId: FieldRef<"Actor", 'Int'>
    readonly settingId: FieldRef<"Actor", 'Int'>
    readonly communityId: FieldRef<"Actor", 'Int'>
    readonly key: FieldRef<"Actor", 'Int'>
    readonly name: FieldRef<"Actor", 'String'>
    readonly image: FieldRef<"Actor", 'String'>
    readonly profile: FieldRef<"Actor", 'String'>
    readonly snsLink: FieldRef<"Actor", 'String'>
    readonly fk: FieldRef<"Actor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Actor findUnique
   */
  export type ActorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter, which Actor to fetch.
     */
    where: ActorWhereUniqueInput
  }

  /**
   * Actor findUniqueOrThrow
   */
  export type ActorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter, which Actor to fetch.
     */
    where: ActorWhereUniqueInput
  }

  /**
   * Actor findFirst
   */
  export type ActorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter, which Actor to fetch.
     */
    where?: ActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: ActorOrderByWithRelationInput | ActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actors.
     */
    cursor?: ActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actors.
     */
    distinct?: ActorScalarFieldEnum | ActorScalarFieldEnum[]
  }

  /**
   * Actor findFirstOrThrow
   */
  export type ActorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter, which Actor to fetch.
     */
    where?: ActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: ActorOrderByWithRelationInput | ActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actors.
     */
    cursor?: ActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actors.
     */
    distinct?: ActorScalarFieldEnum | ActorScalarFieldEnum[]
  }

  /**
   * Actor findMany
   */
  export type ActorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter, which Actors to fetch.
     */
    where?: ActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: ActorOrderByWithRelationInput | ActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actors.
     */
    cursor?: ActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    distinct?: ActorScalarFieldEnum | ActorScalarFieldEnum[]
  }

  /**
   * Actor create
   */
  export type ActorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * The data needed to create a Actor.
     */
    data: XOR<ActorCreateInput, ActorUncheckedCreateInput>
  }

  /**
   * Actor createMany
   */
  export type ActorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actors.
     */
    data: ActorCreateManyInput | ActorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Actor update
   */
  export type ActorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * The data needed to update a Actor.
     */
    data: XOR<ActorUpdateInput, ActorUncheckedUpdateInput>
    /**
     * Choose, which Actor to update.
     */
    where: ActorWhereUniqueInput
  }

  /**
   * Actor updateMany
   */
  export type ActorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actors.
     */
    data: XOR<ActorUpdateManyMutationInput, ActorUncheckedUpdateManyInput>
    /**
     * Filter which Actors to update
     */
    where?: ActorWhereInput
    /**
     * Limit how many Actors to update.
     */
    limit?: number
  }

  /**
   * Actor upsert
   */
  export type ActorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * The filter to search for the Actor to update in case it exists.
     */
    where: ActorWhereUniqueInput
    /**
     * In case the Actor found by the `where` argument doesn't exist, create a new Actor with this data.
     */
    create: XOR<ActorCreateInput, ActorUncheckedCreateInput>
    /**
     * In case the Actor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActorUpdateInput, ActorUncheckedUpdateInput>
  }

  /**
   * Actor delete
   */
  export type ActorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
    /**
     * Filter which Actor to delete.
     */
    where: ActorWhereUniqueInput
  }

  /**
   * Actor deleteMany
   */
  export type ActorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actors to delete
     */
    where?: ActorWhereInput
    /**
     * Limit how many Actors to delete.
     */
    limit?: number
  }

  /**
   * Actor.posts
   */
  export type Actor$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Actor.castings
   */
  export type Actor$castingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
    where?: CastingWhereInput
    orderBy?: CastingOrderByWithRelationInput | CastingOrderByWithRelationInput[]
    cursor?: CastingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CastingScalarFieldEnum | CastingScalarFieldEnum[]
  }

  /**
   * Actor without action
   */
  export type ActorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actor
     */
    select?: ActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actor
     */
    omit?: ActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActorInclude<ExtArgs> | null
  }


  /**
   * Model Musical
   */

  export type AggregateMusical = {
    _count: MusicalCountAggregateOutputType | null
    _avg: MusicalAvgAggregateOutputType | null
    _sum: MusicalSumAggregateOutputType | null
    _min: MusicalMinAggregateOutputType | null
    _max: MusicalMaxAggregateOutputType | null
  }

  export type MusicalAvgAggregateOutputType = {
    id: number | null
    theaterId: number | null
  }

  export type MusicalSumAggregateOutputType = {
    id: number | null
    theaterId: number | null
  }

  export type MusicalMinAggregateOutputType = {
    id: number | null
    theaterId: number | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    poster: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MusicalMaxAggregateOutputType = {
    id: number | null
    theaterId: number | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    poster: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MusicalCountAggregateOutputType = {
    id: number
    theaterId: number
    name: number
    startDate: number
    endDate: number
    poster: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MusicalAvgAggregateInputType = {
    id?: true
    theaterId?: true
  }

  export type MusicalSumAggregateInputType = {
    id?: true
    theaterId?: true
  }

  export type MusicalMinAggregateInputType = {
    id?: true
    theaterId?: true
    name?: true
    startDate?: true
    endDate?: true
    poster?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MusicalMaxAggregateInputType = {
    id?: true
    theaterId?: true
    name?: true
    startDate?: true
    endDate?: true
    poster?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MusicalCountAggregateInputType = {
    id?: true
    theaterId?: true
    name?: true
    startDate?: true
    endDate?: true
    poster?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MusicalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Musical to aggregate.
     */
    where?: MusicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musicals to fetch.
     */
    orderBy?: MusicalOrderByWithRelationInput | MusicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MusicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Musicals
    **/
    _count?: true | MusicalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MusicalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MusicalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MusicalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MusicalMaxAggregateInputType
  }

  export type GetMusicalAggregateType<T extends MusicalAggregateArgs> = {
        [P in keyof T & keyof AggregateMusical]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMusical[P]>
      : GetScalarType<T[P], AggregateMusical[P]>
  }




  export type MusicalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MusicalWhereInput
    orderBy?: MusicalOrderByWithAggregationInput | MusicalOrderByWithAggregationInput[]
    by: MusicalScalarFieldEnum[] | MusicalScalarFieldEnum
    having?: MusicalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MusicalCountAggregateInputType | true
    _avg?: MusicalAvgAggregateInputType
    _sum?: MusicalSumAggregateInputType
    _min?: MusicalMinAggregateInputType
    _max?: MusicalMaxAggregateInputType
  }

  export type MusicalGroupByOutputType = {
    id: number
    theaterId: number
    name: string | null
    startDate: Date | null
    endDate: Date | null
    poster: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: MusicalCountAggregateOutputType | null
    _avg: MusicalAvgAggregateOutputType | null
    _sum: MusicalSumAggregateOutputType | null
    _min: MusicalMinAggregateOutputType | null
    _max: MusicalMaxAggregateOutputType | null
  }

  type GetMusicalGroupByPayload<T extends MusicalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MusicalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MusicalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MusicalGroupByOutputType[P]>
            : GetScalarType<T[P], MusicalGroupByOutputType[P]>
        }
      >
    >


  export type MusicalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theaterId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    poster?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    theater?: boolean | TheaterDefaultArgs<ExtArgs>
    castings?: boolean | Musical$castingsArgs<ExtArgs>
    viewings?: boolean | Musical$viewingsArgs<ExtArgs>
    communities?: boolean | Musical$communitiesArgs<ExtArgs>
    _count?: boolean | MusicalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["musical"]>



  export type MusicalSelectScalar = {
    id?: boolean
    theaterId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    poster?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MusicalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "theaterId" | "name" | "startDate" | "endDate" | "poster" | "createdAt" | "updatedAt", ExtArgs["result"]["musical"]>
  export type MusicalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    theater?: boolean | TheaterDefaultArgs<ExtArgs>
    castings?: boolean | Musical$castingsArgs<ExtArgs>
    viewings?: boolean | Musical$viewingsArgs<ExtArgs>
    communities?: boolean | Musical$communitiesArgs<ExtArgs>
    _count?: boolean | MusicalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MusicalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Musical"
    objects: {
      theater: Prisma.$TheaterPayload<ExtArgs>
      castings: Prisma.$CastingPayload<ExtArgs>[]
      viewings: Prisma.$ViewingRecordPayload<ExtArgs>[]
      communities: Prisma.$MusicalCommunityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      theaterId: number
      name: string | null
      startDate: Date | null
      endDate: Date | null
      poster: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["musical"]>
    composites: {}
  }

  type MusicalGetPayload<S extends boolean | null | undefined | MusicalDefaultArgs> = $Result.GetResult<Prisma.$MusicalPayload, S>

  type MusicalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MusicalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MusicalCountAggregateInputType | true
    }

  export interface MusicalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Musical'], meta: { name: 'Musical' } }
    /**
     * Find zero or one Musical that matches the filter.
     * @param {MusicalFindUniqueArgs} args - Arguments to find a Musical
     * @example
     * // Get one Musical
     * const musical = await prisma.musical.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MusicalFindUniqueArgs>(args: SelectSubset<T, MusicalFindUniqueArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Musical that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MusicalFindUniqueOrThrowArgs} args - Arguments to find a Musical
     * @example
     * // Get one Musical
     * const musical = await prisma.musical.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MusicalFindUniqueOrThrowArgs>(args: SelectSubset<T, MusicalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Musical that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalFindFirstArgs} args - Arguments to find a Musical
     * @example
     * // Get one Musical
     * const musical = await prisma.musical.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MusicalFindFirstArgs>(args?: SelectSubset<T, MusicalFindFirstArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Musical that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalFindFirstOrThrowArgs} args - Arguments to find a Musical
     * @example
     * // Get one Musical
     * const musical = await prisma.musical.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MusicalFindFirstOrThrowArgs>(args?: SelectSubset<T, MusicalFindFirstOrThrowArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Musicals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Musicals
     * const musicals = await prisma.musical.findMany()
     * 
     * // Get first 10 Musicals
     * const musicals = await prisma.musical.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const musicalWithIdOnly = await prisma.musical.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MusicalFindManyArgs>(args?: SelectSubset<T, MusicalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Musical.
     * @param {MusicalCreateArgs} args - Arguments to create a Musical.
     * @example
     * // Create one Musical
     * const Musical = await prisma.musical.create({
     *   data: {
     *     // ... data to create a Musical
     *   }
     * })
     * 
     */
    create<T extends MusicalCreateArgs>(args: SelectSubset<T, MusicalCreateArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Musicals.
     * @param {MusicalCreateManyArgs} args - Arguments to create many Musicals.
     * @example
     * // Create many Musicals
     * const musical = await prisma.musical.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MusicalCreateManyArgs>(args?: SelectSubset<T, MusicalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Musical.
     * @param {MusicalDeleteArgs} args - Arguments to delete one Musical.
     * @example
     * // Delete one Musical
     * const Musical = await prisma.musical.delete({
     *   where: {
     *     // ... filter to delete one Musical
     *   }
     * })
     * 
     */
    delete<T extends MusicalDeleteArgs>(args: SelectSubset<T, MusicalDeleteArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Musical.
     * @param {MusicalUpdateArgs} args - Arguments to update one Musical.
     * @example
     * // Update one Musical
     * const musical = await prisma.musical.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MusicalUpdateArgs>(args: SelectSubset<T, MusicalUpdateArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Musicals.
     * @param {MusicalDeleteManyArgs} args - Arguments to filter Musicals to delete.
     * @example
     * // Delete a few Musicals
     * const { count } = await prisma.musical.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MusicalDeleteManyArgs>(args?: SelectSubset<T, MusicalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Musicals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Musicals
     * const musical = await prisma.musical.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MusicalUpdateManyArgs>(args: SelectSubset<T, MusicalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Musical.
     * @param {MusicalUpsertArgs} args - Arguments to update or create a Musical.
     * @example
     * // Update or create a Musical
     * const musical = await prisma.musical.upsert({
     *   create: {
     *     // ... data to create a Musical
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Musical we want to update
     *   }
     * })
     */
    upsert<T extends MusicalUpsertArgs>(args: SelectSubset<T, MusicalUpsertArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Musicals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalCountArgs} args - Arguments to filter Musicals to count.
     * @example
     * // Count the number of Musicals
     * const count = await prisma.musical.count({
     *   where: {
     *     // ... the filter for the Musicals we want to count
     *   }
     * })
    **/
    count<T extends MusicalCountArgs>(
      args?: Subset<T, MusicalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MusicalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Musical.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MusicalAggregateArgs>(args: Subset<T, MusicalAggregateArgs>): Prisma.PrismaPromise<GetMusicalAggregateType<T>>

    /**
     * Group by Musical.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MusicalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MusicalGroupByArgs['orderBy'] }
        : { orderBy?: MusicalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MusicalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMusicalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Musical model
   */
  readonly fields: MusicalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Musical.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MusicalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    theater<T extends TheaterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TheaterDefaultArgs<ExtArgs>>): Prisma__TheaterClient<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    castings<T extends Musical$castingsArgs<ExtArgs> = {}>(args?: Subset<T, Musical$castingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewings<T extends Musical$viewingsArgs<ExtArgs> = {}>(args?: Subset<T, Musical$viewingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewingRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communities<T extends Musical$communitiesArgs<ExtArgs> = {}>(args?: Subset<T, Musical$communitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MusicalCommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Musical model
   */
  interface MusicalFieldRefs {
    readonly id: FieldRef<"Musical", 'Int'>
    readonly theaterId: FieldRef<"Musical", 'Int'>
    readonly name: FieldRef<"Musical", 'String'>
    readonly startDate: FieldRef<"Musical", 'DateTime'>
    readonly endDate: FieldRef<"Musical", 'DateTime'>
    readonly poster: FieldRef<"Musical", 'String'>
    readonly createdAt: FieldRef<"Musical", 'DateTime'>
    readonly updatedAt: FieldRef<"Musical", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Musical findUnique
   */
  export type MusicalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Musical
     */
    omit?: MusicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter, which Musical to fetch.
     */
    where: MusicalWhereUniqueInput
  }

  /**
   * Musical findUniqueOrThrow
   */
  export type MusicalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Musical
     */
    omit?: MusicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter, which Musical to fetch.
     */
    where: MusicalWhereUniqueInput
  }

  /**
   * Musical findFirst
   */
  export type MusicalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Musical
     */
    omit?: MusicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter, which Musical to fetch.
     */
    where?: MusicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musicals to fetch.
     */
    orderBy?: MusicalOrderByWithRelationInput | MusicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Musicals.
     */
    cursor?: MusicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Musicals.
     */
    distinct?: MusicalScalarFieldEnum | MusicalScalarFieldEnum[]
  }

  /**
   * Musical findFirstOrThrow
   */
  export type MusicalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Musical
     */
    omit?: MusicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter, which Musical to fetch.
     */
    where?: MusicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musicals to fetch.
     */
    orderBy?: MusicalOrderByWithRelationInput | MusicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Musicals.
     */
    cursor?: MusicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Musicals.
     */
    distinct?: MusicalScalarFieldEnum | MusicalScalarFieldEnum[]
  }

  /**
   * Musical findMany
   */
  export type MusicalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Musical
     */
    omit?: MusicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter, which Musicals to fetch.
     */
    where?: MusicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musicals to fetch.
     */
    orderBy?: MusicalOrderByWithRelationInput | MusicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Musicals.
     */
    cursor?: MusicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musicals.
     */
    skip?: number
    distinct?: MusicalScalarFieldEnum | MusicalScalarFieldEnum[]
  }

  /**
   * Musical create
   */
  export type MusicalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Musical
     */
    omit?: MusicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * The data needed to create a Musical.
     */
    data: XOR<MusicalCreateInput, MusicalUncheckedCreateInput>
  }

  /**
   * Musical createMany
   */
  export type MusicalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Musicals.
     */
    data: MusicalCreateManyInput | MusicalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Musical update
   */
  export type MusicalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Musical
     */
    omit?: MusicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * The data needed to update a Musical.
     */
    data: XOR<MusicalUpdateInput, MusicalUncheckedUpdateInput>
    /**
     * Choose, which Musical to update.
     */
    where: MusicalWhereUniqueInput
  }

  /**
   * Musical updateMany
   */
  export type MusicalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Musicals.
     */
    data: XOR<MusicalUpdateManyMutationInput, MusicalUncheckedUpdateManyInput>
    /**
     * Filter which Musicals to update
     */
    where?: MusicalWhereInput
    /**
     * Limit how many Musicals to update.
     */
    limit?: number
  }

  /**
   * Musical upsert
   */
  export type MusicalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Musical
     */
    omit?: MusicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * The filter to search for the Musical to update in case it exists.
     */
    where: MusicalWhereUniqueInput
    /**
     * In case the Musical found by the `where` argument doesn't exist, create a new Musical with this data.
     */
    create: XOR<MusicalCreateInput, MusicalUncheckedCreateInput>
    /**
     * In case the Musical was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MusicalUpdateInput, MusicalUncheckedUpdateInput>
  }

  /**
   * Musical delete
   */
  export type MusicalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Musical
     */
    omit?: MusicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter which Musical to delete.
     */
    where: MusicalWhereUniqueInput
  }

  /**
   * Musical deleteMany
   */
  export type MusicalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Musicals to delete
     */
    where?: MusicalWhereInput
    /**
     * Limit how many Musicals to delete.
     */
    limit?: number
  }

  /**
   * Musical.castings
   */
  export type Musical$castingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
    where?: CastingWhereInput
    orderBy?: CastingOrderByWithRelationInput | CastingOrderByWithRelationInput[]
    cursor?: CastingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CastingScalarFieldEnum | CastingScalarFieldEnum[]
  }

  /**
   * Musical.viewings
   */
  export type Musical$viewingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
    where?: ViewingRecordWhereInput
    orderBy?: ViewingRecordOrderByWithRelationInput | ViewingRecordOrderByWithRelationInput[]
    cursor?: ViewingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewingRecordScalarFieldEnum | ViewingRecordScalarFieldEnum[]
  }

  /**
   * Musical.communities
   */
  export type Musical$communitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
    where?: MusicalCommunityWhereInput
    orderBy?: MusicalCommunityOrderByWithRelationInput | MusicalCommunityOrderByWithRelationInput[]
    cursor?: MusicalCommunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MusicalCommunityScalarFieldEnum | MusicalCommunityScalarFieldEnum[]
  }

  /**
   * Musical without action
   */
  export type MusicalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Musical
     */
    omit?: MusicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
  }


  /**
   * Model Theater
   */

  export type AggregateTheater = {
    _count: TheaterCountAggregateOutputType | null
    _avg: TheaterAvgAggregateOutputType | null
    _sum: TheaterSumAggregateOutputType | null
    _min: TheaterMinAggregateOutputType | null
    _max: TheaterMaxAggregateOutputType | null
  }

  export type TheaterAvgAggregateOutputType = {
    id: number | null
    regionId: number | null
    seatCount: number | null
  }

  export type TheaterSumAggregateOutputType = {
    id: number | null
    regionId: number | null
    seatCount: number | null
  }

  export type TheaterMinAggregateOutputType = {
    id: number | null
    regionId: number | null
    name: string | null
    seatCount: number | null
    roadAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TheaterMaxAggregateOutputType = {
    id: number | null
    regionId: number | null
    name: string | null
    seatCount: number | null
    roadAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TheaterCountAggregateOutputType = {
    id: number
    regionId: number
    name: number
    seatCount: number
    roadAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TheaterAvgAggregateInputType = {
    id?: true
    regionId?: true
    seatCount?: true
  }

  export type TheaterSumAggregateInputType = {
    id?: true
    regionId?: true
    seatCount?: true
  }

  export type TheaterMinAggregateInputType = {
    id?: true
    regionId?: true
    name?: true
    seatCount?: true
    roadAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TheaterMaxAggregateInputType = {
    id?: true
    regionId?: true
    name?: true
    seatCount?: true
    roadAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TheaterCountAggregateInputType = {
    id?: true
    regionId?: true
    name?: true
    seatCount?: true
    roadAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TheaterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Theater to aggregate.
     */
    where?: TheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Theaters to fetch.
     */
    orderBy?: TheaterOrderByWithRelationInput | TheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Theaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Theaters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Theaters
    **/
    _count?: true | TheaterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TheaterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TheaterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TheaterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TheaterMaxAggregateInputType
  }

  export type GetTheaterAggregateType<T extends TheaterAggregateArgs> = {
        [P in keyof T & keyof AggregateTheater]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTheater[P]>
      : GetScalarType<T[P], AggregateTheater[P]>
  }




  export type TheaterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TheaterWhereInput
    orderBy?: TheaterOrderByWithAggregationInput | TheaterOrderByWithAggregationInput[]
    by: TheaterScalarFieldEnum[] | TheaterScalarFieldEnum
    having?: TheaterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TheaterCountAggregateInputType | true
    _avg?: TheaterAvgAggregateInputType
    _sum?: TheaterSumAggregateInputType
    _min?: TheaterMinAggregateInputType
    _max?: TheaterMaxAggregateInputType
  }

  export type TheaterGroupByOutputType = {
    id: number
    regionId: number
    name: string | null
    seatCount: number | null
    roadAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: TheaterCountAggregateOutputType | null
    _avg: TheaterAvgAggregateOutputType | null
    _sum: TheaterSumAggregateOutputType | null
    _min: TheaterMinAggregateOutputType | null
    _max: TheaterMaxAggregateOutputType | null
  }

  type GetTheaterGroupByPayload<T extends TheaterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TheaterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TheaterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TheaterGroupByOutputType[P]>
            : GetScalarType<T[P], TheaterGroupByOutputType[P]>
        }
      >
    >


  export type TheaterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    name?: boolean
    seatCount?: boolean
    roadAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    musicals?: boolean | Theater$musicalsArgs<ExtArgs>
    seats?: boolean | Theater$seatsArgs<ExtArgs>
    _count?: boolean | TheaterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["theater"]>



  export type TheaterSelectScalar = {
    id?: boolean
    regionId?: boolean
    name?: boolean
    seatCount?: boolean
    roadAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TheaterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regionId" | "name" | "seatCount" | "roadAddress" | "createdAt" | "updatedAt", ExtArgs["result"]["theater"]>
  export type TheaterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    musicals?: boolean | Theater$musicalsArgs<ExtArgs>
    seats?: boolean | Theater$seatsArgs<ExtArgs>
    _count?: boolean | TheaterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TheaterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Theater"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      musicals: Prisma.$MusicalPayload<ExtArgs>[]
      seats: Prisma.$SeatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regionId: number
      name: string | null
      seatCount: number | null
      roadAddress: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["theater"]>
    composites: {}
  }

  type TheaterGetPayload<S extends boolean | null | undefined | TheaterDefaultArgs> = $Result.GetResult<Prisma.$TheaterPayload, S>

  type TheaterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TheaterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TheaterCountAggregateInputType | true
    }

  export interface TheaterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Theater'], meta: { name: 'Theater' } }
    /**
     * Find zero or one Theater that matches the filter.
     * @param {TheaterFindUniqueArgs} args - Arguments to find a Theater
     * @example
     * // Get one Theater
     * const theater = await prisma.theater.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TheaterFindUniqueArgs>(args: SelectSubset<T, TheaterFindUniqueArgs<ExtArgs>>): Prisma__TheaterClient<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Theater that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TheaterFindUniqueOrThrowArgs} args - Arguments to find a Theater
     * @example
     * // Get one Theater
     * const theater = await prisma.theater.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TheaterFindUniqueOrThrowArgs>(args: SelectSubset<T, TheaterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TheaterClient<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Theater that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TheaterFindFirstArgs} args - Arguments to find a Theater
     * @example
     * // Get one Theater
     * const theater = await prisma.theater.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TheaterFindFirstArgs>(args?: SelectSubset<T, TheaterFindFirstArgs<ExtArgs>>): Prisma__TheaterClient<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Theater that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TheaterFindFirstOrThrowArgs} args - Arguments to find a Theater
     * @example
     * // Get one Theater
     * const theater = await prisma.theater.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TheaterFindFirstOrThrowArgs>(args?: SelectSubset<T, TheaterFindFirstOrThrowArgs<ExtArgs>>): Prisma__TheaterClient<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Theaters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TheaterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Theaters
     * const theaters = await prisma.theater.findMany()
     * 
     * // Get first 10 Theaters
     * const theaters = await prisma.theater.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const theaterWithIdOnly = await prisma.theater.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TheaterFindManyArgs>(args?: SelectSubset<T, TheaterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Theater.
     * @param {TheaterCreateArgs} args - Arguments to create a Theater.
     * @example
     * // Create one Theater
     * const Theater = await prisma.theater.create({
     *   data: {
     *     // ... data to create a Theater
     *   }
     * })
     * 
     */
    create<T extends TheaterCreateArgs>(args: SelectSubset<T, TheaterCreateArgs<ExtArgs>>): Prisma__TheaterClient<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Theaters.
     * @param {TheaterCreateManyArgs} args - Arguments to create many Theaters.
     * @example
     * // Create many Theaters
     * const theater = await prisma.theater.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TheaterCreateManyArgs>(args?: SelectSubset<T, TheaterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Theater.
     * @param {TheaterDeleteArgs} args - Arguments to delete one Theater.
     * @example
     * // Delete one Theater
     * const Theater = await prisma.theater.delete({
     *   where: {
     *     // ... filter to delete one Theater
     *   }
     * })
     * 
     */
    delete<T extends TheaterDeleteArgs>(args: SelectSubset<T, TheaterDeleteArgs<ExtArgs>>): Prisma__TheaterClient<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Theater.
     * @param {TheaterUpdateArgs} args - Arguments to update one Theater.
     * @example
     * // Update one Theater
     * const theater = await prisma.theater.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TheaterUpdateArgs>(args: SelectSubset<T, TheaterUpdateArgs<ExtArgs>>): Prisma__TheaterClient<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Theaters.
     * @param {TheaterDeleteManyArgs} args - Arguments to filter Theaters to delete.
     * @example
     * // Delete a few Theaters
     * const { count } = await prisma.theater.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TheaterDeleteManyArgs>(args?: SelectSubset<T, TheaterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Theaters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TheaterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Theaters
     * const theater = await prisma.theater.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TheaterUpdateManyArgs>(args: SelectSubset<T, TheaterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Theater.
     * @param {TheaterUpsertArgs} args - Arguments to update or create a Theater.
     * @example
     * // Update or create a Theater
     * const theater = await prisma.theater.upsert({
     *   create: {
     *     // ... data to create a Theater
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Theater we want to update
     *   }
     * })
     */
    upsert<T extends TheaterUpsertArgs>(args: SelectSubset<T, TheaterUpsertArgs<ExtArgs>>): Prisma__TheaterClient<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Theaters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TheaterCountArgs} args - Arguments to filter Theaters to count.
     * @example
     * // Count the number of Theaters
     * const count = await prisma.theater.count({
     *   where: {
     *     // ... the filter for the Theaters we want to count
     *   }
     * })
    **/
    count<T extends TheaterCountArgs>(
      args?: Subset<T, TheaterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TheaterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Theater.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TheaterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TheaterAggregateArgs>(args: Subset<T, TheaterAggregateArgs>): Prisma.PrismaPromise<GetTheaterAggregateType<T>>

    /**
     * Group by Theater.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TheaterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TheaterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TheaterGroupByArgs['orderBy'] }
        : { orderBy?: TheaterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TheaterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTheaterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Theater model
   */
  readonly fields: TheaterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Theater.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TheaterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    musicals<T extends Theater$musicalsArgs<ExtArgs> = {}>(args?: Subset<T, Theater$musicalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seats<T extends Theater$seatsArgs<ExtArgs> = {}>(args?: Subset<T, Theater$seatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Theater model
   */
  interface TheaterFieldRefs {
    readonly id: FieldRef<"Theater", 'Int'>
    readonly regionId: FieldRef<"Theater", 'Int'>
    readonly name: FieldRef<"Theater", 'String'>
    readonly seatCount: FieldRef<"Theater", 'Int'>
    readonly roadAddress: FieldRef<"Theater", 'String'>
    readonly createdAt: FieldRef<"Theater", 'DateTime'>
    readonly updatedAt: FieldRef<"Theater", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Theater findUnique
   */
  export type TheaterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theater
     */
    select?: TheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theater
     */
    omit?: TheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TheaterInclude<ExtArgs> | null
    /**
     * Filter, which Theater to fetch.
     */
    where: TheaterWhereUniqueInput
  }

  /**
   * Theater findUniqueOrThrow
   */
  export type TheaterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theater
     */
    select?: TheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theater
     */
    omit?: TheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TheaterInclude<ExtArgs> | null
    /**
     * Filter, which Theater to fetch.
     */
    where: TheaterWhereUniqueInput
  }

  /**
   * Theater findFirst
   */
  export type TheaterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theater
     */
    select?: TheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theater
     */
    omit?: TheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TheaterInclude<ExtArgs> | null
    /**
     * Filter, which Theater to fetch.
     */
    where?: TheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Theaters to fetch.
     */
    orderBy?: TheaterOrderByWithRelationInput | TheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Theaters.
     */
    cursor?: TheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Theaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Theaters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Theaters.
     */
    distinct?: TheaterScalarFieldEnum | TheaterScalarFieldEnum[]
  }

  /**
   * Theater findFirstOrThrow
   */
  export type TheaterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theater
     */
    select?: TheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theater
     */
    omit?: TheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TheaterInclude<ExtArgs> | null
    /**
     * Filter, which Theater to fetch.
     */
    where?: TheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Theaters to fetch.
     */
    orderBy?: TheaterOrderByWithRelationInput | TheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Theaters.
     */
    cursor?: TheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Theaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Theaters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Theaters.
     */
    distinct?: TheaterScalarFieldEnum | TheaterScalarFieldEnum[]
  }

  /**
   * Theater findMany
   */
  export type TheaterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theater
     */
    select?: TheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theater
     */
    omit?: TheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TheaterInclude<ExtArgs> | null
    /**
     * Filter, which Theaters to fetch.
     */
    where?: TheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Theaters to fetch.
     */
    orderBy?: TheaterOrderByWithRelationInput | TheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Theaters.
     */
    cursor?: TheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Theaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Theaters.
     */
    skip?: number
    distinct?: TheaterScalarFieldEnum | TheaterScalarFieldEnum[]
  }

  /**
   * Theater create
   */
  export type TheaterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theater
     */
    select?: TheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theater
     */
    omit?: TheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TheaterInclude<ExtArgs> | null
    /**
     * The data needed to create a Theater.
     */
    data: XOR<TheaterCreateInput, TheaterUncheckedCreateInput>
  }

  /**
   * Theater createMany
   */
  export type TheaterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Theaters.
     */
    data: TheaterCreateManyInput | TheaterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Theater update
   */
  export type TheaterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theater
     */
    select?: TheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theater
     */
    omit?: TheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TheaterInclude<ExtArgs> | null
    /**
     * The data needed to update a Theater.
     */
    data: XOR<TheaterUpdateInput, TheaterUncheckedUpdateInput>
    /**
     * Choose, which Theater to update.
     */
    where: TheaterWhereUniqueInput
  }

  /**
   * Theater updateMany
   */
  export type TheaterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Theaters.
     */
    data: XOR<TheaterUpdateManyMutationInput, TheaterUncheckedUpdateManyInput>
    /**
     * Filter which Theaters to update
     */
    where?: TheaterWhereInput
    /**
     * Limit how many Theaters to update.
     */
    limit?: number
  }

  /**
   * Theater upsert
   */
  export type TheaterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theater
     */
    select?: TheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theater
     */
    omit?: TheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TheaterInclude<ExtArgs> | null
    /**
     * The filter to search for the Theater to update in case it exists.
     */
    where: TheaterWhereUniqueInput
    /**
     * In case the Theater found by the `where` argument doesn't exist, create a new Theater with this data.
     */
    create: XOR<TheaterCreateInput, TheaterUncheckedCreateInput>
    /**
     * In case the Theater was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TheaterUpdateInput, TheaterUncheckedUpdateInput>
  }

  /**
   * Theater delete
   */
  export type TheaterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theater
     */
    select?: TheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theater
     */
    omit?: TheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TheaterInclude<ExtArgs> | null
    /**
     * Filter which Theater to delete.
     */
    where: TheaterWhereUniqueInput
  }

  /**
   * Theater deleteMany
   */
  export type TheaterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Theaters to delete
     */
    where?: TheaterWhereInput
    /**
     * Limit how many Theaters to delete.
     */
    limit?: number
  }

  /**
   * Theater.musicals
   */
  export type Theater$musicalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Musical
     */
    omit?: MusicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    where?: MusicalWhereInput
    orderBy?: MusicalOrderByWithRelationInput | MusicalOrderByWithRelationInput[]
    cursor?: MusicalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MusicalScalarFieldEnum | MusicalScalarFieldEnum[]
  }

  /**
   * Theater.seats
   */
  export type Theater$seatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    where?: SeatWhereInput
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    cursor?: SeatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Theater without action
   */
  export type TheaterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theater
     */
    select?: TheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theater
     */
    omit?: TheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TheaterInclude<ExtArgs> | null
  }


  /**
   * Model Seat
   */

  export type AggregateSeat = {
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  export type SeatAvgAggregateOutputType = {
    id: number | null
    theaterId: number | null
    locationId: number | null
  }

  export type SeatSumAggregateOutputType = {
    id: number | null
    theaterId: number | null
    locationId: number | null
  }

  export type SeatMinAggregateOutputType = {
    id: number | null
    theaterId: number | null
    locationId: number | null
    field: string | null
    field2: string | null
    field3: string | null
    floor: string | null
  }

  export type SeatMaxAggregateOutputType = {
    id: number | null
    theaterId: number | null
    locationId: number | null
    field: string | null
    field2: string | null
    field3: string | null
    floor: string | null
  }

  export type SeatCountAggregateOutputType = {
    id: number
    theaterId: number
    locationId: number
    field: number
    field2: number
    field3: number
    floor: number
    _all: number
  }


  export type SeatAvgAggregateInputType = {
    id?: true
    theaterId?: true
    locationId?: true
  }

  export type SeatSumAggregateInputType = {
    id?: true
    theaterId?: true
    locationId?: true
  }

  export type SeatMinAggregateInputType = {
    id?: true
    theaterId?: true
    locationId?: true
    field?: true
    field2?: true
    field3?: true
    floor?: true
  }

  export type SeatMaxAggregateInputType = {
    id?: true
    theaterId?: true
    locationId?: true
    field?: true
    field2?: true
    field3?: true
    floor?: true
  }

  export type SeatCountAggregateInputType = {
    id?: true
    theaterId?: true
    locationId?: true
    field?: true
    field2?: true
    field3?: true
    floor?: true
    _all?: true
  }

  export type SeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seat to aggregate.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seats
    **/
    _count?: true | SeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatMaxAggregateInputType
  }

  export type GetSeatAggregateType<T extends SeatAggregateArgs> = {
        [P in keyof T & keyof AggregateSeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeat[P]>
      : GetScalarType<T[P], AggregateSeat[P]>
  }




  export type SeatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatWhereInput
    orderBy?: SeatOrderByWithAggregationInput | SeatOrderByWithAggregationInput[]
    by: SeatScalarFieldEnum[] | SeatScalarFieldEnum
    having?: SeatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatCountAggregateInputType | true
    _avg?: SeatAvgAggregateInputType
    _sum?: SeatSumAggregateInputType
    _min?: SeatMinAggregateInputType
    _max?: SeatMaxAggregateInputType
  }

  export type SeatGroupByOutputType = {
    id: number
    theaterId: number
    locationId: number
    field: string | null
    field2: string | null
    field3: string | null
    floor: string | null
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  type GetSeatGroupByPayload<T extends SeatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatGroupByOutputType[P]>
            : GetScalarType<T[P], SeatGroupByOutputType[P]>
        }
      >
    >


  export type SeatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theaterId?: boolean
    locationId?: boolean
    field?: boolean
    field2?: boolean
    field3?: boolean
    floor?: boolean
    theater?: boolean | TheaterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seat"]>



  export type SeatSelectScalar = {
    id?: boolean
    theaterId?: boolean
    locationId?: boolean
    field?: boolean
    field2?: boolean
    field3?: boolean
    floor?: boolean
  }

  export type SeatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "theaterId" | "locationId" | "field" | "field2" | "field3" | "floor", ExtArgs["result"]["seat"]>
  export type SeatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    theater?: boolean | TheaterDefaultArgs<ExtArgs>
  }

  export type $SeatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seat"
    objects: {
      theater: Prisma.$TheaterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      theaterId: number
      locationId: number
      field: string | null
      field2: string | null
      field3: string | null
      floor: string | null
    }, ExtArgs["result"]["seat"]>
    composites: {}
  }

  type SeatGetPayload<S extends boolean | null | undefined | SeatDefaultArgs> = $Result.GetResult<Prisma.$SeatPayload, S>

  type SeatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeatCountAggregateInputType | true
    }

  export interface SeatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seat'], meta: { name: 'Seat' } }
    /**
     * Find zero or one Seat that matches the filter.
     * @param {SeatFindUniqueArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeatFindUniqueArgs>(args: SelectSubset<T, SeatFindUniqueArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeatFindUniqueOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeatFindUniqueOrThrowArgs>(args: SelectSubset<T, SeatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindFirstArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeatFindFirstArgs>(args?: SelectSubset<T, SeatFindFirstArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindFirstOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeatFindFirstOrThrowArgs>(args?: SelectSubset<T, SeatFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seats
     * const seats = await prisma.seat.findMany()
     * 
     * // Get first 10 Seats
     * const seats = await prisma.seat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seatWithIdOnly = await prisma.seat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeatFindManyArgs>(args?: SelectSubset<T, SeatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seat.
     * @param {SeatCreateArgs} args - Arguments to create a Seat.
     * @example
     * // Create one Seat
     * const Seat = await prisma.seat.create({
     *   data: {
     *     // ... data to create a Seat
     *   }
     * })
     * 
     */
    create<T extends SeatCreateArgs>(args: SelectSubset<T, SeatCreateArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seats.
     * @param {SeatCreateManyArgs} args - Arguments to create many Seats.
     * @example
     * // Create many Seats
     * const seat = await prisma.seat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeatCreateManyArgs>(args?: SelectSubset<T, SeatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seat.
     * @param {SeatDeleteArgs} args - Arguments to delete one Seat.
     * @example
     * // Delete one Seat
     * const Seat = await prisma.seat.delete({
     *   where: {
     *     // ... filter to delete one Seat
     *   }
     * })
     * 
     */
    delete<T extends SeatDeleteArgs>(args: SelectSubset<T, SeatDeleteArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seat.
     * @param {SeatUpdateArgs} args - Arguments to update one Seat.
     * @example
     * // Update one Seat
     * const seat = await prisma.seat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeatUpdateArgs>(args: SelectSubset<T, SeatUpdateArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seats.
     * @param {SeatDeleteManyArgs} args - Arguments to filter Seats to delete.
     * @example
     * // Delete a few Seats
     * const { count } = await prisma.seat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeatDeleteManyArgs>(args?: SelectSubset<T, SeatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seats
     * const seat = await prisma.seat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeatUpdateManyArgs>(args: SelectSubset<T, SeatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seat.
     * @param {SeatUpsertArgs} args - Arguments to update or create a Seat.
     * @example
     * // Update or create a Seat
     * const seat = await prisma.seat.upsert({
     *   create: {
     *     // ... data to create a Seat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seat we want to update
     *   }
     * })
     */
    upsert<T extends SeatUpsertArgs>(args: SelectSubset<T, SeatUpsertArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatCountArgs} args - Arguments to filter Seats to count.
     * @example
     * // Count the number of Seats
     * const count = await prisma.seat.count({
     *   where: {
     *     // ... the filter for the Seats we want to count
     *   }
     * })
    **/
    count<T extends SeatCountArgs>(
      args?: Subset<T, SeatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatAggregateArgs>(args: Subset<T, SeatAggregateArgs>): Prisma.PrismaPromise<GetSeatAggregateType<T>>

    /**
     * Group by Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeatGroupByArgs['orderBy'] }
        : { orderBy?: SeatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seat model
   */
  readonly fields: SeatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    theater<T extends TheaterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TheaterDefaultArgs<ExtArgs>>): Prisma__TheaterClient<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seat model
   */
  interface SeatFieldRefs {
    readonly id: FieldRef<"Seat", 'Int'>
    readonly theaterId: FieldRef<"Seat", 'Int'>
    readonly locationId: FieldRef<"Seat", 'Int'>
    readonly field: FieldRef<"Seat", 'String'>
    readonly field2: FieldRef<"Seat", 'String'>
    readonly field3: FieldRef<"Seat", 'String'>
    readonly floor: FieldRef<"Seat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Seat findUnique
   */
  export type SeatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat findUniqueOrThrow
   */
  export type SeatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat findFirst
   */
  export type SeatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat findFirstOrThrow
   */
  export type SeatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat findMany
   */
  export type SeatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seats to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat create
   */
  export type SeatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The data needed to create a Seat.
     */
    data: XOR<SeatCreateInput, SeatUncheckedCreateInput>
  }

  /**
   * Seat createMany
   */
  export type SeatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seats.
     */
    data: SeatCreateManyInput | SeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seat update
   */
  export type SeatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The data needed to update a Seat.
     */
    data: XOR<SeatUpdateInput, SeatUncheckedUpdateInput>
    /**
     * Choose, which Seat to update.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat updateMany
   */
  export type SeatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seats.
     */
    data: XOR<SeatUpdateManyMutationInput, SeatUncheckedUpdateManyInput>
    /**
     * Filter which Seats to update
     */
    where?: SeatWhereInput
    /**
     * Limit how many Seats to update.
     */
    limit?: number
  }

  /**
   * Seat upsert
   */
  export type SeatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The filter to search for the Seat to update in case it exists.
     */
    where: SeatWhereUniqueInput
    /**
     * In case the Seat found by the `where` argument doesn't exist, create a new Seat with this data.
     */
    create: XOR<SeatCreateInput, SeatUncheckedCreateInput>
    /**
     * In case the Seat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeatUpdateInput, SeatUncheckedUpdateInput>
  }

  /**
   * Seat delete
   */
  export type SeatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter which Seat to delete.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat deleteMany
   */
  export type SeatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seats to delete
     */
    where?: SeatWhereInput
    /**
     * Limit how many Seats to delete.
     */
    limit?: number
  }

  /**
   * Seat without action
   */
  export type SeatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
  }


  /**
   * Model Community
   */

  export type AggregateCommunity = {
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  export type CommunityAvgAggregateOutputType = {
    id: number | null
  }

  export type CommunitySumAggregateOutputType = {
    id: number | null
  }

  export type CommunityMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    type: string | null
    description: string | null
  }

  export type CommunityMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    type: string | null
    description: string | null
  }

  export type CommunityCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    type: number
    description: number
    _all: number
  }


  export type CommunityAvgAggregateInputType = {
    id?: true
  }

  export type CommunitySumAggregateInputType = {
    id?: true
  }

  export type CommunityMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    type?: true
    description?: true
  }

  export type CommunityMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    type?: true
    description?: true
  }

  export type CommunityCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    type?: true
    description?: true
    _all?: true
  }

  export type CommunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Community to aggregate.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communities
    **/
    _count?: true | CommunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMaxAggregateInputType
  }

  export type GetCommunityAggregateType<T extends CommunityAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunity[P]>
      : GetScalarType<T[P], AggregateCommunity[P]>
  }




  export type CommunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithAggregationInput | CommunityOrderByWithAggregationInput[]
    by: CommunityScalarFieldEnum[] | CommunityScalarFieldEnum
    having?: CommunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityCountAggregateInputType | true
    _avg?: CommunityAvgAggregateInputType
    _sum?: CommunitySumAggregateInputType
    _min?: CommunityMinAggregateInputType
    _max?: CommunityMaxAggregateInputType
  }

  export type CommunityGroupByOutputType = {
    id: number
    createdAt: Date | null
    name: string | null
    type: string | null
    description: string | null
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  type GetCommunityGroupByPayload<T extends CommunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityGroupByOutputType[P]>
        }
      >
    >


  export type CommunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    userCommunities?: boolean | Community$userCommunitiesArgs<ExtArgs>
    musicalCommunities?: boolean | Community$musicalCommunitiesArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>



  export type CommunitySelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
  }

  export type CommunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "type" | "description", ExtArgs["result"]["community"]>
  export type CommunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCommunities?: boolean | Community$userCommunitiesArgs<ExtArgs>
    musicalCommunities?: boolean | Community$musicalCommunitiesArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CommunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Community"
    objects: {
      userCommunities: Prisma.$UserCommunityPayload<ExtArgs>[]
      musicalCommunities: Prisma.$MusicalCommunityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date | null
      name: string | null
      type: string | null
      description: string | null
    }, ExtArgs["result"]["community"]>
    composites: {}
  }

  type CommunityGetPayload<S extends boolean | null | undefined | CommunityDefaultArgs> = $Result.GetResult<Prisma.$CommunityPayload, S>

  type CommunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityCountAggregateInputType | true
    }

  export interface CommunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Community'], meta: { name: 'Community' } }
    /**
     * Find zero or one Community that matches the filter.
     * @param {CommunityFindUniqueArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityFindUniqueArgs>(args: SelectSubset<T, CommunityFindUniqueArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Community that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityFindUniqueOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Community that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityFindFirstArgs>(args?: SelectSubset<T, CommunityFindFirstArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Community that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Communities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communities
     * const communities = await prisma.community.findMany()
     * 
     * // Get first 10 Communities
     * const communities = await prisma.community.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityWithIdOnly = await prisma.community.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityFindManyArgs>(args?: SelectSubset<T, CommunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Community.
     * @param {CommunityCreateArgs} args - Arguments to create a Community.
     * @example
     * // Create one Community
     * const Community = await prisma.community.create({
     *   data: {
     *     // ... data to create a Community
     *   }
     * })
     * 
     */
    create<T extends CommunityCreateArgs>(args: SelectSubset<T, CommunityCreateArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Communities.
     * @param {CommunityCreateManyArgs} args - Arguments to create many Communities.
     * @example
     * // Create many Communities
     * const community = await prisma.community.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityCreateManyArgs>(args?: SelectSubset<T, CommunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Community.
     * @param {CommunityDeleteArgs} args - Arguments to delete one Community.
     * @example
     * // Delete one Community
     * const Community = await prisma.community.delete({
     *   where: {
     *     // ... filter to delete one Community
     *   }
     * })
     * 
     */
    delete<T extends CommunityDeleteArgs>(args: SelectSubset<T, CommunityDeleteArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Community.
     * @param {CommunityUpdateArgs} args - Arguments to update one Community.
     * @example
     * // Update one Community
     * const community = await prisma.community.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityUpdateArgs>(args: SelectSubset<T, CommunityUpdateArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Communities.
     * @param {CommunityDeleteManyArgs} args - Arguments to filter Communities to delete.
     * @example
     * // Delete a few Communities
     * const { count } = await prisma.community.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityDeleteManyArgs>(args?: SelectSubset<T, CommunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityUpdateManyArgs>(args: SelectSubset<T, CommunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Community.
     * @param {CommunityUpsertArgs} args - Arguments to update or create a Community.
     * @example
     * // Update or create a Community
     * const community = await prisma.community.upsert({
     *   create: {
     *     // ... data to create a Community
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Community we want to update
     *   }
     * })
     */
    upsert<T extends CommunityUpsertArgs>(args: SelectSubset<T, CommunityUpsertArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCountArgs} args - Arguments to filter Communities to count.
     * @example
     * // Count the number of Communities
     * const count = await prisma.community.count({
     *   where: {
     *     // ... the filter for the Communities we want to count
     *   }
     * })
    **/
    count<T extends CommunityCountArgs>(
      args?: Subset<T, CommunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityAggregateArgs>(args: Subset<T, CommunityAggregateArgs>): Prisma.PrismaPromise<GetCommunityAggregateType<T>>

    /**
     * Group by Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityGroupByArgs['orderBy'] }
        : { orderBy?: CommunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Community model
   */
  readonly fields: CommunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Community.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userCommunities<T extends Community$userCommunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Community$userCommunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    musicalCommunities<T extends Community$musicalCommunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Community$musicalCommunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MusicalCommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Community model
   */
  interface CommunityFieldRefs {
    readonly id: FieldRef<"Community", 'Int'>
    readonly createdAt: FieldRef<"Community", 'DateTime'>
    readonly name: FieldRef<"Community", 'String'>
    readonly type: FieldRef<"Community", 'String'>
    readonly description: FieldRef<"Community", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Community findUnique
   */
  export type CommunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findUniqueOrThrow
   */
  export type CommunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findFirst
   */
  export type CommunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findFirstOrThrow
   */
  export type CommunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findMany
   */
  export type CommunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Communities to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community create
   */
  export type CommunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Community.
     */
    data?: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
  }

  /**
   * Community createMany
   */
  export type CommunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Community update
   */
  export type CommunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Community.
     */
    data: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
    /**
     * Choose, which Community to update.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community updateMany
   */
  export type CommunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
    /**
     * Limit how many Communities to update.
     */
    limit?: number
  }

  /**
   * Community upsert
   */
  export type CommunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Community to update in case it exists.
     */
    where: CommunityWhereUniqueInput
    /**
     * In case the Community found by the `where` argument doesn't exist, create a new Community with this data.
     */
    create: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
    /**
     * In case the Community was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
  }

  /**
   * Community delete
   */
  export type CommunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter which Community to delete.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community deleteMany
   */
  export type CommunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communities to delete
     */
    where?: CommunityWhereInput
    /**
     * Limit how many Communities to delete.
     */
    limit?: number
  }

  /**
   * Community.userCommunities
   */
  export type Community$userCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
    where?: UserCommunityWhereInput
    orderBy?: UserCommunityOrderByWithRelationInput | UserCommunityOrderByWithRelationInput[]
    cursor?: UserCommunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCommunityScalarFieldEnum | UserCommunityScalarFieldEnum[]
  }

  /**
   * Community.musicalCommunities
   */
  export type Community$musicalCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
    where?: MusicalCommunityWhereInput
    orderBy?: MusicalCommunityOrderByWithRelationInput | MusicalCommunityOrderByWithRelationInput[]
    cursor?: MusicalCommunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MusicalCommunityScalarFieldEnum | MusicalCommunityScalarFieldEnum[]
  }

  /**
   * Community without action
   */
  export type CommunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingAvgAggregateOutputType = {
    id: number | null
  }

  export type SettingSumAggregateOutputType = {
    id: number | null
  }

  export type SettingMinAggregateOutputType = {
    id: number | null
    useBackground: boolean | null
    useProfilePhoto: boolean | null
    allowRepost: boolean | null
  }

  export type SettingMaxAggregateOutputType = {
    id: number | null
    useBackground: boolean | null
    useProfilePhoto: boolean | null
    allowRepost: boolean | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    useBackground: number
    useProfilePhoto: number
    allowRepost: number
    _all: number
  }


  export type SettingAvgAggregateInputType = {
    id?: true
  }

  export type SettingSumAggregateInputType = {
    id?: true
  }

  export type SettingMinAggregateInputType = {
    id?: true
    useBackground?: true
    useProfilePhoto?: true
    allowRepost?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    useBackground?: true
    useProfilePhoto?: true
    allowRepost?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    useBackground?: true
    useProfilePhoto?: true
    allowRepost?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _avg?: SettingAvgAggregateInputType
    _sum?: SettingSumAggregateInputType
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: number
    useBackground: boolean | null
    useProfilePhoto: boolean | null
    allowRepost: boolean | null
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    useBackground?: boolean
    useProfilePhoto?: boolean
    allowRepost?: boolean
    users?: boolean | Setting$usersArgs<ExtArgs>
    posts?: boolean | Setting$postsArgs<ExtArgs>
    _count?: boolean | SettingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["setting"]>



  export type SettingSelectScalar = {
    id?: boolean
    useBackground?: boolean
    useProfilePhoto?: boolean
    allowRepost?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "useBackground" | "useProfilePhoto" | "allowRepost", ExtArgs["result"]["setting"]>
  export type SettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Setting$usersArgs<ExtArgs>
    posts?: boolean | Setting$postsArgs<ExtArgs>
    _count?: boolean | SettingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {
      users: Prisma.$UserPayload<ExtArgs> | null
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      useBackground: boolean | null
      useProfilePhoto: boolean | null
      allowRepost: boolean | null
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Setting$usersArgs<ExtArgs> = {}>(args?: Subset<T, Setting$usersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    posts<T extends Setting$postsArgs<ExtArgs> = {}>(args?: Subset<T, Setting$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'Int'>
    readonly useBackground: FieldRef<"Setting", 'Boolean'>
    readonly useProfilePhoto: FieldRef<"Setting", 'Boolean'>
    readonly allowRepost: FieldRef<"Setting", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data?: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting.users
   */
  export type Setting$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Setting.posts
   */
  export type Setting$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    type: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    name: string
    type: string | null
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>



  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string | null
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Tag$postsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly type: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.posts
   */
  export type Tag$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type ImageSumAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: number | null
    postId: number | null
    url: string | null
    caption: string | null
  }

  export type ImageMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    url: string | null
    caption: string | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    postId: number
    url: number
    caption: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    id?: true
    postId?: true
  }

  export type ImageSumAggregateInputType = {
    id?: true
    postId?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    postId?: true
    url?: true
    caption?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    postId?: true
    url?: true
    caption?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    postId?: true
    url?: true
    caption?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    id: number
    postId: number
    url: string | null
    caption: string | null
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    url?: boolean
    caption?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>



  export type ImageSelectScalar = {
    id?: boolean
    postId?: boolean
    url?: boolean
    caption?: boolean
  }

  export type ImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "url" | "caption", ExtArgs["result"]["image"]>
  export type ImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      url: string | null
      caption: string | null
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", 'Int'>
    readonly postId: FieldRef<"Image", 'Int'>
    readonly url: FieldRef<"Image", 'String'>
    readonly caption: FieldRef<"Image", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to delete.
     */
    limit?: number
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
  }


  /**
   * Model Subscribe
   */

  export type AggregateSubscribe = {
    _count: SubscribeCountAggregateOutputType | null
    _avg: SubscribeAvgAggregateOutputType | null
    _sum: SubscribeSumAggregateOutputType | null
    _min: SubscribeMinAggregateOutputType | null
    _max: SubscribeMaxAggregateOutputType | null
  }

  export type SubscribeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SubscribeSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SubscribeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
  }

  export type SubscribeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
  }

  export type SubscribeCountAggregateOutputType = {
    id: number
    userId: number
    startDate: number
    endDate: number
    isActive: number
    _all: number
  }


  export type SubscribeAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SubscribeSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SubscribeMinAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    endDate?: true
    isActive?: true
  }

  export type SubscribeMaxAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    endDate?: true
    isActive?: true
  }

  export type SubscribeCountAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    _all?: true
  }

  export type SubscribeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscribe to aggregate.
     */
    where?: SubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribes to fetch.
     */
    orderBy?: SubscribeOrderByWithRelationInput | SubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscribes
    **/
    _count?: true | SubscribeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscribeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscribeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscribeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscribeMaxAggregateInputType
  }

  export type GetSubscribeAggregateType<T extends SubscribeAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscribe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscribe[P]>
      : GetScalarType<T[P], AggregateSubscribe[P]>
  }




  export type SubscribeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscribeWhereInput
    orderBy?: SubscribeOrderByWithAggregationInput | SubscribeOrderByWithAggregationInput[]
    by: SubscribeScalarFieldEnum[] | SubscribeScalarFieldEnum
    having?: SubscribeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscribeCountAggregateInputType | true
    _avg?: SubscribeAvgAggregateInputType
    _sum?: SubscribeSumAggregateInputType
    _min?: SubscribeMinAggregateInputType
    _max?: SubscribeMaxAggregateInputType
  }

  export type SubscribeGroupByOutputType = {
    id: number
    userId: number
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    _count: SubscribeCountAggregateOutputType | null
    _avg: SubscribeAvgAggregateOutputType | null
    _sum: SubscribeSumAggregateOutputType | null
    _min: SubscribeMinAggregateOutputType | null
    _max: SubscribeMaxAggregateOutputType | null
  }

  type GetSubscribeGroupByPayload<T extends SubscribeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscribeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscribeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscribeGroupByOutputType[P]>
            : GetScalarType<T[P], SubscribeGroupByOutputType[P]>
        }
      >
    >


  export type SubscribeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscribe"]>



  export type SubscribeSelectScalar = {
    id?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
  }

  export type SubscribeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "startDate" | "endDate" | "isActive", ExtArgs["result"]["subscribe"]>
  export type SubscribeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscribePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscribe"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      startDate: Date | null
      endDate: Date | null
      isActive: boolean | null
    }, ExtArgs["result"]["subscribe"]>
    composites: {}
  }

  type SubscribeGetPayload<S extends boolean | null | undefined | SubscribeDefaultArgs> = $Result.GetResult<Prisma.$SubscribePayload, S>

  type SubscribeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscribeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscribeCountAggregateInputType | true
    }

  export interface SubscribeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscribe'], meta: { name: 'Subscribe' } }
    /**
     * Find zero or one Subscribe that matches the filter.
     * @param {SubscribeFindUniqueArgs} args - Arguments to find a Subscribe
     * @example
     * // Get one Subscribe
     * const subscribe = await prisma.subscribe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscribeFindUniqueArgs>(args: SelectSubset<T, SubscribeFindUniqueArgs<ExtArgs>>): Prisma__SubscribeClient<$Result.GetResult<Prisma.$SubscribePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscribe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscribeFindUniqueOrThrowArgs} args - Arguments to find a Subscribe
     * @example
     * // Get one Subscribe
     * const subscribe = await prisma.subscribe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscribeFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscribeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscribeClient<$Result.GetResult<Prisma.$SubscribePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscribe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribeFindFirstArgs} args - Arguments to find a Subscribe
     * @example
     * // Get one Subscribe
     * const subscribe = await prisma.subscribe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscribeFindFirstArgs>(args?: SelectSubset<T, SubscribeFindFirstArgs<ExtArgs>>): Prisma__SubscribeClient<$Result.GetResult<Prisma.$SubscribePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscribe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribeFindFirstOrThrowArgs} args - Arguments to find a Subscribe
     * @example
     * // Get one Subscribe
     * const subscribe = await prisma.subscribe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscribeFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscribeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscribeClient<$Result.GetResult<Prisma.$SubscribePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscribes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscribes
     * const subscribes = await prisma.subscribe.findMany()
     * 
     * // Get first 10 Subscribes
     * const subscribes = await prisma.subscribe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscribeWithIdOnly = await prisma.subscribe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscribeFindManyArgs>(args?: SelectSubset<T, SubscribeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscribePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscribe.
     * @param {SubscribeCreateArgs} args - Arguments to create a Subscribe.
     * @example
     * // Create one Subscribe
     * const Subscribe = await prisma.subscribe.create({
     *   data: {
     *     // ... data to create a Subscribe
     *   }
     * })
     * 
     */
    create<T extends SubscribeCreateArgs>(args: SelectSubset<T, SubscribeCreateArgs<ExtArgs>>): Prisma__SubscribeClient<$Result.GetResult<Prisma.$SubscribePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscribes.
     * @param {SubscribeCreateManyArgs} args - Arguments to create many Subscribes.
     * @example
     * // Create many Subscribes
     * const subscribe = await prisma.subscribe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscribeCreateManyArgs>(args?: SelectSubset<T, SubscribeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscribe.
     * @param {SubscribeDeleteArgs} args - Arguments to delete one Subscribe.
     * @example
     * // Delete one Subscribe
     * const Subscribe = await prisma.subscribe.delete({
     *   where: {
     *     // ... filter to delete one Subscribe
     *   }
     * })
     * 
     */
    delete<T extends SubscribeDeleteArgs>(args: SelectSubset<T, SubscribeDeleteArgs<ExtArgs>>): Prisma__SubscribeClient<$Result.GetResult<Prisma.$SubscribePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscribe.
     * @param {SubscribeUpdateArgs} args - Arguments to update one Subscribe.
     * @example
     * // Update one Subscribe
     * const subscribe = await prisma.subscribe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscribeUpdateArgs>(args: SelectSubset<T, SubscribeUpdateArgs<ExtArgs>>): Prisma__SubscribeClient<$Result.GetResult<Prisma.$SubscribePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscribes.
     * @param {SubscribeDeleteManyArgs} args - Arguments to filter Subscribes to delete.
     * @example
     * // Delete a few Subscribes
     * const { count } = await prisma.subscribe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscribeDeleteManyArgs>(args?: SelectSubset<T, SubscribeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscribes
     * const subscribe = await prisma.subscribe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscribeUpdateManyArgs>(args: SelectSubset<T, SubscribeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscribe.
     * @param {SubscribeUpsertArgs} args - Arguments to update or create a Subscribe.
     * @example
     * // Update or create a Subscribe
     * const subscribe = await prisma.subscribe.upsert({
     *   create: {
     *     // ... data to create a Subscribe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscribe we want to update
     *   }
     * })
     */
    upsert<T extends SubscribeUpsertArgs>(args: SelectSubset<T, SubscribeUpsertArgs<ExtArgs>>): Prisma__SubscribeClient<$Result.GetResult<Prisma.$SubscribePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribeCountArgs} args - Arguments to filter Subscribes to count.
     * @example
     * // Count the number of Subscribes
     * const count = await prisma.subscribe.count({
     *   where: {
     *     // ... the filter for the Subscribes we want to count
     *   }
     * })
    **/
    count<T extends SubscribeCountArgs>(
      args?: Subset<T, SubscribeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscribeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscribe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscribeAggregateArgs>(args: Subset<T, SubscribeAggregateArgs>): Prisma.PrismaPromise<GetSubscribeAggregateType<T>>

    /**
     * Group by Subscribe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscribeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscribeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscribeGroupByArgs['orderBy'] }
        : { orderBy?: SubscribeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscribeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscribeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscribe model
   */
  readonly fields: SubscribeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscribe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscribeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscribe model
   */
  interface SubscribeFieldRefs {
    readonly id: FieldRef<"Subscribe", 'Int'>
    readonly userId: FieldRef<"Subscribe", 'Int'>
    readonly startDate: FieldRef<"Subscribe", 'DateTime'>
    readonly endDate: FieldRef<"Subscribe", 'DateTime'>
    readonly isActive: FieldRef<"Subscribe", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Subscribe findUnique
   */
  export type SubscribeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscribe
     */
    select?: SubscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscribe
     */
    omit?: SubscribeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscribeInclude<ExtArgs> | null
    /**
     * Filter, which Subscribe to fetch.
     */
    where: SubscribeWhereUniqueInput
  }

  /**
   * Subscribe findUniqueOrThrow
   */
  export type SubscribeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscribe
     */
    select?: SubscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscribe
     */
    omit?: SubscribeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscribeInclude<ExtArgs> | null
    /**
     * Filter, which Subscribe to fetch.
     */
    where: SubscribeWhereUniqueInput
  }

  /**
   * Subscribe findFirst
   */
  export type SubscribeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscribe
     */
    select?: SubscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscribe
     */
    omit?: SubscribeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscribeInclude<ExtArgs> | null
    /**
     * Filter, which Subscribe to fetch.
     */
    where?: SubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribes to fetch.
     */
    orderBy?: SubscribeOrderByWithRelationInput | SubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribes.
     */
    cursor?: SubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribes.
     */
    distinct?: SubscribeScalarFieldEnum | SubscribeScalarFieldEnum[]
  }

  /**
   * Subscribe findFirstOrThrow
   */
  export type SubscribeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscribe
     */
    select?: SubscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscribe
     */
    omit?: SubscribeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscribeInclude<ExtArgs> | null
    /**
     * Filter, which Subscribe to fetch.
     */
    where?: SubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribes to fetch.
     */
    orderBy?: SubscribeOrderByWithRelationInput | SubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribes.
     */
    cursor?: SubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribes.
     */
    distinct?: SubscribeScalarFieldEnum | SubscribeScalarFieldEnum[]
  }

  /**
   * Subscribe findMany
   */
  export type SubscribeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscribe
     */
    select?: SubscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscribe
     */
    omit?: SubscribeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscribeInclude<ExtArgs> | null
    /**
     * Filter, which Subscribes to fetch.
     */
    where?: SubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribes to fetch.
     */
    orderBy?: SubscribeOrderByWithRelationInput | SubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscribes.
     */
    cursor?: SubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribes.
     */
    skip?: number
    distinct?: SubscribeScalarFieldEnum | SubscribeScalarFieldEnum[]
  }

  /**
   * Subscribe create
   */
  export type SubscribeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscribe
     */
    select?: SubscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscribe
     */
    omit?: SubscribeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscribeInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscribe.
     */
    data: XOR<SubscribeCreateInput, SubscribeUncheckedCreateInput>
  }

  /**
   * Subscribe createMany
   */
  export type SubscribeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscribes.
     */
    data: SubscribeCreateManyInput | SubscribeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscribe update
   */
  export type SubscribeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscribe
     */
    select?: SubscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscribe
     */
    omit?: SubscribeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscribeInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscribe.
     */
    data: XOR<SubscribeUpdateInput, SubscribeUncheckedUpdateInput>
    /**
     * Choose, which Subscribe to update.
     */
    where: SubscribeWhereUniqueInput
  }

  /**
   * Subscribe updateMany
   */
  export type SubscribeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscribes.
     */
    data: XOR<SubscribeUpdateManyMutationInput, SubscribeUncheckedUpdateManyInput>
    /**
     * Filter which Subscribes to update
     */
    where?: SubscribeWhereInput
    /**
     * Limit how many Subscribes to update.
     */
    limit?: number
  }

  /**
   * Subscribe upsert
   */
  export type SubscribeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscribe
     */
    select?: SubscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscribe
     */
    omit?: SubscribeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscribeInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscribe to update in case it exists.
     */
    where: SubscribeWhereUniqueInput
    /**
     * In case the Subscribe found by the `where` argument doesn't exist, create a new Subscribe with this data.
     */
    create: XOR<SubscribeCreateInput, SubscribeUncheckedCreateInput>
    /**
     * In case the Subscribe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscribeUpdateInput, SubscribeUncheckedUpdateInput>
  }

  /**
   * Subscribe delete
   */
  export type SubscribeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscribe
     */
    select?: SubscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscribe
     */
    omit?: SubscribeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscribeInclude<ExtArgs> | null
    /**
     * Filter which Subscribe to delete.
     */
    where: SubscribeWhereUniqueInput
  }

  /**
   * Subscribe deleteMany
   */
  export type SubscribeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscribes to delete
     */
    where?: SubscribeWhereInput
    /**
     * Limit how many Subscribes to delete.
     */
    limit?: number
  }

  /**
   * Subscribe without action
   */
  export type SubscribeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscribe
     */
    select?: SubscribeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscribe
     */
    omit?: SubscribeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscribeInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _avg: FollowAvgAggregateOutputType | null
    _sum: FollowSumAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowAvgAggregateOutputType = {
    id: number | null
    followerId: number | null
    followingId: number | null
  }

  export type FollowSumAggregateOutputType = {
    id: number | null
    followerId: number | null
    followingId: number | null
  }

  export type FollowMinAggregateOutputType = {
    id: number | null
    followerId: number | null
    followingId: number | null
    createdAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: number | null
    followerId: number | null
    followingId: number | null
    createdAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: number
    _all: number
  }


  export type FollowAvgAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
  }

  export type FollowSumAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
  }

  export type FollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FollowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FollowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _avg?: FollowAvgAggregateInputType
    _sum?: FollowSumAggregateInputType
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: Date | null
    _count: FollowCountAggregateOutputType | null
    _avg: FollowAvgAggregateOutputType | null
    _sum: FollowSumAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>



  export type FollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
  }

  export type FollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerId" | "followingId" | "createdAt", ExtArgs["result"]["follow"]>
  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      followerId: number
      followingId: number
      createdAt: Date | null
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'Int'>
    readonly followerId: FieldRef<"Follow", 'Int'>
    readonly followingId: FieldRef<"Follow", 'Int'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to delete.
     */
    limit?: number
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model ViewingRecord
   */

  export type AggregateViewingRecord = {
    _count: ViewingRecordCountAggregateOutputType | null
    _avg: ViewingRecordAvgAggregateOutputType | null
    _sum: ViewingRecordSumAggregateOutputType | null
    _min: ViewingRecordMinAggregateOutputType | null
    _max: ViewingRecordMaxAggregateOutputType | null
  }

  export type ViewingRecordAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    musicalId: number | null
  }

  export type ViewingRecordSumAggregateOutputType = {
    id: number | null
    userId: number | null
    musicalId: number | null
  }

  export type ViewingRecordMinAggregateOutputType = {
    id: number | null
    userId: number | null
    musicalId: number | null
    date: Date | null
    seat: string | null
  }

  export type ViewingRecordMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    musicalId: number | null
    date: Date | null
    seat: string | null
  }

  export type ViewingRecordCountAggregateOutputType = {
    id: number
    userId: number
    musicalId: number
    date: number
    seat: number
    _all: number
  }


  export type ViewingRecordAvgAggregateInputType = {
    id?: true
    userId?: true
    musicalId?: true
  }

  export type ViewingRecordSumAggregateInputType = {
    id?: true
    userId?: true
    musicalId?: true
  }

  export type ViewingRecordMinAggregateInputType = {
    id?: true
    userId?: true
    musicalId?: true
    date?: true
    seat?: true
  }

  export type ViewingRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    musicalId?: true
    date?: true
    seat?: true
  }

  export type ViewingRecordCountAggregateInputType = {
    id?: true
    userId?: true
    musicalId?: true
    date?: true
    seat?: true
    _all?: true
  }

  export type ViewingRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewingRecord to aggregate.
     */
    where?: ViewingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingRecords to fetch.
     */
    orderBy?: ViewingRecordOrderByWithRelationInput | ViewingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewingRecords
    **/
    _count?: true | ViewingRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViewingRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViewingRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewingRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewingRecordMaxAggregateInputType
  }

  export type GetViewingRecordAggregateType<T extends ViewingRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateViewingRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewingRecord[P]>
      : GetScalarType<T[P], AggregateViewingRecord[P]>
  }




  export type ViewingRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewingRecordWhereInput
    orderBy?: ViewingRecordOrderByWithAggregationInput | ViewingRecordOrderByWithAggregationInput[]
    by: ViewingRecordScalarFieldEnum[] | ViewingRecordScalarFieldEnum
    having?: ViewingRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewingRecordCountAggregateInputType | true
    _avg?: ViewingRecordAvgAggregateInputType
    _sum?: ViewingRecordSumAggregateInputType
    _min?: ViewingRecordMinAggregateInputType
    _max?: ViewingRecordMaxAggregateInputType
  }

  export type ViewingRecordGroupByOutputType = {
    id: number
    userId: number
    musicalId: number
    date: Date | null
    seat: string | null
    _count: ViewingRecordCountAggregateOutputType | null
    _avg: ViewingRecordAvgAggregateOutputType | null
    _sum: ViewingRecordSumAggregateOutputType | null
    _min: ViewingRecordMinAggregateOutputType | null
    _max: ViewingRecordMaxAggregateOutputType | null
  }

  type GetViewingRecordGroupByPayload<T extends ViewingRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewingRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewingRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewingRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ViewingRecordGroupByOutputType[P]>
        }
      >
    >


  export type ViewingRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    musicalId?: boolean
    date?: boolean
    seat?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    musical?: boolean | MusicalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viewingRecord"]>



  export type ViewingRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    musicalId?: boolean
    date?: boolean
    seat?: boolean
  }

  export type ViewingRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "musicalId" | "date" | "seat", ExtArgs["result"]["viewingRecord"]>
  export type ViewingRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    musical?: boolean | MusicalDefaultArgs<ExtArgs>
  }

  export type $ViewingRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewingRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      musical: Prisma.$MusicalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      musicalId: number
      date: Date | null
      seat: string | null
    }, ExtArgs["result"]["viewingRecord"]>
    composites: {}
  }

  type ViewingRecordGetPayload<S extends boolean | null | undefined | ViewingRecordDefaultArgs> = $Result.GetResult<Prisma.$ViewingRecordPayload, S>

  type ViewingRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViewingRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViewingRecordCountAggregateInputType | true
    }

  export interface ViewingRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewingRecord'], meta: { name: 'ViewingRecord' } }
    /**
     * Find zero or one ViewingRecord that matches the filter.
     * @param {ViewingRecordFindUniqueArgs} args - Arguments to find a ViewingRecord
     * @example
     * // Get one ViewingRecord
     * const viewingRecord = await prisma.viewingRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewingRecordFindUniqueArgs>(args: SelectSubset<T, ViewingRecordFindUniqueArgs<ExtArgs>>): Prisma__ViewingRecordClient<$Result.GetResult<Prisma.$ViewingRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViewingRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViewingRecordFindUniqueOrThrowArgs} args - Arguments to find a ViewingRecord
     * @example
     * // Get one ViewingRecord
     * const viewingRecord = await prisma.viewingRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewingRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewingRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewingRecordClient<$Result.GetResult<Prisma.$ViewingRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewingRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRecordFindFirstArgs} args - Arguments to find a ViewingRecord
     * @example
     * // Get one ViewingRecord
     * const viewingRecord = await prisma.viewingRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewingRecordFindFirstArgs>(args?: SelectSubset<T, ViewingRecordFindFirstArgs<ExtArgs>>): Prisma__ViewingRecordClient<$Result.GetResult<Prisma.$ViewingRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewingRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRecordFindFirstOrThrowArgs} args - Arguments to find a ViewingRecord
     * @example
     * // Get one ViewingRecord
     * const viewingRecord = await prisma.viewingRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewingRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewingRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewingRecordClient<$Result.GetResult<Prisma.$ViewingRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViewingRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewingRecords
     * const viewingRecords = await prisma.viewingRecord.findMany()
     * 
     * // Get first 10 ViewingRecords
     * const viewingRecords = await prisma.viewingRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viewingRecordWithIdOnly = await prisma.viewingRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViewingRecordFindManyArgs>(args?: SelectSubset<T, ViewingRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewingRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViewingRecord.
     * @param {ViewingRecordCreateArgs} args - Arguments to create a ViewingRecord.
     * @example
     * // Create one ViewingRecord
     * const ViewingRecord = await prisma.viewingRecord.create({
     *   data: {
     *     // ... data to create a ViewingRecord
     *   }
     * })
     * 
     */
    create<T extends ViewingRecordCreateArgs>(args: SelectSubset<T, ViewingRecordCreateArgs<ExtArgs>>): Prisma__ViewingRecordClient<$Result.GetResult<Prisma.$ViewingRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViewingRecords.
     * @param {ViewingRecordCreateManyArgs} args - Arguments to create many ViewingRecords.
     * @example
     * // Create many ViewingRecords
     * const viewingRecord = await prisma.viewingRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewingRecordCreateManyArgs>(args?: SelectSubset<T, ViewingRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ViewingRecord.
     * @param {ViewingRecordDeleteArgs} args - Arguments to delete one ViewingRecord.
     * @example
     * // Delete one ViewingRecord
     * const ViewingRecord = await prisma.viewingRecord.delete({
     *   where: {
     *     // ... filter to delete one ViewingRecord
     *   }
     * })
     * 
     */
    delete<T extends ViewingRecordDeleteArgs>(args: SelectSubset<T, ViewingRecordDeleteArgs<ExtArgs>>): Prisma__ViewingRecordClient<$Result.GetResult<Prisma.$ViewingRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViewingRecord.
     * @param {ViewingRecordUpdateArgs} args - Arguments to update one ViewingRecord.
     * @example
     * // Update one ViewingRecord
     * const viewingRecord = await prisma.viewingRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewingRecordUpdateArgs>(args: SelectSubset<T, ViewingRecordUpdateArgs<ExtArgs>>): Prisma__ViewingRecordClient<$Result.GetResult<Prisma.$ViewingRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViewingRecords.
     * @param {ViewingRecordDeleteManyArgs} args - Arguments to filter ViewingRecords to delete.
     * @example
     * // Delete a few ViewingRecords
     * const { count } = await prisma.viewingRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewingRecordDeleteManyArgs>(args?: SelectSubset<T, ViewingRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewingRecords
     * const viewingRecord = await prisma.viewingRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewingRecordUpdateManyArgs>(args: SelectSubset<T, ViewingRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ViewingRecord.
     * @param {ViewingRecordUpsertArgs} args - Arguments to update or create a ViewingRecord.
     * @example
     * // Update or create a ViewingRecord
     * const viewingRecord = await prisma.viewingRecord.upsert({
     *   create: {
     *     // ... data to create a ViewingRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewingRecord we want to update
     *   }
     * })
     */
    upsert<T extends ViewingRecordUpsertArgs>(args: SelectSubset<T, ViewingRecordUpsertArgs<ExtArgs>>): Prisma__ViewingRecordClient<$Result.GetResult<Prisma.$ViewingRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViewingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRecordCountArgs} args - Arguments to filter ViewingRecords to count.
     * @example
     * // Count the number of ViewingRecords
     * const count = await prisma.viewingRecord.count({
     *   where: {
     *     // ... the filter for the ViewingRecords we want to count
     *   }
     * })
    **/
    count<T extends ViewingRecordCountArgs>(
      args?: Subset<T, ViewingRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewingRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewingRecordAggregateArgs>(args: Subset<T, ViewingRecordAggregateArgs>): Prisma.PrismaPromise<GetViewingRecordAggregateType<T>>

    /**
     * Group by ViewingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewingRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewingRecordGroupByArgs['orderBy'] }
        : { orderBy?: ViewingRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewingRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewingRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewingRecord model
   */
  readonly fields: ViewingRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewingRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewingRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    musical<T extends MusicalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MusicalDefaultArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViewingRecord model
   */
  interface ViewingRecordFieldRefs {
    readonly id: FieldRef<"ViewingRecord", 'Int'>
    readonly userId: FieldRef<"ViewingRecord", 'Int'>
    readonly musicalId: FieldRef<"ViewingRecord", 'Int'>
    readonly date: FieldRef<"ViewingRecord", 'DateTime'>
    readonly seat: FieldRef<"ViewingRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ViewingRecord findUnique
   */
  export type ViewingRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
    /**
     * Filter, which ViewingRecord to fetch.
     */
    where: ViewingRecordWhereUniqueInput
  }

  /**
   * ViewingRecord findUniqueOrThrow
   */
  export type ViewingRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
    /**
     * Filter, which ViewingRecord to fetch.
     */
    where: ViewingRecordWhereUniqueInput
  }

  /**
   * ViewingRecord findFirst
   */
  export type ViewingRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
    /**
     * Filter, which ViewingRecord to fetch.
     */
    where?: ViewingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingRecords to fetch.
     */
    orderBy?: ViewingRecordOrderByWithRelationInput | ViewingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewingRecords.
     */
    cursor?: ViewingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewingRecords.
     */
    distinct?: ViewingRecordScalarFieldEnum | ViewingRecordScalarFieldEnum[]
  }

  /**
   * ViewingRecord findFirstOrThrow
   */
  export type ViewingRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
    /**
     * Filter, which ViewingRecord to fetch.
     */
    where?: ViewingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingRecords to fetch.
     */
    orderBy?: ViewingRecordOrderByWithRelationInput | ViewingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewingRecords.
     */
    cursor?: ViewingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewingRecords.
     */
    distinct?: ViewingRecordScalarFieldEnum | ViewingRecordScalarFieldEnum[]
  }

  /**
   * ViewingRecord findMany
   */
  export type ViewingRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
    /**
     * Filter, which ViewingRecords to fetch.
     */
    where?: ViewingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingRecords to fetch.
     */
    orderBy?: ViewingRecordOrderByWithRelationInput | ViewingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewingRecords.
     */
    cursor?: ViewingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingRecords.
     */
    skip?: number
    distinct?: ViewingRecordScalarFieldEnum | ViewingRecordScalarFieldEnum[]
  }

  /**
   * ViewingRecord create
   */
  export type ViewingRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a ViewingRecord.
     */
    data: XOR<ViewingRecordCreateInput, ViewingRecordUncheckedCreateInput>
  }

  /**
   * ViewingRecord createMany
   */
  export type ViewingRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewingRecords.
     */
    data: ViewingRecordCreateManyInput | ViewingRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewingRecord update
   */
  export type ViewingRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a ViewingRecord.
     */
    data: XOR<ViewingRecordUpdateInput, ViewingRecordUncheckedUpdateInput>
    /**
     * Choose, which ViewingRecord to update.
     */
    where: ViewingRecordWhereUniqueInput
  }

  /**
   * ViewingRecord updateMany
   */
  export type ViewingRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewingRecords.
     */
    data: XOR<ViewingRecordUpdateManyMutationInput, ViewingRecordUncheckedUpdateManyInput>
    /**
     * Filter which ViewingRecords to update
     */
    where?: ViewingRecordWhereInput
    /**
     * Limit how many ViewingRecords to update.
     */
    limit?: number
  }

  /**
   * ViewingRecord upsert
   */
  export type ViewingRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the ViewingRecord to update in case it exists.
     */
    where: ViewingRecordWhereUniqueInput
    /**
     * In case the ViewingRecord found by the `where` argument doesn't exist, create a new ViewingRecord with this data.
     */
    create: XOR<ViewingRecordCreateInput, ViewingRecordUncheckedCreateInput>
    /**
     * In case the ViewingRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewingRecordUpdateInput, ViewingRecordUncheckedUpdateInput>
  }

  /**
   * ViewingRecord delete
   */
  export type ViewingRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
    /**
     * Filter which ViewingRecord to delete.
     */
    where: ViewingRecordWhereUniqueInput
  }

  /**
   * ViewingRecord deleteMany
   */
  export type ViewingRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewingRecords to delete
     */
    where?: ViewingRecordWhereInput
    /**
     * Limit how many ViewingRecords to delete.
     */
    limit?: number
  }

  /**
   * ViewingRecord without action
   */
  export type ViewingRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRecord
     */
    select?: ViewingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRecord
     */
    omit?: ViewingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRecordInclude<ExtArgs> | null
  }


  /**
   * Model PostLike
   */

  export type AggregatePostLike = {
    _count: PostLikeCountAggregateOutputType | null
    _avg: PostLikeAvgAggregateOutputType | null
    _sum: PostLikeSumAggregateOutputType | null
    _min: PostLikeMinAggregateOutputType | null
    _max: PostLikeMaxAggregateOutputType | null
  }

  export type PostLikeAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type PostLikeSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type PostLikeMinAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    likedAt: Date | null
  }

  export type PostLikeMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    likedAt: Date | null
  }

  export type PostLikeCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    likedAt: number
    _all: number
  }


  export type PostLikeAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type PostLikeSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type PostLikeMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    likedAt?: true
  }

  export type PostLikeMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    likedAt?: true
  }

  export type PostLikeCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    likedAt?: true
    _all?: true
  }

  export type PostLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostLike to aggregate.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostLikes
    **/
    _count?: true | PostLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostLikeMaxAggregateInputType
  }

  export type GetPostLikeAggregateType<T extends PostLikeAggregateArgs> = {
        [P in keyof T & keyof AggregatePostLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostLike[P]>
      : GetScalarType<T[P], AggregatePostLike[P]>
  }




  export type PostLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithAggregationInput | PostLikeOrderByWithAggregationInput[]
    by: PostLikeScalarFieldEnum[] | PostLikeScalarFieldEnum
    having?: PostLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostLikeCountAggregateInputType | true
    _avg?: PostLikeAvgAggregateInputType
    _sum?: PostLikeSumAggregateInputType
    _min?: PostLikeMinAggregateInputType
    _max?: PostLikeMaxAggregateInputType
  }

  export type PostLikeGroupByOutputType = {
    id: number
    postId: number
    userId: number
    likedAt: Date | null
    _count: PostLikeCountAggregateOutputType | null
    _avg: PostLikeAvgAggregateOutputType | null
    _sum: PostLikeSumAggregateOutputType | null
    _min: PostLikeMinAggregateOutputType | null
    _max: PostLikeMaxAggregateOutputType | null
  }

  type GetPostLikeGroupByPayload<T extends PostLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostLikeGroupByOutputType[P]>
            : GetScalarType<T[P], PostLikeGroupByOutputType[P]>
        }
      >
    >


  export type PostLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    likedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postLike"]>



  export type PostLikeSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    likedAt?: boolean
  }

  export type PostLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "likedAt", ExtArgs["result"]["postLike"]>
  export type PostLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostLike"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      userId: number
      likedAt: Date | null
    }, ExtArgs["result"]["postLike"]>
    composites: {}
  }

  type PostLikeGetPayload<S extends boolean | null | undefined | PostLikeDefaultArgs> = $Result.GetResult<Prisma.$PostLikePayload, S>

  type PostLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostLikeCountAggregateInputType | true
    }

  export interface PostLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostLike'], meta: { name: 'PostLike' } }
    /**
     * Find zero or one PostLike that matches the filter.
     * @param {PostLikeFindUniqueArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostLikeFindUniqueArgs>(args: SelectSubset<T, PostLikeFindUniqueArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostLikeFindUniqueOrThrowArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, PostLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindFirstArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostLikeFindFirstArgs>(args?: SelectSubset<T, PostLikeFindFirstArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindFirstOrThrowArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, PostLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostLikes
     * const postLikes = await prisma.postLike.findMany()
     * 
     * // Get first 10 PostLikes
     * const postLikes = await prisma.postLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postLikeWithIdOnly = await prisma.postLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostLikeFindManyArgs>(args?: SelectSubset<T, PostLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostLike.
     * @param {PostLikeCreateArgs} args - Arguments to create a PostLike.
     * @example
     * // Create one PostLike
     * const PostLike = await prisma.postLike.create({
     *   data: {
     *     // ... data to create a PostLike
     *   }
     * })
     * 
     */
    create<T extends PostLikeCreateArgs>(args: SelectSubset<T, PostLikeCreateArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostLikes.
     * @param {PostLikeCreateManyArgs} args - Arguments to create many PostLikes.
     * @example
     * // Create many PostLikes
     * const postLike = await prisma.postLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostLikeCreateManyArgs>(args?: SelectSubset<T, PostLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PostLike.
     * @param {PostLikeDeleteArgs} args - Arguments to delete one PostLike.
     * @example
     * // Delete one PostLike
     * const PostLike = await prisma.postLike.delete({
     *   where: {
     *     // ... filter to delete one PostLike
     *   }
     * })
     * 
     */
    delete<T extends PostLikeDeleteArgs>(args: SelectSubset<T, PostLikeDeleteArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostLike.
     * @param {PostLikeUpdateArgs} args - Arguments to update one PostLike.
     * @example
     * // Update one PostLike
     * const postLike = await prisma.postLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostLikeUpdateArgs>(args: SelectSubset<T, PostLikeUpdateArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostLikes.
     * @param {PostLikeDeleteManyArgs} args - Arguments to filter PostLikes to delete.
     * @example
     * // Delete a few PostLikes
     * const { count } = await prisma.postLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostLikeDeleteManyArgs>(args?: SelectSubset<T, PostLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostLikes
     * const postLike = await prisma.postLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostLikeUpdateManyArgs>(args: SelectSubset<T, PostLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostLike.
     * @param {PostLikeUpsertArgs} args - Arguments to update or create a PostLike.
     * @example
     * // Update or create a PostLike
     * const postLike = await prisma.postLike.upsert({
     *   create: {
     *     // ... data to create a PostLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostLike we want to update
     *   }
     * })
     */
    upsert<T extends PostLikeUpsertArgs>(args: SelectSubset<T, PostLikeUpsertArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeCountArgs} args - Arguments to filter PostLikes to count.
     * @example
     * // Count the number of PostLikes
     * const count = await prisma.postLike.count({
     *   where: {
     *     // ... the filter for the PostLikes we want to count
     *   }
     * })
    **/
    count<T extends PostLikeCountArgs>(
      args?: Subset<T, PostLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostLikeAggregateArgs>(args: Subset<T, PostLikeAggregateArgs>): Prisma.PrismaPromise<GetPostLikeAggregateType<T>>

    /**
     * Group by PostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostLikeGroupByArgs['orderBy'] }
        : { orderBy?: PostLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostLike model
   */
  readonly fields: PostLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostLike model
   */
  interface PostLikeFieldRefs {
    readonly id: FieldRef<"PostLike", 'Int'>
    readonly postId: FieldRef<"PostLike", 'Int'>
    readonly userId: FieldRef<"PostLike", 'Int'>
    readonly likedAt: FieldRef<"PostLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostLike findUnique
   */
  export type PostLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike findUniqueOrThrow
   */
  export type PostLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike findFirst
   */
  export type PostLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     */
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike findFirstOrThrow
   */
  export type PostLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     */
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike findMany
   */
  export type PostLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLikes to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike create
   */
  export type PostLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a PostLike.
     */
    data: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
  }

  /**
   * PostLike createMany
   */
  export type PostLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostLikes.
     */
    data: PostLikeCreateManyInput | PostLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostLike update
   */
  export type PostLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a PostLike.
     */
    data: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
    /**
     * Choose, which PostLike to update.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike updateMany
   */
  export type PostLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostLikes.
     */
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyInput>
    /**
     * Filter which PostLikes to update
     */
    where?: PostLikeWhereInput
    /**
     * Limit how many PostLikes to update.
     */
    limit?: number
  }

  /**
   * PostLike upsert
   */
  export type PostLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the PostLike to update in case it exists.
     */
    where: PostLikeWhereUniqueInput
    /**
     * In case the PostLike found by the `where` argument doesn't exist, create a new PostLike with this data.
     */
    create: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
    /**
     * In case the PostLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
  }

  /**
   * PostLike delete
   */
  export type PostLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter which PostLike to delete.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike deleteMany
   */
  export type PostLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostLikes to delete
     */
    where?: PostLikeWhereInput
    /**
     * Limit how many PostLikes to delete.
     */
    limit?: number
  }

  /**
   * PostLike without action
   */
  export type PostLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type QuestionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    createdAt: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type QuestionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: number
    userId: number
    title: string
    content: string
    createdAt: Date | null
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    answers?: boolean | Question$answersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>



  export type QuestionSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type QuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "content" | "createdAt", ExtArgs["result"]["question"]>
  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    answers?: boolean | Question$answersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      answers: Prisma.$AnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      title: string
      content: string
      createdAt: Date | null
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends Question$answersArgs<ExtArgs> = {}>(args?: Subset<T, Question$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'Int'>
    readonly userId: FieldRef<"Question", 'Int'>
    readonly title: FieldRef<"Question", 'String'>
    readonly content: FieldRef<"Question", 'String'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to delete.
     */
    limit?: number
  }

  /**
   * Question.answers
   */
  export type Question$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    cursor?: AnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model Answer
   */

  export type AggregateAnswer = {
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  export type AnswerAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
    userId: number | null
  }

  export type AnswerSumAggregateOutputType = {
    id: number | null
    questionId: number | null
    userId: number | null
  }

  export type AnswerMinAggregateOutputType = {
    id: number | null
    questionId: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type AnswerMaxAggregateOutputType = {
    id: number | null
    questionId: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type AnswerCountAggregateOutputType = {
    id: number
    questionId: number
    userId: number
    content: number
    createdAt: number
    _all: number
  }


  export type AnswerAvgAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
  }

  export type AnswerSumAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
  }

  export type AnswerMinAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type AnswerMaxAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type AnswerCountAggregateInputType = {
    id?: true
    questionId?: true
    userId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type AnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answer to aggregate.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answers
    **/
    _count?: true | AnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswerMaxAggregateInputType
  }

  export type GetAnswerAggregateType<T extends AnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer[P]>
      : GetScalarType<T[P], AggregateAnswer[P]>
  }




  export type AnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithAggregationInput | AnswerOrderByWithAggregationInput[]
    by: AnswerScalarFieldEnum[] | AnswerScalarFieldEnum
    having?: AnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswerCountAggregateInputType | true
    _avg?: AnswerAvgAggregateInputType
    _sum?: AnswerSumAggregateInputType
    _min?: AnswerMinAggregateInputType
    _max?: AnswerMaxAggregateInputType
  }

  export type AnswerGroupByOutputType = {
    id: number
    questionId: number
    userId: number
    content: string
    createdAt: Date | null
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  type GetAnswerGroupByPayload<T extends AnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerGroupByOutputType[P]>
        }
      >
    >


  export type AnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>



  export type AnswerSelectScalar = {
    id?: boolean
    questionId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type AnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "userId" | "content" | "createdAt", ExtArgs["result"]["answer"]>
  export type AnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Answer"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionId: number
      userId: number
      content: string
      createdAt: Date | null
    }, ExtArgs["result"]["answer"]>
    composites: {}
  }

  type AnswerGetPayload<S extends boolean | null | undefined | AnswerDefaultArgs> = $Result.GetResult<Prisma.$AnswerPayload, S>

  type AnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnswerCountAggregateInputType | true
    }

  export interface AnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Answer'], meta: { name: 'Answer' } }
    /**
     * Find zero or one Answer that matches the filter.
     * @param {AnswerFindUniqueArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnswerFindUniqueArgs>(args: SelectSubset<T, AnswerFindUniqueArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Answer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnswerFindUniqueOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, AnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnswerFindFirstArgs>(args?: SelectSubset<T, AnswerFindFirstArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, AnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answer.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answerWithIdOnly = await prisma.answer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnswerFindManyArgs>(args?: SelectSubset<T, AnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Answer.
     * @param {AnswerCreateArgs} args - Arguments to create a Answer.
     * @example
     * // Create one Answer
     * const Answer = await prisma.answer.create({
     *   data: {
     *     // ... data to create a Answer
     *   }
     * })
     * 
     */
    create<T extends AnswerCreateArgs>(args: SelectSubset<T, AnswerCreateArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Answers.
     * @param {AnswerCreateManyArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answer = await prisma.answer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnswerCreateManyArgs>(args?: SelectSubset<T, AnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Answer.
     * @param {AnswerDeleteArgs} args - Arguments to delete one Answer.
     * @example
     * // Delete one Answer
     * const Answer = await prisma.answer.delete({
     *   where: {
     *     // ... filter to delete one Answer
     *   }
     * })
     * 
     */
    delete<T extends AnswerDeleteArgs>(args: SelectSubset<T, AnswerDeleteArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Answer.
     * @param {AnswerUpdateArgs} args - Arguments to update one Answer.
     * @example
     * // Update one Answer
     * const answer = await prisma.answer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnswerUpdateArgs>(args: SelectSubset<T, AnswerUpdateArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Answers.
     * @param {AnswerDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnswerDeleteManyArgs>(args?: SelectSubset<T, AnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnswerUpdateManyArgs>(args: SelectSubset<T, AnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Answer.
     * @param {AnswerUpsertArgs} args - Arguments to update or create a Answer.
     * @example
     * // Update or create a Answer
     * const answer = await prisma.answer.upsert({
     *   create: {
     *     // ... data to create a Answer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer we want to update
     *   }
     * })
     */
    upsert<T extends AnswerUpsertArgs>(args: SelectSubset<T, AnswerUpsertArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answer.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends AnswerCountArgs>(
      args?: Subset<T, AnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswerAggregateArgs>(args: Subset<T, AnswerAggregateArgs>): Prisma.PrismaPromise<GetAnswerAggregateType<T>>

    /**
     * Group by Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerGroupByArgs['orderBy'] }
        : { orderBy?: AnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Answer model
   */
  readonly fields: AnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Answer model
   */
  interface AnswerFieldRefs {
    readonly id: FieldRef<"Answer", 'Int'>
    readonly questionId: FieldRef<"Answer", 'Int'>
    readonly userId: FieldRef<"Answer", 'Int'>
    readonly content: FieldRef<"Answer", 'String'>
    readonly createdAt: FieldRef<"Answer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Answer findUnique
   */
  export type AnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer findUniqueOrThrow
   */
  export type AnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer findFirst
   */
  export type AnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer findFirstOrThrow
   */
  export type AnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer findMany
   */
  export type AnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer create
   */
  export type AnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a Answer.
     */
    data: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
  }

  /**
   * Answer createMany
   */
  export type AnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Answers.
     */
    data: AnswerCreateManyInput | AnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Answer update
   */
  export type AnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a Answer.
     */
    data: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
    /**
     * Choose, which Answer to update.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer updateMany
   */
  export type AnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswerWhereInput
    /**
     * Limit how many Answers to update.
     */
    limit?: number
  }

  /**
   * Answer upsert
   */
  export type AnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the Answer to update in case it exists.
     */
    where: AnswerWhereUniqueInput
    /**
     * In case the Answer found by the `where` argument doesn't exist, create a new Answer with this data.
     */
    create: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
    /**
     * In case the Answer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
  }

  /**
   * Answer delete
   */
  export type AnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter which Answer to delete.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer deleteMany
   */
  export type AnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to delete
     */
    where?: AnswerWhereInput
    /**
     * Limit how many Answers to delete.
     */
    limit?: number
  }

  /**
   * Answer without action
   */
  export type AnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
  }


  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionSumAggregateOutputType = {
    id: number | null
  }

  export type RegionMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RegionMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    id?: true
  }

  export type RegionSumAggregateInputType = {
    id?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: number
    name: string
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    theaters?: boolean | Region$theatersArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>



  export type RegionSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RegionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["region"]>
  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    theaters?: boolean | Region$theatersArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      theaters: Prisma.$TheaterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["region"]>
    composites: {}
  }

  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFindUniqueArgs>(args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Region that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFindFirstArgs>(args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionFindManyArgs>(args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
     */
    create<T extends RegionCreateArgs>(args: SelectSubset<T, RegionCreateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Regions.
     * @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionCreateManyArgs>(args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
     */
    delete<T extends RegionDeleteArgs>(args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionUpdateArgs>(args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionDeleteManyArgs>(args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionUpdateManyArgs>(args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
     */
    upsert<T extends RegionUpsertArgs>(args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    theaters<T extends Region$theatersArgs<ExtArgs> = {}>(args?: Subset<T, Region$theatersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TheaterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Region model
   */
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'Int'>
    readonly name: FieldRef<"Region", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }

  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to delete.
     */
    limit?: number
  }

  /**
   * Region.theaters
   */
  export type Region$theatersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theater
     */
    select?: TheaterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theater
     */
    omit?: TheaterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TheaterInclude<ExtArgs> | null
    where?: TheaterWhereInput
    orderBy?: TheaterOrderByWithRelationInput | TheaterOrderByWithRelationInput[]
    cursor?: TheaterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TheaterScalarFieldEnum | TheaterScalarFieldEnum[]
  }

  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
  }


  /**
   * Model Casting
   */

  export type AggregateCasting = {
    _count: CastingCountAggregateOutputType | null
    _avg: CastingAvgAggregateOutputType | null
    _sum: CastingSumAggregateOutputType | null
    _min: CastingMinAggregateOutputType | null
    _max: CastingMaxAggregateOutputType | null
  }

  export type CastingAvgAggregateOutputType = {
    id: number | null
    musicalId: number | null
    actorId: number | null
  }

  export type CastingSumAggregateOutputType = {
    id: number | null
    musicalId: number | null
    actorId: number | null
  }

  export type CastingMinAggregateOutputType = {
    id: number | null
    musicalId: number | null
    actorId: number | null
    role: string | null
  }

  export type CastingMaxAggregateOutputType = {
    id: number | null
    musicalId: number | null
    actorId: number | null
    role: string | null
  }

  export type CastingCountAggregateOutputType = {
    id: number
    musicalId: number
    actorId: number
    role: number
    _all: number
  }


  export type CastingAvgAggregateInputType = {
    id?: true
    musicalId?: true
    actorId?: true
  }

  export type CastingSumAggregateInputType = {
    id?: true
    musicalId?: true
    actorId?: true
  }

  export type CastingMinAggregateInputType = {
    id?: true
    musicalId?: true
    actorId?: true
    role?: true
  }

  export type CastingMaxAggregateInputType = {
    id?: true
    musicalId?: true
    actorId?: true
    role?: true
  }

  export type CastingCountAggregateInputType = {
    id?: true
    musicalId?: true
    actorId?: true
    role?: true
    _all?: true
  }

  export type CastingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Casting to aggregate.
     */
    where?: CastingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Castings to fetch.
     */
    orderBy?: CastingOrderByWithRelationInput | CastingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CastingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Castings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Castings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Castings
    **/
    _count?: true | CastingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CastingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CastingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CastingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CastingMaxAggregateInputType
  }

  export type GetCastingAggregateType<T extends CastingAggregateArgs> = {
        [P in keyof T & keyof AggregateCasting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCasting[P]>
      : GetScalarType<T[P], AggregateCasting[P]>
  }




  export type CastingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastingWhereInput
    orderBy?: CastingOrderByWithAggregationInput | CastingOrderByWithAggregationInput[]
    by: CastingScalarFieldEnum[] | CastingScalarFieldEnum
    having?: CastingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CastingCountAggregateInputType | true
    _avg?: CastingAvgAggregateInputType
    _sum?: CastingSumAggregateInputType
    _min?: CastingMinAggregateInputType
    _max?: CastingMaxAggregateInputType
  }

  export type CastingGroupByOutputType = {
    id: number
    musicalId: number
    actorId: number
    role: string | null
    _count: CastingCountAggregateOutputType | null
    _avg: CastingAvgAggregateOutputType | null
    _sum: CastingSumAggregateOutputType | null
    _min: CastingMinAggregateOutputType | null
    _max: CastingMaxAggregateOutputType | null
  }

  type GetCastingGroupByPayload<T extends CastingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CastingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CastingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CastingGroupByOutputType[P]>
            : GetScalarType<T[P], CastingGroupByOutputType[P]>
        }
      >
    >


  export type CastingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    musicalId?: boolean
    actorId?: boolean
    role?: boolean
    musical?: boolean | MusicalDefaultArgs<ExtArgs>
    actor?: boolean | ActorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["casting"]>



  export type CastingSelectScalar = {
    id?: boolean
    musicalId?: boolean
    actorId?: boolean
    role?: boolean
  }

  export type CastingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "musicalId" | "actorId" | "role", ExtArgs["result"]["casting"]>
  export type CastingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    musical?: boolean | MusicalDefaultArgs<ExtArgs>
    actor?: boolean | ActorDefaultArgs<ExtArgs>
  }

  export type $CastingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Casting"
    objects: {
      musical: Prisma.$MusicalPayload<ExtArgs>
      actor: Prisma.$ActorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      musicalId: number
      actorId: number
      role: string | null
    }, ExtArgs["result"]["casting"]>
    composites: {}
  }

  type CastingGetPayload<S extends boolean | null | undefined | CastingDefaultArgs> = $Result.GetResult<Prisma.$CastingPayload, S>

  type CastingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CastingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CastingCountAggregateInputType | true
    }

  export interface CastingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Casting'], meta: { name: 'Casting' } }
    /**
     * Find zero or one Casting that matches the filter.
     * @param {CastingFindUniqueArgs} args - Arguments to find a Casting
     * @example
     * // Get one Casting
     * const casting = await prisma.casting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CastingFindUniqueArgs>(args: SelectSubset<T, CastingFindUniqueArgs<ExtArgs>>): Prisma__CastingClient<$Result.GetResult<Prisma.$CastingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Casting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CastingFindUniqueOrThrowArgs} args - Arguments to find a Casting
     * @example
     * // Get one Casting
     * const casting = await prisma.casting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CastingFindUniqueOrThrowArgs>(args: SelectSubset<T, CastingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CastingClient<$Result.GetResult<Prisma.$CastingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Casting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingFindFirstArgs} args - Arguments to find a Casting
     * @example
     * // Get one Casting
     * const casting = await prisma.casting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CastingFindFirstArgs>(args?: SelectSubset<T, CastingFindFirstArgs<ExtArgs>>): Prisma__CastingClient<$Result.GetResult<Prisma.$CastingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Casting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingFindFirstOrThrowArgs} args - Arguments to find a Casting
     * @example
     * // Get one Casting
     * const casting = await prisma.casting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CastingFindFirstOrThrowArgs>(args?: SelectSubset<T, CastingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CastingClient<$Result.GetResult<Prisma.$CastingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Castings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Castings
     * const castings = await prisma.casting.findMany()
     * 
     * // Get first 10 Castings
     * const castings = await prisma.casting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const castingWithIdOnly = await prisma.casting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CastingFindManyArgs>(args?: SelectSubset<T, CastingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Casting.
     * @param {CastingCreateArgs} args - Arguments to create a Casting.
     * @example
     * // Create one Casting
     * const Casting = await prisma.casting.create({
     *   data: {
     *     // ... data to create a Casting
     *   }
     * })
     * 
     */
    create<T extends CastingCreateArgs>(args: SelectSubset<T, CastingCreateArgs<ExtArgs>>): Prisma__CastingClient<$Result.GetResult<Prisma.$CastingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Castings.
     * @param {CastingCreateManyArgs} args - Arguments to create many Castings.
     * @example
     * // Create many Castings
     * const casting = await prisma.casting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CastingCreateManyArgs>(args?: SelectSubset<T, CastingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Casting.
     * @param {CastingDeleteArgs} args - Arguments to delete one Casting.
     * @example
     * // Delete one Casting
     * const Casting = await prisma.casting.delete({
     *   where: {
     *     // ... filter to delete one Casting
     *   }
     * })
     * 
     */
    delete<T extends CastingDeleteArgs>(args: SelectSubset<T, CastingDeleteArgs<ExtArgs>>): Prisma__CastingClient<$Result.GetResult<Prisma.$CastingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Casting.
     * @param {CastingUpdateArgs} args - Arguments to update one Casting.
     * @example
     * // Update one Casting
     * const casting = await prisma.casting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CastingUpdateArgs>(args: SelectSubset<T, CastingUpdateArgs<ExtArgs>>): Prisma__CastingClient<$Result.GetResult<Prisma.$CastingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Castings.
     * @param {CastingDeleteManyArgs} args - Arguments to filter Castings to delete.
     * @example
     * // Delete a few Castings
     * const { count } = await prisma.casting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CastingDeleteManyArgs>(args?: SelectSubset<T, CastingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Castings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Castings
     * const casting = await prisma.casting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CastingUpdateManyArgs>(args: SelectSubset<T, CastingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Casting.
     * @param {CastingUpsertArgs} args - Arguments to update or create a Casting.
     * @example
     * // Update or create a Casting
     * const casting = await prisma.casting.upsert({
     *   create: {
     *     // ... data to create a Casting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Casting we want to update
     *   }
     * })
     */
    upsert<T extends CastingUpsertArgs>(args: SelectSubset<T, CastingUpsertArgs<ExtArgs>>): Prisma__CastingClient<$Result.GetResult<Prisma.$CastingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Castings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingCountArgs} args - Arguments to filter Castings to count.
     * @example
     * // Count the number of Castings
     * const count = await prisma.casting.count({
     *   where: {
     *     // ... the filter for the Castings we want to count
     *   }
     * })
    **/
    count<T extends CastingCountArgs>(
      args?: Subset<T, CastingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CastingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Casting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CastingAggregateArgs>(args: Subset<T, CastingAggregateArgs>): Prisma.PrismaPromise<GetCastingAggregateType<T>>

    /**
     * Group by Casting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CastingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CastingGroupByArgs['orderBy'] }
        : { orderBy?: CastingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CastingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCastingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Casting model
   */
  readonly fields: CastingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Casting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CastingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    musical<T extends MusicalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MusicalDefaultArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    actor<T extends ActorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActorDefaultArgs<ExtArgs>>): Prisma__ActorClient<$Result.GetResult<Prisma.$ActorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Casting model
   */
  interface CastingFieldRefs {
    readonly id: FieldRef<"Casting", 'Int'>
    readonly musicalId: FieldRef<"Casting", 'Int'>
    readonly actorId: FieldRef<"Casting", 'Int'>
    readonly role: FieldRef<"Casting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Casting findUnique
   */
  export type CastingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
    /**
     * Filter, which Casting to fetch.
     */
    where: CastingWhereUniqueInput
  }

  /**
   * Casting findUniqueOrThrow
   */
  export type CastingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
    /**
     * Filter, which Casting to fetch.
     */
    where: CastingWhereUniqueInput
  }

  /**
   * Casting findFirst
   */
  export type CastingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
    /**
     * Filter, which Casting to fetch.
     */
    where?: CastingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Castings to fetch.
     */
    orderBy?: CastingOrderByWithRelationInput | CastingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Castings.
     */
    cursor?: CastingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Castings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Castings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Castings.
     */
    distinct?: CastingScalarFieldEnum | CastingScalarFieldEnum[]
  }

  /**
   * Casting findFirstOrThrow
   */
  export type CastingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
    /**
     * Filter, which Casting to fetch.
     */
    where?: CastingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Castings to fetch.
     */
    orderBy?: CastingOrderByWithRelationInput | CastingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Castings.
     */
    cursor?: CastingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Castings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Castings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Castings.
     */
    distinct?: CastingScalarFieldEnum | CastingScalarFieldEnum[]
  }

  /**
   * Casting findMany
   */
  export type CastingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
    /**
     * Filter, which Castings to fetch.
     */
    where?: CastingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Castings to fetch.
     */
    orderBy?: CastingOrderByWithRelationInput | CastingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Castings.
     */
    cursor?: CastingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Castings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Castings.
     */
    skip?: number
    distinct?: CastingScalarFieldEnum | CastingScalarFieldEnum[]
  }

  /**
   * Casting create
   */
  export type CastingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
    /**
     * The data needed to create a Casting.
     */
    data: XOR<CastingCreateInput, CastingUncheckedCreateInput>
  }

  /**
   * Casting createMany
   */
  export type CastingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Castings.
     */
    data: CastingCreateManyInput | CastingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Casting update
   */
  export type CastingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
    /**
     * The data needed to update a Casting.
     */
    data: XOR<CastingUpdateInput, CastingUncheckedUpdateInput>
    /**
     * Choose, which Casting to update.
     */
    where: CastingWhereUniqueInput
  }

  /**
   * Casting updateMany
   */
  export type CastingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Castings.
     */
    data: XOR<CastingUpdateManyMutationInput, CastingUncheckedUpdateManyInput>
    /**
     * Filter which Castings to update
     */
    where?: CastingWhereInput
    /**
     * Limit how many Castings to update.
     */
    limit?: number
  }

  /**
   * Casting upsert
   */
  export type CastingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
    /**
     * The filter to search for the Casting to update in case it exists.
     */
    where: CastingWhereUniqueInput
    /**
     * In case the Casting found by the `where` argument doesn't exist, create a new Casting with this data.
     */
    create: XOR<CastingCreateInput, CastingUncheckedCreateInput>
    /**
     * In case the Casting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CastingUpdateInput, CastingUncheckedUpdateInput>
  }

  /**
   * Casting delete
   */
  export type CastingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
    /**
     * Filter which Casting to delete.
     */
    where: CastingWhereUniqueInput
  }

  /**
   * Casting deleteMany
   */
  export type CastingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Castings to delete
     */
    where?: CastingWhereInput
    /**
     * Limit how many Castings to delete.
     */
    limit?: number
  }

  /**
   * Casting without action
   */
  export type CastingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casting
     */
    select?: CastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Casting
     */
    omit?: CastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingInclude<ExtArgs> | null
  }


  /**
   * Model UserCommunity
   */

  export type AggregateUserCommunity = {
    _count: UserCommunityCountAggregateOutputType | null
    _avg: UserCommunityAvgAggregateOutputType | null
    _sum: UserCommunitySumAggregateOutputType | null
    _min: UserCommunityMinAggregateOutputType | null
    _max: UserCommunityMaxAggregateOutputType | null
  }

  export type UserCommunityAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    communityId: number | null
  }

  export type UserCommunitySumAggregateOutputType = {
    id: number | null
    userId: number | null
    communityId: number | null
  }

  export type UserCommunityMinAggregateOutputType = {
    id: number | null
    userId: number | null
    communityId: number | null
    joinedAt: Date | null
  }

  export type UserCommunityMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    communityId: number | null
    joinedAt: Date | null
  }

  export type UserCommunityCountAggregateOutputType = {
    id: number
    userId: number
    communityId: number
    joinedAt: number
    _all: number
  }


  export type UserCommunityAvgAggregateInputType = {
    id?: true
    userId?: true
    communityId?: true
  }

  export type UserCommunitySumAggregateInputType = {
    id?: true
    userId?: true
    communityId?: true
  }

  export type UserCommunityMinAggregateInputType = {
    id?: true
    userId?: true
    communityId?: true
    joinedAt?: true
  }

  export type UserCommunityMaxAggregateInputType = {
    id?: true
    userId?: true
    communityId?: true
    joinedAt?: true
  }

  export type UserCommunityCountAggregateInputType = {
    id?: true
    userId?: true
    communityId?: true
    joinedAt?: true
    _all?: true
  }

  export type UserCommunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCommunity to aggregate.
     */
    where?: UserCommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCommunities to fetch.
     */
    orderBy?: UserCommunityOrderByWithRelationInput | UserCommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCommunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCommunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCommunities
    **/
    _count?: true | UserCommunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCommunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCommunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCommunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCommunityMaxAggregateInputType
  }

  export type GetUserCommunityAggregateType<T extends UserCommunityAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCommunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCommunity[P]>
      : GetScalarType<T[P], AggregateUserCommunity[P]>
  }




  export type UserCommunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCommunityWhereInput
    orderBy?: UserCommunityOrderByWithAggregationInput | UserCommunityOrderByWithAggregationInput[]
    by: UserCommunityScalarFieldEnum[] | UserCommunityScalarFieldEnum
    having?: UserCommunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCommunityCountAggregateInputType | true
    _avg?: UserCommunityAvgAggregateInputType
    _sum?: UserCommunitySumAggregateInputType
    _min?: UserCommunityMinAggregateInputType
    _max?: UserCommunityMaxAggregateInputType
  }

  export type UserCommunityGroupByOutputType = {
    id: number
    userId: number
    communityId: number
    joinedAt: Date | null
    _count: UserCommunityCountAggregateOutputType | null
    _avg: UserCommunityAvgAggregateOutputType | null
    _sum: UserCommunitySumAggregateOutputType | null
    _min: UserCommunityMinAggregateOutputType | null
    _max: UserCommunityMaxAggregateOutputType | null
  }

  type GetUserCommunityGroupByPayload<T extends UserCommunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCommunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCommunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCommunityGroupByOutputType[P]>
            : GetScalarType<T[P], UserCommunityGroupByOutputType[P]>
        }
      >
    >


  export type UserCommunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    communityId?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCommunity"]>



  export type UserCommunitySelectScalar = {
    id?: boolean
    userId?: boolean
    communityId?: boolean
    joinedAt?: boolean
  }

  export type UserCommunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "communityId" | "joinedAt", ExtArgs["result"]["userCommunity"]>
  export type UserCommunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }

  export type $UserCommunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCommunity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      community: Prisma.$CommunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      communityId: number
      joinedAt: Date | null
    }, ExtArgs["result"]["userCommunity"]>
    composites: {}
  }

  type UserCommunityGetPayload<S extends boolean | null | undefined | UserCommunityDefaultArgs> = $Result.GetResult<Prisma.$UserCommunityPayload, S>

  type UserCommunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCommunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCommunityCountAggregateInputType | true
    }

  export interface UserCommunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCommunity'], meta: { name: 'UserCommunity' } }
    /**
     * Find zero or one UserCommunity that matches the filter.
     * @param {UserCommunityFindUniqueArgs} args - Arguments to find a UserCommunity
     * @example
     * // Get one UserCommunity
     * const userCommunity = await prisma.userCommunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCommunityFindUniqueArgs>(args: SelectSubset<T, UserCommunityFindUniqueArgs<ExtArgs>>): Prisma__UserCommunityClient<$Result.GetResult<Prisma.$UserCommunityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCommunity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCommunityFindUniqueOrThrowArgs} args - Arguments to find a UserCommunity
     * @example
     * // Get one UserCommunity
     * const userCommunity = await prisma.userCommunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCommunityFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCommunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCommunityClient<$Result.GetResult<Prisma.$UserCommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCommunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommunityFindFirstArgs} args - Arguments to find a UserCommunity
     * @example
     * // Get one UserCommunity
     * const userCommunity = await prisma.userCommunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCommunityFindFirstArgs>(args?: SelectSubset<T, UserCommunityFindFirstArgs<ExtArgs>>): Prisma__UserCommunityClient<$Result.GetResult<Prisma.$UserCommunityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCommunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommunityFindFirstOrThrowArgs} args - Arguments to find a UserCommunity
     * @example
     * // Get one UserCommunity
     * const userCommunity = await prisma.userCommunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCommunityFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCommunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCommunityClient<$Result.GetResult<Prisma.$UserCommunityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCommunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCommunities
     * const userCommunities = await prisma.userCommunity.findMany()
     * 
     * // Get first 10 UserCommunities
     * const userCommunities = await prisma.userCommunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCommunityWithIdOnly = await prisma.userCommunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCommunityFindManyArgs>(args?: SelectSubset<T, UserCommunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCommunity.
     * @param {UserCommunityCreateArgs} args - Arguments to create a UserCommunity.
     * @example
     * // Create one UserCommunity
     * const UserCommunity = await prisma.userCommunity.create({
     *   data: {
     *     // ... data to create a UserCommunity
     *   }
     * })
     * 
     */
    create<T extends UserCommunityCreateArgs>(args: SelectSubset<T, UserCommunityCreateArgs<ExtArgs>>): Prisma__UserCommunityClient<$Result.GetResult<Prisma.$UserCommunityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCommunities.
     * @param {UserCommunityCreateManyArgs} args - Arguments to create many UserCommunities.
     * @example
     * // Create many UserCommunities
     * const userCommunity = await prisma.userCommunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCommunityCreateManyArgs>(args?: SelectSubset<T, UserCommunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserCommunity.
     * @param {UserCommunityDeleteArgs} args - Arguments to delete one UserCommunity.
     * @example
     * // Delete one UserCommunity
     * const UserCommunity = await prisma.userCommunity.delete({
     *   where: {
     *     // ... filter to delete one UserCommunity
     *   }
     * })
     * 
     */
    delete<T extends UserCommunityDeleteArgs>(args: SelectSubset<T, UserCommunityDeleteArgs<ExtArgs>>): Prisma__UserCommunityClient<$Result.GetResult<Prisma.$UserCommunityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCommunity.
     * @param {UserCommunityUpdateArgs} args - Arguments to update one UserCommunity.
     * @example
     * // Update one UserCommunity
     * const userCommunity = await prisma.userCommunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCommunityUpdateArgs>(args: SelectSubset<T, UserCommunityUpdateArgs<ExtArgs>>): Prisma__UserCommunityClient<$Result.GetResult<Prisma.$UserCommunityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCommunities.
     * @param {UserCommunityDeleteManyArgs} args - Arguments to filter UserCommunities to delete.
     * @example
     * // Delete a few UserCommunities
     * const { count } = await prisma.userCommunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCommunityDeleteManyArgs>(args?: SelectSubset<T, UserCommunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCommunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCommunities
     * const userCommunity = await prisma.userCommunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCommunityUpdateManyArgs>(args: SelectSubset<T, UserCommunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCommunity.
     * @param {UserCommunityUpsertArgs} args - Arguments to update or create a UserCommunity.
     * @example
     * // Update or create a UserCommunity
     * const userCommunity = await prisma.userCommunity.upsert({
     *   create: {
     *     // ... data to create a UserCommunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCommunity we want to update
     *   }
     * })
     */
    upsert<T extends UserCommunityUpsertArgs>(args: SelectSubset<T, UserCommunityUpsertArgs<ExtArgs>>): Prisma__UserCommunityClient<$Result.GetResult<Prisma.$UserCommunityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCommunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommunityCountArgs} args - Arguments to filter UserCommunities to count.
     * @example
     * // Count the number of UserCommunities
     * const count = await prisma.userCommunity.count({
     *   where: {
     *     // ... the filter for the UserCommunities we want to count
     *   }
     * })
    **/
    count<T extends UserCommunityCountArgs>(
      args?: Subset<T, UserCommunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCommunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCommunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCommunityAggregateArgs>(args: Subset<T, UserCommunityAggregateArgs>): Prisma.PrismaPromise<GetUserCommunityAggregateType<T>>

    /**
     * Group by UserCommunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCommunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCommunityGroupByArgs['orderBy'] }
        : { orderBy?: UserCommunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCommunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCommunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCommunity model
   */
  readonly fields: UserCommunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCommunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCommunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCommunity model
   */
  interface UserCommunityFieldRefs {
    readonly id: FieldRef<"UserCommunity", 'Int'>
    readonly userId: FieldRef<"UserCommunity", 'Int'>
    readonly communityId: FieldRef<"UserCommunity", 'Int'>
    readonly joinedAt: FieldRef<"UserCommunity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserCommunity findUnique
   */
  export type UserCommunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
    /**
     * Filter, which UserCommunity to fetch.
     */
    where: UserCommunityWhereUniqueInput
  }

  /**
   * UserCommunity findUniqueOrThrow
   */
  export type UserCommunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
    /**
     * Filter, which UserCommunity to fetch.
     */
    where: UserCommunityWhereUniqueInput
  }

  /**
   * UserCommunity findFirst
   */
  export type UserCommunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
    /**
     * Filter, which UserCommunity to fetch.
     */
    where?: UserCommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCommunities to fetch.
     */
    orderBy?: UserCommunityOrderByWithRelationInput | UserCommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCommunities.
     */
    cursor?: UserCommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCommunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCommunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCommunities.
     */
    distinct?: UserCommunityScalarFieldEnum | UserCommunityScalarFieldEnum[]
  }

  /**
   * UserCommunity findFirstOrThrow
   */
  export type UserCommunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
    /**
     * Filter, which UserCommunity to fetch.
     */
    where?: UserCommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCommunities to fetch.
     */
    orderBy?: UserCommunityOrderByWithRelationInput | UserCommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCommunities.
     */
    cursor?: UserCommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCommunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCommunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCommunities.
     */
    distinct?: UserCommunityScalarFieldEnum | UserCommunityScalarFieldEnum[]
  }

  /**
   * UserCommunity findMany
   */
  export type UserCommunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
    /**
     * Filter, which UserCommunities to fetch.
     */
    where?: UserCommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCommunities to fetch.
     */
    orderBy?: UserCommunityOrderByWithRelationInput | UserCommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCommunities.
     */
    cursor?: UserCommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCommunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCommunities.
     */
    skip?: number
    distinct?: UserCommunityScalarFieldEnum | UserCommunityScalarFieldEnum[]
  }

  /**
   * UserCommunity create
   */
  export type UserCommunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCommunity.
     */
    data: XOR<UserCommunityCreateInput, UserCommunityUncheckedCreateInput>
  }

  /**
   * UserCommunity createMany
   */
  export type UserCommunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCommunities.
     */
    data: UserCommunityCreateManyInput | UserCommunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCommunity update
   */
  export type UserCommunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCommunity.
     */
    data: XOR<UserCommunityUpdateInput, UserCommunityUncheckedUpdateInput>
    /**
     * Choose, which UserCommunity to update.
     */
    where: UserCommunityWhereUniqueInput
  }

  /**
   * UserCommunity updateMany
   */
  export type UserCommunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCommunities.
     */
    data: XOR<UserCommunityUpdateManyMutationInput, UserCommunityUncheckedUpdateManyInput>
    /**
     * Filter which UserCommunities to update
     */
    where?: UserCommunityWhereInput
    /**
     * Limit how many UserCommunities to update.
     */
    limit?: number
  }

  /**
   * UserCommunity upsert
   */
  export type UserCommunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCommunity to update in case it exists.
     */
    where: UserCommunityWhereUniqueInput
    /**
     * In case the UserCommunity found by the `where` argument doesn't exist, create a new UserCommunity with this data.
     */
    create: XOR<UserCommunityCreateInput, UserCommunityUncheckedCreateInput>
    /**
     * In case the UserCommunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCommunityUpdateInput, UserCommunityUncheckedUpdateInput>
  }

  /**
   * UserCommunity delete
   */
  export type UserCommunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
    /**
     * Filter which UserCommunity to delete.
     */
    where: UserCommunityWhereUniqueInput
  }

  /**
   * UserCommunity deleteMany
   */
  export type UserCommunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCommunities to delete
     */
    where?: UserCommunityWhereInput
    /**
     * Limit how many UserCommunities to delete.
     */
    limit?: number
  }

  /**
   * UserCommunity without action
   */
  export type UserCommunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCommunity
     */
    select?: UserCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCommunity
     */
    omit?: UserCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommunityInclude<ExtArgs> | null
  }


  /**
   * Model MusicalCommunity
   */

  export type AggregateMusicalCommunity = {
    _count: MusicalCommunityCountAggregateOutputType | null
    _avg: MusicalCommunityAvgAggregateOutputType | null
    _sum: MusicalCommunitySumAggregateOutputType | null
    _min: MusicalCommunityMinAggregateOutputType | null
    _max: MusicalCommunityMaxAggregateOutputType | null
  }

  export type MusicalCommunityAvgAggregateOutputType = {
    id: number | null
    musicalId: number | null
    communityId: number | null
  }

  export type MusicalCommunitySumAggregateOutputType = {
    id: number | null
    musicalId: number | null
    communityId: number | null
  }

  export type MusicalCommunityMinAggregateOutputType = {
    id: number | null
    musicalId: number | null
    communityId: number | null
  }

  export type MusicalCommunityMaxAggregateOutputType = {
    id: number | null
    musicalId: number | null
    communityId: number | null
  }

  export type MusicalCommunityCountAggregateOutputType = {
    id: number
    musicalId: number
    communityId: number
    _all: number
  }


  export type MusicalCommunityAvgAggregateInputType = {
    id?: true
    musicalId?: true
    communityId?: true
  }

  export type MusicalCommunitySumAggregateInputType = {
    id?: true
    musicalId?: true
    communityId?: true
  }

  export type MusicalCommunityMinAggregateInputType = {
    id?: true
    musicalId?: true
    communityId?: true
  }

  export type MusicalCommunityMaxAggregateInputType = {
    id?: true
    musicalId?: true
    communityId?: true
  }

  export type MusicalCommunityCountAggregateInputType = {
    id?: true
    musicalId?: true
    communityId?: true
    _all?: true
  }

  export type MusicalCommunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MusicalCommunity to aggregate.
     */
    where?: MusicalCommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MusicalCommunities to fetch.
     */
    orderBy?: MusicalCommunityOrderByWithRelationInput | MusicalCommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MusicalCommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MusicalCommunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MusicalCommunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MusicalCommunities
    **/
    _count?: true | MusicalCommunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MusicalCommunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MusicalCommunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MusicalCommunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MusicalCommunityMaxAggregateInputType
  }

  export type GetMusicalCommunityAggregateType<T extends MusicalCommunityAggregateArgs> = {
        [P in keyof T & keyof AggregateMusicalCommunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMusicalCommunity[P]>
      : GetScalarType<T[P], AggregateMusicalCommunity[P]>
  }




  export type MusicalCommunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MusicalCommunityWhereInput
    orderBy?: MusicalCommunityOrderByWithAggregationInput | MusicalCommunityOrderByWithAggregationInput[]
    by: MusicalCommunityScalarFieldEnum[] | MusicalCommunityScalarFieldEnum
    having?: MusicalCommunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MusicalCommunityCountAggregateInputType | true
    _avg?: MusicalCommunityAvgAggregateInputType
    _sum?: MusicalCommunitySumAggregateInputType
    _min?: MusicalCommunityMinAggregateInputType
    _max?: MusicalCommunityMaxAggregateInputType
  }

  export type MusicalCommunityGroupByOutputType = {
    id: number
    musicalId: number
    communityId: number
    _count: MusicalCommunityCountAggregateOutputType | null
    _avg: MusicalCommunityAvgAggregateOutputType | null
    _sum: MusicalCommunitySumAggregateOutputType | null
    _min: MusicalCommunityMinAggregateOutputType | null
    _max: MusicalCommunityMaxAggregateOutputType | null
  }

  type GetMusicalCommunityGroupByPayload<T extends MusicalCommunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MusicalCommunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MusicalCommunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MusicalCommunityGroupByOutputType[P]>
            : GetScalarType<T[P], MusicalCommunityGroupByOutputType[P]>
        }
      >
    >


  export type MusicalCommunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    musicalId?: boolean
    communityId?: boolean
    musical?: boolean | MusicalDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["musicalCommunity"]>



  export type MusicalCommunitySelectScalar = {
    id?: boolean
    musicalId?: boolean
    communityId?: boolean
  }

  export type MusicalCommunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "musicalId" | "communityId", ExtArgs["result"]["musicalCommunity"]>
  export type MusicalCommunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    musical?: boolean | MusicalDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }

  export type $MusicalCommunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MusicalCommunity"
    objects: {
      musical: Prisma.$MusicalPayload<ExtArgs>
      community: Prisma.$CommunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      musicalId: number
      communityId: number
    }, ExtArgs["result"]["musicalCommunity"]>
    composites: {}
  }

  type MusicalCommunityGetPayload<S extends boolean | null | undefined | MusicalCommunityDefaultArgs> = $Result.GetResult<Prisma.$MusicalCommunityPayload, S>

  type MusicalCommunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MusicalCommunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MusicalCommunityCountAggregateInputType | true
    }

  export interface MusicalCommunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MusicalCommunity'], meta: { name: 'MusicalCommunity' } }
    /**
     * Find zero or one MusicalCommunity that matches the filter.
     * @param {MusicalCommunityFindUniqueArgs} args - Arguments to find a MusicalCommunity
     * @example
     * // Get one MusicalCommunity
     * const musicalCommunity = await prisma.musicalCommunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MusicalCommunityFindUniqueArgs>(args: SelectSubset<T, MusicalCommunityFindUniqueArgs<ExtArgs>>): Prisma__MusicalCommunityClient<$Result.GetResult<Prisma.$MusicalCommunityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MusicalCommunity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MusicalCommunityFindUniqueOrThrowArgs} args - Arguments to find a MusicalCommunity
     * @example
     * // Get one MusicalCommunity
     * const musicalCommunity = await prisma.musicalCommunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MusicalCommunityFindUniqueOrThrowArgs>(args: SelectSubset<T, MusicalCommunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MusicalCommunityClient<$Result.GetResult<Prisma.$MusicalCommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MusicalCommunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalCommunityFindFirstArgs} args - Arguments to find a MusicalCommunity
     * @example
     * // Get one MusicalCommunity
     * const musicalCommunity = await prisma.musicalCommunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MusicalCommunityFindFirstArgs>(args?: SelectSubset<T, MusicalCommunityFindFirstArgs<ExtArgs>>): Prisma__MusicalCommunityClient<$Result.GetResult<Prisma.$MusicalCommunityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MusicalCommunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalCommunityFindFirstOrThrowArgs} args - Arguments to find a MusicalCommunity
     * @example
     * // Get one MusicalCommunity
     * const musicalCommunity = await prisma.musicalCommunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MusicalCommunityFindFirstOrThrowArgs>(args?: SelectSubset<T, MusicalCommunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__MusicalCommunityClient<$Result.GetResult<Prisma.$MusicalCommunityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MusicalCommunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalCommunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MusicalCommunities
     * const musicalCommunities = await prisma.musicalCommunity.findMany()
     * 
     * // Get first 10 MusicalCommunities
     * const musicalCommunities = await prisma.musicalCommunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const musicalCommunityWithIdOnly = await prisma.musicalCommunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MusicalCommunityFindManyArgs>(args?: SelectSubset<T, MusicalCommunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MusicalCommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MusicalCommunity.
     * @param {MusicalCommunityCreateArgs} args - Arguments to create a MusicalCommunity.
     * @example
     * // Create one MusicalCommunity
     * const MusicalCommunity = await prisma.musicalCommunity.create({
     *   data: {
     *     // ... data to create a MusicalCommunity
     *   }
     * })
     * 
     */
    create<T extends MusicalCommunityCreateArgs>(args: SelectSubset<T, MusicalCommunityCreateArgs<ExtArgs>>): Prisma__MusicalCommunityClient<$Result.GetResult<Prisma.$MusicalCommunityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MusicalCommunities.
     * @param {MusicalCommunityCreateManyArgs} args - Arguments to create many MusicalCommunities.
     * @example
     * // Create many MusicalCommunities
     * const musicalCommunity = await prisma.musicalCommunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MusicalCommunityCreateManyArgs>(args?: SelectSubset<T, MusicalCommunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MusicalCommunity.
     * @param {MusicalCommunityDeleteArgs} args - Arguments to delete one MusicalCommunity.
     * @example
     * // Delete one MusicalCommunity
     * const MusicalCommunity = await prisma.musicalCommunity.delete({
     *   where: {
     *     // ... filter to delete one MusicalCommunity
     *   }
     * })
     * 
     */
    delete<T extends MusicalCommunityDeleteArgs>(args: SelectSubset<T, MusicalCommunityDeleteArgs<ExtArgs>>): Prisma__MusicalCommunityClient<$Result.GetResult<Prisma.$MusicalCommunityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MusicalCommunity.
     * @param {MusicalCommunityUpdateArgs} args - Arguments to update one MusicalCommunity.
     * @example
     * // Update one MusicalCommunity
     * const musicalCommunity = await prisma.musicalCommunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MusicalCommunityUpdateArgs>(args: SelectSubset<T, MusicalCommunityUpdateArgs<ExtArgs>>): Prisma__MusicalCommunityClient<$Result.GetResult<Prisma.$MusicalCommunityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MusicalCommunities.
     * @param {MusicalCommunityDeleteManyArgs} args - Arguments to filter MusicalCommunities to delete.
     * @example
     * // Delete a few MusicalCommunities
     * const { count } = await prisma.musicalCommunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MusicalCommunityDeleteManyArgs>(args?: SelectSubset<T, MusicalCommunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MusicalCommunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalCommunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MusicalCommunities
     * const musicalCommunity = await prisma.musicalCommunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MusicalCommunityUpdateManyArgs>(args: SelectSubset<T, MusicalCommunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MusicalCommunity.
     * @param {MusicalCommunityUpsertArgs} args - Arguments to update or create a MusicalCommunity.
     * @example
     * // Update or create a MusicalCommunity
     * const musicalCommunity = await prisma.musicalCommunity.upsert({
     *   create: {
     *     // ... data to create a MusicalCommunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MusicalCommunity we want to update
     *   }
     * })
     */
    upsert<T extends MusicalCommunityUpsertArgs>(args: SelectSubset<T, MusicalCommunityUpsertArgs<ExtArgs>>): Prisma__MusicalCommunityClient<$Result.GetResult<Prisma.$MusicalCommunityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MusicalCommunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalCommunityCountArgs} args - Arguments to filter MusicalCommunities to count.
     * @example
     * // Count the number of MusicalCommunities
     * const count = await prisma.musicalCommunity.count({
     *   where: {
     *     // ... the filter for the MusicalCommunities we want to count
     *   }
     * })
    **/
    count<T extends MusicalCommunityCountArgs>(
      args?: Subset<T, MusicalCommunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MusicalCommunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MusicalCommunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalCommunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MusicalCommunityAggregateArgs>(args: Subset<T, MusicalCommunityAggregateArgs>): Prisma.PrismaPromise<GetMusicalCommunityAggregateType<T>>

    /**
     * Group by MusicalCommunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalCommunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MusicalCommunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MusicalCommunityGroupByArgs['orderBy'] }
        : { orderBy?: MusicalCommunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MusicalCommunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMusicalCommunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MusicalCommunity model
   */
  readonly fields: MusicalCommunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MusicalCommunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MusicalCommunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    musical<T extends MusicalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MusicalDefaultArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MusicalCommunity model
   */
  interface MusicalCommunityFieldRefs {
    readonly id: FieldRef<"MusicalCommunity", 'Int'>
    readonly musicalId: FieldRef<"MusicalCommunity", 'Int'>
    readonly communityId: FieldRef<"MusicalCommunity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MusicalCommunity findUnique
   */
  export type MusicalCommunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
    /**
     * Filter, which MusicalCommunity to fetch.
     */
    where: MusicalCommunityWhereUniqueInput
  }

  /**
   * MusicalCommunity findUniqueOrThrow
   */
  export type MusicalCommunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
    /**
     * Filter, which MusicalCommunity to fetch.
     */
    where: MusicalCommunityWhereUniqueInput
  }

  /**
   * MusicalCommunity findFirst
   */
  export type MusicalCommunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
    /**
     * Filter, which MusicalCommunity to fetch.
     */
    where?: MusicalCommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MusicalCommunities to fetch.
     */
    orderBy?: MusicalCommunityOrderByWithRelationInput | MusicalCommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MusicalCommunities.
     */
    cursor?: MusicalCommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MusicalCommunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MusicalCommunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MusicalCommunities.
     */
    distinct?: MusicalCommunityScalarFieldEnum | MusicalCommunityScalarFieldEnum[]
  }

  /**
   * MusicalCommunity findFirstOrThrow
   */
  export type MusicalCommunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
    /**
     * Filter, which MusicalCommunity to fetch.
     */
    where?: MusicalCommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MusicalCommunities to fetch.
     */
    orderBy?: MusicalCommunityOrderByWithRelationInput | MusicalCommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MusicalCommunities.
     */
    cursor?: MusicalCommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MusicalCommunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MusicalCommunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MusicalCommunities.
     */
    distinct?: MusicalCommunityScalarFieldEnum | MusicalCommunityScalarFieldEnum[]
  }

  /**
   * MusicalCommunity findMany
   */
  export type MusicalCommunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
    /**
     * Filter, which MusicalCommunities to fetch.
     */
    where?: MusicalCommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MusicalCommunities to fetch.
     */
    orderBy?: MusicalCommunityOrderByWithRelationInput | MusicalCommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MusicalCommunities.
     */
    cursor?: MusicalCommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MusicalCommunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MusicalCommunities.
     */
    skip?: number
    distinct?: MusicalCommunityScalarFieldEnum | MusicalCommunityScalarFieldEnum[]
  }

  /**
   * MusicalCommunity create
   */
  export type MusicalCommunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
    /**
     * The data needed to create a MusicalCommunity.
     */
    data: XOR<MusicalCommunityCreateInput, MusicalCommunityUncheckedCreateInput>
  }

  /**
   * MusicalCommunity createMany
   */
  export type MusicalCommunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MusicalCommunities.
     */
    data: MusicalCommunityCreateManyInput | MusicalCommunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MusicalCommunity update
   */
  export type MusicalCommunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
    /**
     * The data needed to update a MusicalCommunity.
     */
    data: XOR<MusicalCommunityUpdateInput, MusicalCommunityUncheckedUpdateInput>
    /**
     * Choose, which MusicalCommunity to update.
     */
    where: MusicalCommunityWhereUniqueInput
  }

  /**
   * MusicalCommunity updateMany
   */
  export type MusicalCommunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MusicalCommunities.
     */
    data: XOR<MusicalCommunityUpdateManyMutationInput, MusicalCommunityUncheckedUpdateManyInput>
    /**
     * Filter which MusicalCommunities to update
     */
    where?: MusicalCommunityWhereInput
    /**
     * Limit how many MusicalCommunities to update.
     */
    limit?: number
  }

  /**
   * MusicalCommunity upsert
   */
  export type MusicalCommunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
    /**
     * The filter to search for the MusicalCommunity to update in case it exists.
     */
    where: MusicalCommunityWhereUniqueInput
    /**
     * In case the MusicalCommunity found by the `where` argument doesn't exist, create a new MusicalCommunity with this data.
     */
    create: XOR<MusicalCommunityCreateInput, MusicalCommunityUncheckedCreateInput>
    /**
     * In case the MusicalCommunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MusicalCommunityUpdateInput, MusicalCommunityUncheckedUpdateInput>
  }

  /**
   * MusicalCommunity delete
   */
  export type MusicalCommunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
    /**
     * Filter which MusicalCommunity to delete.
     */
    where: MusicalCommunityWhereUniqueInput
  }

  /**
   * MusicalCommunity deleteMany
   */
  export type MusicalCommunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MusicalCommunities to delete
     */
    where?: MusicalCommunityWhereInput
    /**
     * Limit how many MusicalCommunities to delete.
     */
    limit?: number
  }

  /**
   * MusicalCommunity without action
   */
  export type MusicalCommunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCommunity
     */
    select?: MusicalCommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MusicalCommunity
     */
    omit?: MusicalCommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalCommunityInclude<ExtArgs> | null
  }


  /**
   * Model MultiProfile
   */

  export type AggregateMultiProfile = {
    _count: MultiProfileCountAggregateOutputType | null
    _avg: MultiProfileAvgAggregateOutputType | null
    _sum: MultiProfileSumAggregateOutputType | null
    _min: MultiProfileMinAggregateOutputType | null
    _max: MultiProfileMaxAggregateOutputType | null
  }

  export type MultiProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type MultiProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type MultiProfileMinAggregateOutputType = {
    id: number | null
    userId: number | null
    nickname: string | null
    image: string | null
    bio: string | null
  }

  export type MultiProfileMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    nickname: string | null
    image: string | null
    bio: string | null
  }

  export type MultiProfileCountAggregateOutputType = {
    id: number
    userId: number
    nickname: number
    image: number
    bio: number
    _all: number
  }


  export type MultiProfileAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type MultiProfileSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type MultiProfileMinAggregateInputType = {
    id?: true
    userId?: true
    nickname?: true
    image?: true
    bio?: true
  }

  export type MultiProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    nickname?: true
    image?: true
    bio?: true
  }

  export type MultiProfileCountAggregateInputType = {
    id?: true
    userId?: true
    nickname?: true
    image?: true
    bio?: true
    _all?: true
  }

  export type MultiProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiProfile to aggregate.
     */
    where?: MultiProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiProfiles to fetch.
     */
    orderBy?: MultiProfileOrderByWithRelationInput | MultiProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultiProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MultiProfiles
    **/
    _count?: true | MultiProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MultiProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MultiProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultiProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultiProfileMaxAggregateInputType
  }

  export type GetMultiProfileAggregateType<T extends MultiProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateMultiProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultiProfile[P]>
      : GetScalarType<T[P], AggregateMultiProfile[P]>
  }




  export type MultiProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiProfileWhereInput
    orderBy?: MultiProfileOrderByWithAggregationInput | MultiProfileOrderByWithAggregationInput[]
    by: MultiProfileScalarFieldEnum[] | MultiProfileScalarFieldEnum
    having?: MultiProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultiProfileCountAggregateInputType | true
    _avg?: MultiProfileAvgAggregateInputType
    _sum?: MultiProfileSumAggregateInputType
    _min?: MultiProfileMinAggregateInputType
    _max?: MultiProfileMaxAggregateInputType
  }

  export type MultiProfileGroupByOutputType = {
    id: number
    userId: number
    nickname: string
    image: string | null
    bio: string | null
    _count: MultiProfileCountAggregateOutputType | null
    _avg: MultiProfileAvgAggregateOutputType | null
    _sum: MultiProfileSumAggregateOutputType | null
    _min: MultiProfileMinAggregateOutputType | null
    _max: MultiProfileMaxAggregateOutputType | null
  }

  type GetMultiProfileGroupByPayload<T extends MultiProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultiProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultiProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultiProfileGroupByOutputType[P]>
            : GetScalarType<T[P], MultiProfileGroupByOutputType[P]>
        }
      >
    >


  export type MultiProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    nickname?: boolean
    image?: boolean
    bio?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multiProfile"]>



  export type MultiProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    nickname?: boolean
    image?: boolean
    bio?: boolean
  }

  export type MultiProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "nickname" | "image" | "bio", ExtArgs["result"]["multiProfile"]>
  export type MultiProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MultiProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MultiProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      nickname: string
      image: string | null
      bio: string | null
    }, ExtArgs["result"]["multiProfile"]>
    composites: {}
  }

  type MultiProfileGetPayload<S extends boolean | null | undefined | MultiProfileDefaultArgs> = $Result.GetResult<Prisma.$MultiProfilePayload, S>

  type MultiProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MultiProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MultiProfileCountAggregateInputType | true
    }

  export interface MultiProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MultiProfile'], meta: { name: 'MultiProfile' } }
    /**
     * Find zero or one MultiProfile that matches the filter.
     * @param {MultiProfileFindUniqueArgs} args - Arguments to find a MultiProfile
     * @example
     * // Get one MultiProfile
     * const multiProfile = await prisma.multiProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MultiProfileFindUniqueArgs>(args: SelectSubset<T, MultiProfileFindUniqueArgs<ExtArgs>>): Prisma__MultiProfileClient<$Result.GetResult<Prisma.$MultiProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MultiProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MultiProfileFindUniqueOrThrowArgs} args - Arguments to find a MultiProfile
     * @example
     * // Get one MultiProfile
     * const multiProfile = await prisma.multiProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MultiProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, MultiProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MultiProfileClient<$Result.GetResult<Prisma.$MultiProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiProfileFindFirstArgs} args - Arguments to find a MultiProfile
     * @example
     * // Get one MultiProfile
     * const multiProfile = await prisma.multiProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MultiProfileFindFirstArgs>(args?: SelectSubset<T, MultiProfileFindFirstArgs<ExtArgs>>): Prisma__MultiProfileClient<$Result.GetResult<Prisma.$MultiProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiProfileFindFirstOrThrowArgs} args - Arguments to find a MultiProfile
     * @example
     * // Get one MultiProfile
     * const multiProfile = await prisma.multiProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MultiProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, MultiProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MultiProfileClient<$Result.GetResult<Prisma.$MultiProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MultiProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MultiProfiles
     * const multiProfiles = await prisma.multiProfile.findMany()
     * 
     * // Get first 10 MultiProfiles
     * const multiProfiles = await prisma.multiProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multiProfileWithIdOnly = await prisma.multiProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MultiProfileFindManyArgs>(args?: SelectSubset<T, MultiProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MultiProfile.
     * @param {MultiProfileCreateArgs} args - Arguments to create a MultiProfile.
     * @example
     * // Create one MultiProfile
     * const MultiProfile = await prisma.multiProfile.create({
     *   data: {
     *     // ... data to create a MultiProfile
     *   }
     * })
     * 
     */
    create<T extends MultiProfileCreateArgs>(args: SelectSubset<T, MultiProfileCreateArgs<ExtArgs>>): Prisma__MultiProfileClient<$Result.GetResult<Prisma.$MultiProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MultiProfiles.
     * @param {MultiProfileCreateManyArgs} args - Arguments to create many MultiProfiles.
     * @example
     * // Create many MultiProfiles
     * const multiProfile = await prisma.multiProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MultiProfileCreateManyArgs>(args?: SelectSubset<T, MultiProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MultiProfile.
     * @param {MultiProfileDeleteArgs} args - Arguments to delete one MultiProfile.
     * @example
     * // Delete one MultiProfile
     * const MultiProfile = await prisma.multiProfile.delete({
     *   where: {
     *     // ... filter to delete one MultiProfile
     *   }
     * })
     * 
     */
    delete<T extends MultiProfileDeleteArgs>(args: SelectSubset<T, MultiProfileDeleteArgs<ExtArgs>>): Prisma__MultiProfileClient<$Result.GetResult<Prisma.$MultiProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MultiProfile.
     * @param {MultiProfileUpdateArgs} args - Arguments to update one MultiProfile.
     * @example
     * // Update one MultiProfile
     * const multiProfile = await prisma.multiProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MultiProfileUpdateArgs>(args: SelectSubset<T, MultiProfileUpdateArgs<ExtArgs>>): Prisma__MultiProfileClient<$Result.GetResult<Prisma.$MultiProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MultiProfiles.
     * @param {MultiProfileDeleteManyArgs} args - Arguments to filter MultiProfiles to delete.
     * @example
     * // Delete a few MultiProfiles
     * const { count } = await prisma.multiProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MultiProfileDeleteManyArgs>(args?: SelectSubset<T, MultiProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultiProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MultiProfiles
     * const multiProfile = await prisma.multiProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MultiProfileUpdateManyArgs>(args: SelectSubset<T, MultiProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MultiProfile.
     * @param {MultiProfileUpsertArgs} args - Arguments to update or create a MultiProfile.
     * @example
     * // Update or create a MultiProfile
     * const multiProfile = await prisma.multiProfile.upsert({
     *   create: {
     *     // ... data to create a MultiProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MultiProfile we want to update
     *   }
     * })
     */
    upsert<T extends MultiProfileUpsertArgs>(args: SelectSubset<T, MultiProfileUpsertArgs<ExtArgs>>): Prisma__MultiProfileClient<$Result.GetResult<Prisma.$MultiProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MultiProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiProfileCountArgs} args - Arguments to filter MultiProfiles to count.
     * @example
     * // Count the number of MultiProfiles
     * const count = await prisma.multiProfile.count({
     *   where: {
     *     // ... the filter for the MultiProfiles we want to count
     *   }
     * })
    **/
    count<T extends MultiProfileCountArgs>(
      args?: Subset<T, MultiProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultiProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MultiProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultiProfileAggregateArgs>(args: Subset<T, MultiProfileAggregateArgs>): Prisma.PrismaPromise<GetMultiProfileAggregateType<T>>

    /**
     * Group by MultiProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultiProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultiProfileGroupByArgs['orderBy'] }
        : { orderBy?: MultiProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultiProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultiProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MultiProfile model
   */
  readonly fields: MultiProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MultiProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultiProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MultiProfile model
   */
  interface MultiProfileFieldRefs {
    readonly id: FieldRef<"MultiProfile", 'Int'>
    readonly userId: FieldRef<"MultiProfile", 'Int'>
    readonly nickname: FieldRef<"MultiProfile", 'String'>
    readonly image: FieldRef<"MultiProfile", 'String'>
    readonly bio: FieldRef<"MultiProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MultiProfile findUnique
   */
  export type MultiProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiProfile
     */
    select?: MultiProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiProfile
     */
    omit?: MultiProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiProfileInclude<ExtArgs> | null
    /**
     * Filter, which MultiProfile to fetch.
     */
    where: MultiProfileWhereUniqueInput
  }

  /**
   * MultiProfile findUniqueOrThrow
   */
  export type MultiProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiProfile
     */
    select?: MultiProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiProfile
     */
    omit?: MultiProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiProfileInclude<ExtArgs> | null
    /**
     * Filter, which MultiProfile to fetch.
     */
    where: MultiProfileWhereUniqueInput
  }

  /**
   * MultiProfile findFirst
   */
  export type MultiProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiProfile
     */
    select?: MultiProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiProfile
     */
    omit?: MultiProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiProfileInclude<ExtArgs> | null
    /**
     * Filter, which MultiProfile to fetch.
     */
    where?: MultiProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiProfiles to fetch.
     */
    orderBy?: MultiProfileOrderByWithRelationInput | MultiProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiProfiles.
     */
    cursor?: MultiProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiProfiles.
     */
    distinct?: MultiProfileScalarFieldEnum | MultiProfileScalarFieldEnum[]
  }

  /**
   * MultiProfile findFirstOrThrow
   */
  export type MultiProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiProfile
     */
    select?: MultiProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiProfile
     */
    omit?: MultiProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiProfileInclude<ExtArgs> | null
    /**
     * Filter, which MultiProfile to fetch.
     */
    where?: MultiProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiProfiles to fetch.
     */
    orderBy?: MultiProfileOrderByWithRelationInput | MultiProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiProfiles.
     */
    cursor?: MultiProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiProfiles.
     */
    distinct?: MultiProfileScalarFieldEnum | MultiProfileScalarFieldEnum[]
  }

  /**
   * MultiProfile findMany
   */
  export type MultiProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiProfile
     */
    select?: MultiProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiProfile
     */
    omit?: MultiProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiProfileInclude<ExtArgs> | null
    /**
     * Filter, which MultiProfiles to fetch.
     */
    where?: MultiProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiProfiles to fetch.
     */
    orderBy?: MultiProfileOrderByWithRelationInput | MultiProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MultiProfiles.
     */
    cursor?: MultiProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiProfiles.
     */
    skip?: number
    distinct?: MultiProfileScalarFieldEnum | MultiProfileScalarFieldEnum[]
  }

  /**
   * MultiProfile create
   */
  export type MultiProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiProfile
     */
    select?: MultiProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiProfile
     */
    omit?: MultiProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a MultiProfile.
     */
    data: XOR<MultiProfileCreateInput, MultiProfileUncheckedCreateInput>
  }

  /**
   * MultiProfile createMany
   */
  export type MultiProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MultiProfiles.
     */
    data: MultiProfileCreateManyInput | MultiProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultiProfile update
   */
  export type MultiProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiProfile
     */
    select?: MultiProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiProfile
     */
    omit?: MultiProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a MultiProfile.
     */
    data: XOR<MultiProfileUpdateInput, MultiProfileUncheckedUpdateInput>
    /**
     * Choose, which MultiProfile to update.
     */
    where: MultiProfileWhereUniqueInput
  }

  /**
   * MultiProfile updateMany
   */
  export type MultiProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MultiProfiles.
     */
    data: XOR<MultiProfileUpdateManyMutationInput, MultiProfileUncheckedUpdateManyInput>
    /**
     * Filter which MultiProfiles to update
     */
    where?: MultiProfileWhereInput
    /**
     * Limit how many MultiProfiles to update.
     */
    limit?: number
  }

  /**
   * MultiProfile upsert
   */
  export type MultiProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiProfile
     */
    select?: MultiProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiProfile
     */
    omit?: MultiProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the MultiProfile to update in case it exists.
     */
    where: MultiProfileWhereUniqueInput
    /**
     * In case the MultiProfile found by the `where` argument doesn't exist, create a new MultiProfile with this data.
     */
    create: XOR<MultiProfileCreateInput, MultiProfileUncheckedCreateInput>
    /**
     * In case the MultiProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultiProfileUpdateInput, MultiProfileUncheckedUpdateInput>
  }

  /**
   * MultiProfile delete
   */
  export type MultiProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiProfile
     */
    select?: MultiProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiProfile
     */
    omit?: MultiProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiProfileInclude<ExtArgs> | null
    /**
     * Filter which MultiProfile to delete.
     */
    where: MultiProfileWhereUniqueInput
  }

  /**
   * MultiProfile deleteMany
   */
  export type MultiProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiProfiles to delete
     */
    where?: MultiProfileWhereInput
    /**
     * Limit how many MultiProfiles to delete.
     */
    limit?: number
  }

  /**
   * MultiProfile without action
   */
  export type MultiProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiProfile
     */
    select?: MultiProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiProfile
     */
    omit?: MultiProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiProfileInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    loginId: 'loginId',
    settingId: 'settingId',
    username: 'username',
    password: 'password',
    email: 'email',
    nickname: 'nickname',
    profileImage: 'profileImage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    bio: 'bio',
    birthDate: 'birthDate',
    isSubscribed: 'isSubscribed'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    settingId: 'settingId',
    communityId: 'communityId',
    title: 'title',
    content: 'content',
    category: 'category',
    like: 'like',
    likeCount: 'likeCount',
    commentCount: 'commentCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    repost: 'repost',
    bookmark: 'bookmark',
    communityGroup: 'communityGroup',
    viewCount: 'viewCount',
    tag: 'tag',
    mediaType: 'mediaType',
    isPinned: 'isPinned',
    tabCategory: 'tabCategory',
    isShared: 'isShared',
    musicalId: 'musicalId',
    actorId: 'actorId',
    extraField: 'extraField'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    settingId: 'settingId',
    communityId: 'communityId',
    content: 'content',
    createdAt: 'createdAt',
    anonymous: 'anonymous'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    settingId: 'settingId',
    theaterId: 'theaterId',
    key: 'key',
    postId: 'postId',
    content: 'content',
    rating: 'rating',
    spoiler: 'spoiler',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    liked: 'liked',
    likeCount: 'likeCount',
    comment: 'comment',
    imageUrl: 'imageUrl',
    reported: 'reported',
    watchDate: 'watchDate',
    watchTime: 'watchTime',
    extraField2: 'extraField2'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ActorScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    settingId: 'settingId',
    communityId: 'communityId',
    key: 'key',
    name: 'name',
    image: 'image',
    profile: 'profile',
    snsLink: 'snsLink',
    fk: 'fk'
  };

  export type ActorScalarFieldEnum = (typeof ActorScalarFieldEnum)[keyof typeof ActorScalarFieldEnum]


  export const MusicalScalarFieldEnum: {
    id: 'id',
    theaterId: 'theaterId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    poster: 'poster',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MusicalScalarFieldEnum = (typeof MusicalScalarFieldEnum)[keyof typeof MusicalScalarFieldEnum]


  export const TheaterScalarFieldEnum: {
    id: 'id',
    regionId: 'regionId',
    name: 'name',
    seatCount: 'seatCount',
    roadAddress: 'roadAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TheaterScalarFieldEnum = (typeof TheaterScalarFieldEnum)[keyof typeof TheaterScalarFieldEnum]


  export const SeatScalarFieldEnum: {
    id: 'id',
    theaterId: 'theaterId',
    locationId: 'locationId',
    field: 'field',
    field2: 'field2',
    field3: 'field3',
    floor: 'floor'
  };

  export type SeatScalarFieldEnum = (typeof SeatScalarFieldEnum)[keyof typeof SeatScalarFieldEnum]


  export const CommunityScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    type: 'type',
    description: 'description'
  };

  export type CommunityScalarFieldEnum = (typeof CommunityScalarFieldEnum)[keyof typeof CommunityScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    useBackground: 'useBackground',
    useProfilePhoto: 'useProfilePhoto',
    allowRepost: 'allowRepost'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    url: 'url',
    caption: 'caption'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const SubscribeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive'
  };

  export type SubscribeScalarFieldEnum = (typeof SubscribeScalarFieldEnum)[keyof typeof SubscribeScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingId: 'followingId',
    createdAt: 'createdAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const ViewingRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    musicalId: 'musicalId',
    date: 'date',
    seat: 'seat'
  };

  export type ViewingRecordScalarFieldEnum = (typeof ViewingRecordScalarFieldEnum)[keyof typeof ViewingRecordScalarFieldEnum]


  export const PostLikeScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    likedAt: 'likedAt'
  };

  export type PostLikeScalarFieldEnum = (typeof PostLikeScalarFieldEnum)[keyof typeof PostLikeScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const AnswerScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type AnswerScalarFieldEnum = (typeof AnswerScalarFieldEnum)[keyof typeof AnswerScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const CastingScalarFieldEnum: {
    id: 'id',
    musicalId: 'musicalId',
    actorId: 'actorId',
    role: 'role'
  };

  export type CastingScalarFieldEnum = (typeof CastingScalarFieldEnum)[keyof typeof CastingScalarFieldEnum]


  export const UserCommunityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    communityId: 'communityId',
    joinedAt: 'joinedAt'
  };

  export type UserCommunityScalarFieldEnum = (typeof UserCommunityScalarFieldEnum)[keyof typeof UserCommunityScalarFieldEnum]


  export const MusicalCommunityScalarFieldEnum: {
    id: 'id',
    musicalId: 'musicalId',
    communityId: 'communityId'
  };

  export type MusicalCommunityScalarFieldEnum = (typeof MusicalCommunityScalarFieldEnum)[keyof typeof MusicalCommunityScalarFieldEnum]


  export const MultiProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    nickname: 'nickname',
    image: 'image',
    bio: 'bio'
  };

  export type MultiProfileScalarFieldEnum = (typeof MultiProfileScalarFieldEnum)[keyof typeof MultiProfileScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    loginId: 'loginId',
    username: 'username',
    password: 'password',
    email: 'email',
    nickname: 'nickname',
    profileImage: 'profileImage',
    bio: 'bio'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const PostOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content',
    category: 'category',
    like: 'like',
    communityGroup: 'communityGroup',
    tag: 'tag',
    extraField: 'extraField'
  };

  export type PostOrderByRelevanceFieldEnum = (typeof PostOrderByRelevanceFieldEnum)[keyof typeof PostOrderByRelevanceFieldEnum]


  export const CommentOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type CommentOrderByRelevanceFieldEnum = (typeof CommentOrderByRelevanceFieldEnum)[keyof typeof CommentOrderByRelevanceFieldEnum]


  export const ReviewOrderByRelevanceFieldEnum: {
    content: 'content',
    liked: 'liked',
    comment: 'comment',
    imageUrl: 'imageUrl',
    extraField2: 'extraField2'
  };

  export type ReviewOrderByRelevanceFieldEnum = (typeof ReviewOrderByRelevanceFieldEnum)[keyof typeof ReviewOrderByRelevanceFieldEnum]


  export const ActorOrderByRelevanceFieldEnum: {
    name: 'name',
    image: 'image',
    profile: 'profile',
    snsLink: 'snsLink'
  };

  export type ActorOrderByRelevanceFieldEnum = (typeof ActorOrderByRelevanceFieldEnum)[keyof typeof ActorOrderByRelevanceFieldEnum]


  export const MusicalOrderByRelevanceFieldEnum: {
    name: 'name',
    poster: 'poster'
  };

  export type MusicalOrderByRelevanceFieldEnum = (typeof MusicalOrderByRelevanceFieldEnum)[keyof typeof MusicalOrderByRelevanceFieldEnum]


  export const TheaterOrderByRelevanceFieldEnum: {
    name: 'name',
    roadAddress: 'roadAddress'
  };

  export type TheaterOrderByRelevanceFieldEnum = (typeof TheaterOrderByRelevanceFieldEnum)[keyof typeof TheaterOrderByRelevanceFieldEnum]


  export const SeatOrderByRelevanceFieldEnum: {
    field: 'field',
    field2: 'field2',
    field3: 'field3',
    floor: 'floor'
  };

  export type SeatOrderByRelevanceFieldEnum = (typeof SeatOrderByRelevanceFieldEnum)[keyof typeof SeatOrderByRelevanceFieldEnum]


  export const CommunityOrderByRelevanceFieldEnum: {
    name: 'name',
    type: 'type',
    description: 'description'
  };

  export type CommunityOrderByRelevanceFieldEnum = (typeof CommunityOrderByRelevanceFieldEnum)[keyof typeof CommunityOrderByRelevanceFieldEnum]


  export const TagOrderByRelevanceFieldEnum: {
    name: 'name',
    type: 'type'
  };

  export type TagOrderByRelevanceFieldEnum = (typeof TagOrderByRelevanceFieldEnum)[keyof typeof TagOrderByRelevanceFieldEnum]


  export const ImageOrderByRelevanceFieldEnum: {
    url: 'url',
    caption: 'caption'
  };

  export type ImageOrderByRelevanceFieldEnum = (typeof ImageOrderByRelevanceFieldEnum)[keyof typeof ImageOrderByRelevanceFieldEnum]


  export const ViewingRecordOrderByRelevanceFieldEnum: {
    seat: 'seat'
  };

  export type ViewingRecordOrderByRelevanceFieldEnum = (typeof ViewingRecordOrderByRelevanceFieldEnum)[keyof typeof ViewingRecordOrderByRelevanceFieldEnum]


  export const QuestionOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content'
  };

  export type QuestionOrderByRelevanceFieldEnum = (typeof QuestionOrderByRelevanceFieldEnum)[keyof typeof QuestionOrderByRelevanceFieldEnum]


  export const AnswerOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type AnswerOrderByRelevanceFieldEnum = (typeof AnswerOrderByRelevanceFieldEnum)[keyof typeof AnswerOrderByRelevanceFieldEnum]


  export const RegionOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type RegionOrderByRelevanceFieldEnum = (typeof RegionOrderByRelevanceFieldEnum)[keyof typeof RegionOrderByRelevanceFieldEnum]


  export const CastingOrderByRelevanceFieldEnum: {
    role: 'role'
  };

  export type CastingOrderByRelevanceFieldEnum = (typeof CastingOrderByRelevanceFieldEnum)[keyof typeof CastingOrderByRelevanceFieldEnum]


  export const MultiProfileOrderByRelevanceFieldEnum: {
    nickname: 'nickname',
    image: 'image',
    bio: 'bio'
  };

  export type MultiProfileOrderByRelevanceFieldEnum = (typeof MultiProfileOrderByRelevanceFieldEnum)[keyof typeof MultiProfileOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ImageOrVideo'
   */
  export type EnumImageOrVideoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageOrVideo'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    loginId?: StringFilter<"User"> | string
    settingId?: IntFilter<"User"> | number
    username?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    nickname?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    bio?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    isSubscribed?: BoolNullableFilter<"User"> | boolean | null
    setting?: XOR<SettingScalarRelationFilter, SettingWhereInput>
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    reviews?: ReviewListRelationFilter
    postLikes?: PostLikeListRelationFilter
    questions?: QuestionListRelationFilter
    answers?: AnswerListRelationFilter
    subscriptions?: SubscribeListRelationFilter
    viewings?: ViewingRecordListRelationFilter
    follows?: FollowListRelationFilter
    followers?: FollowListRelationFilter
    multiProfiles?: MultiProfileListRelationFilter
    userCommunities?: UserCommunityListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    loginId?: SortOrder
    settingId?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    email?: SortOrder
    nickname?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    isSubscribed?: SortOrderInput | SortOrder
    setting?: SettingOrderByWithRelationInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    postLikes?: PostLikeOrderByRelationAggregateInput
    questions?: QuestionOrderByRelationAggregateInput
    answers?: AnswerOrderByRelationAggregateInput
    subscriptions?: SubscribeOrderByRelationAggregateInput
    viewings?: ViewingRecordOrderByRelationAggregateInput
    follows?: FollowOrderByRelationAggregateInput
    followers?: FollowOrderByRelationAggregateInput
    multiProfiles?: MultiProfileOrderByRelationAggregateInput
    userCommunities?: UserCommunityOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    loginId?: string
    settingId?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    nickname?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    bio?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    isSubscribed?: BoolNullableFilter<"User"> | boolean | null
    setting?: XOR<SettingScalarRelationFilter, SettingWhereInput>
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    reviews?: ReviewListRelationFilter
    postLikes?: PostLikeListRelationFilter
    questions?: QuestionListRelationFilter
    answers?: AnswerListRelationFilter
    subscriptions?: SubscribeListRelationFilter
    viewings?: ViewingRecordListRelationFilter
    follows?: FollowListRelationFilter
    followers?: FollowListRelationFilter
    multiProfiles?: MultiProfileListRelationFilter
    userCommunities?: UserCommunityListRelationFilter
  }, "id" | "loginId" | "settingId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    loginId?: SortOrder
    settingId?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    email?: SortOrder
    nickname?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    isSubscribed?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    loginId?: StringWithAggregatesFilter<"User"> | string
    settingId?: IntWithAggregatesFilter<"User"> | number
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    nickname?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isSubscribed?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    userId?: IntFilter<"Post"> | number
    settingId?: IntFilter<"Post"> | number
    communityId?: IntFilter<"Post"> | number
    title?: StringNullableFilter<"Post"> | string | null
    content?: StringNullableFilter<"Post"> | string | null
    category?: StringNullableFilter<"Post"> | string | null
    like?: StringNullableFilter<"Post"> | string | null
    likeCount?: IntNullableFilter<"Post"> | number | null
    commentCount?: IntNullableFilter<"Post"> | number | null
    createdAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    repost?: IntNullableFilter<"Post"> | number | null
    bookmark?: IntNullableFilter<"Post"> | number | null
    communityGroup?: StringNullableFilter<"Post"> | string | null
    viewCount?: IntNullableFilter<"Post"> | number | null
    tag?: StringNullableFilter<"Post"> | string | null
    mediaType?: EnumImageOrVideoNullableFilter<"Post"> | $Enums.ImageOrVideo | null
    isPinned?: BoolNullableFilter<"Post"> | boolean | null
    tabCategory?: EnumCategoryNullableFilter<"Post"> | $Enums.Category | null
    isShared?: BoolNullableFilter<"Post"> | boolean | null
    musicalId?: IntNullableFilter<"Post"> | number | null
    actorId?: IntNullableFilter<"Post"> | number | null
    extraField?: StringNullableFilter<"Post"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    actor?: XOR<ActorNullableScalarRelationFilter, ActorWhereInput> | null
    setting?: XOR<SettingScalarRelationFilter, SettingWhereInput>
    comments?: CommentListRelationFilter
    postLikes?: PostLikeListRelationFilter
    images?: ImageListRelationFilter
    reviews?: ReviewListRelationFilter
    tags?: TagListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    like?: SortOrderInput | SortOrder
    likeCount?: SortOrderInput | SortOrder
    commentCount?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    repost?: SortOrderInput | SortOrder
    bookmark?: SortOrderInput | SortOrder
    communityGroup?: SortOrderInput | SortOrder
    viewCount?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    isPinned?: SortOrderInput | SortOrder
    tabCategory?: SortOrderInput | SortOrder
    isShared?: SortOrderInput | SortOrder
    musicalId?: SortOrderInput | SortOrder
    actorId?: SortOrderInput | SortOrder
    extraField?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    actor?: ActorOrderByWithRelationInput
    setting?: SettingOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    postLikes?: PostLikeOrderByRelationAggregateInput
    images?: ImageOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    _relevance?: PostOrderByRelevanceInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    userId?: IntFilter<"Post"> | number
    settingId?: IntFilter<"Post"> | number
    communityId?: IntFilter<"Post"> | number
    title?: StringNullableFilter<"Post"> | string | null
    content?: StringNullableFilter<"Post"> | string | null
    category?: StringNullableFilter<"Post"> | string | null
    like?: StringNullableFilter<"Post"> | string | null
    likeCount?: IntNullableFilter<"Post"> | number | null
    commentCount?: IntNullableFilter<"Post"> | number | null
    createdAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    repost?: IntNullableFilter<"Post"> | number | null
    bookmark?: IntNullableFilter<"Post"> | number | null
    communityGroup?: StringNullableFilter<"Post"> | string | null
    viewCount?: IntNullableFilter<"Post"> | number | null
    tag?: StringNullableFilter<"Post"> | string | null
    mediaType?: EnumImageOrVideoNullableFilter<"Post"> | $Enums.ImageOrVideo | null
    isPinned?: BoolNullableFilter<"Post"> | boolean | null
    tabCategory?: EnumCategoryNullableFilter<"Post"> | $Enums.Category | null
    isShared?: BoolNullableFilter<"Post"> | boolean | null
    musicalId?: IntNullableFilter<"Post"> | number | null
    actorId?: IntNullableFilter<"Post"> | number | null
    extraField?: StringNullableFilter<"Post"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    actor?: XOR<ActorNullableScalarRelationFilter, ActorWhereInput> | null
    setting?: XOR<SettingScalarRelationFilter, SettingWhereInput>
    comments?: CommentListRelationFilter
    postLikes?: PostLikeListRelationFilter
    images?: ImageListRelationFilter
    reviews?: ReviewListRelationFilter
    tags?: TagListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    like?: SortOrderInput | SortOrder
    likeCount?: SortOrderInput | SortOrder
    commentCount?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    repost?: SortOrderInput | SortOrder
    bookmark?: SortOrderInput | SortOrder
    communityGroup?: SortOrderInput | SortOrder
    viewCount?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    isPinned?: SortOrderInput | SortOrder
    tabCategory?: SortOrderInput | SortOrder
    isShared?: SortOrderInput | SortOrder
    musicalId?: SortOrderInput | SortOrder
    actorId?: SortOrderInput | SortOrder
    extraField?: SortOrderInput | SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    userId?: IntWithAggregatesFilter<"Post"> | number
    settingId?: IntWithAggregatesFilter<"Post"> | number
    communityId?: IntWithAggregatesFilter<"Post"> | number
    title?: StringNullableWithAggregatesFilter<"Post"> | string | null
    content?: StringNullableWithAggregatesFilter<"Post"> | string | null
    category?: StringNullableWithAggregatesFilter<"Post"> | string | null
    like?: StringNullableWithAggregatesFilter<"Post"> | string | null
    likeCount?: IntNullableWithAggregatesFilter<"Post"> | number | null
    commentCount?: IntNullableWithAggregatesFilter<"Post"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    repost?: IntNullableWithAggregatesFilter<"Post"> | number | null
    bookmark?: IntNullableWithAggregatesFilter<"Post"> | number | null
    communityGroup?: StringNullableWithAggregatesFilter<"Post"> | string | null
    viewCount?: IntNullableWithAggregatesFilter<"Post"> | number | null
    tag?: StringNullableWithAggregatesFilter<"Post"> | string | null
    mediaType?: EnumImageOrVideoNullableWithAggregatesFilter<"Post"> | $Enums.ImageOrVideo | null
    isPinned?: BoolNullableWithAggregatesFilter<"Post"> | boolean | null
    tabCategory?: EnumCategoryNullableWithAggregatesFilter<"Post"> | $Enums.Category | null
    isShared?: BoolNullableWithAggregatesFilter<"Post"> | boolean | null
    musicalId?: IntNullableWithAggregatesFilter<"Post"> | number | null
    actorId?: IntNullableWithAggregatesFilter<"Post"> | number | null
    extraField?: StringNullableWithAggregatesFilter<"Post"> | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    settingId?: IntFilter<"Comment"> | number
    communityId?: IntFilter<"Comment"> | number
    content?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    anonymous?: BoolNullableFilter<"Comment"> | boolean | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    anonymous?: SortOrderInput | SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: CommentOrderByRelevanceInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    settingId?: IntFilter<"Comment"> | number
    communityId?: IntFilter<"Comment"> | number
    content?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    anonymous?: BoolNullableFilter<"Comment"> | boolean | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    anonymous?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    postId?: IntWithAggregatesFilter<"Comment"> | number
    userId?: IntWithAggregatesFilter<"Comment"> | number
    settingId?: IntWithAggregatesFilter<"Comment"> | number
    communityId?: IntWithAggregatesFilter<"Comment"> | number
    content?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Comment"> | Date | string | null
    anonymous?: BoolNullableWithAggregatesFilter<"Comment"> | boolean | null
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    settingId?: IntFilter<"Review"> | number
    theaterId?: IntFilter<"Review"> | number
    key?: IntFilter<"Review"> | number
    postId?: IntNullableFilter<"Review"> | number | null
    content?: StringNullableFilter<"Review"> | string | null
    rating?: IntNullableFilter<"Review"> | number | null
    spoiler?: BoolNullableFilter<"Review"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    liked?: StringNullableFilter<"Review"> | string | null
    likeCount?: IntNullableFilter<"Review"> | number | null
    comment?: StringNullableFilter<"Review"> | string | null
    imageUrl?: StringNullableFilter<"Review"> | string | null
    reported?: BoolNullableFilter<"Review"> | boolean | null
    watchDate?: DateTimeNullableFilter<"Review"> | Date | string | null
    watchTime?: DateTimeNullableFilter<"Review"> | Date | string | null
    extraField2?: StringNullableFilter<"Review"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    theaterId?: SortOrder
    key?: SortOrder
    postId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    spoiler?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    liked?: SortOrderInput | SortOrder
    likeCount?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    reported?: SortOrderInput | SortOrder
    watchDate?: SortOrderInput | SortOrder
    watchTime?: SortOrderInput | SortOrder
    extraField2?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
    _relevance?: ReviewOrderByRelevanceInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: IntFilter<"Review"> | number
    settingId?: IntFilter<"Review"> | number
    theaterId?: IntFilter<"Review"> | number
    key?: IntFilter<"Review"> | number
    postId?: IntNullableFilter<"Review"> | number | null
    content?: StringNullableFilter<"Review"> | string | null
    rating?: IntNullableFilter<"Review"> | number | null
    spoiler?: BoolNullableFilter<"Review"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    liked?: StringNullableFilter<"Review"> | string | null
    likeCount?: IntNullableFilter<"Review"> | number | null
    comment?: StringNullableFilter<"Review"> | string | null
    imageUrl?: StringNullableFilter<"Review"> | string | null
    reported?: BoolNullableFilter<"Review"> | boolean | null
    watchDate?: DateTimeNullableFilter<"Review"> | Date | string | null
    watchTime?: DateTimeNullableFilter<"Review"> | Date | string | null
    extraField2?: StringNullableFilter<"Review"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    theaterId?: SortOrder
    key?: SortOrder
    postId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    spoiler?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    liked?: SortOrderInput | SortOrder
    likeCount?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    reported?: SortOrderInput | SortOrder
    watchDate?: SortOrderInput | SortOrder
    watchTime?: SortOrderInput | SortOrder
    extraField2?: SortOrderInput | SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Review"> | number
    userId?: IntWithAggregatesFilter<"Review"> | number
    settingId?: IntWithAggregatesFilter<"Review"> | number
    theaterId?: IntWithAggregatesFilter<"Review"> | number
    key?: IntWithAggregatesFilter<"Review"> | number
    postId?: IntNullableWithAggregatesFilter<"Review"> | number | null
    content?: StringNullableWithAggregatesFilter<"Review"> | string | null
    rating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    spoiler?: BoolNullableWithAggregatesFilter<"Review"> | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
    liked?: StringNullableWithAggregatesFilter<"Review"> | string | null
    likeCount?: IntNullableWithAggregatesFilter<"Review"> | number | null
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Review"> | string | null
    reported?: BoolNullableWithAggregatesFilter<"Review"> | boolean | null
    watchDate?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
    watchTime?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
    extraField2?: StringNullableWithAggregatesFilter<"Review"> | string | null
  }

  export type ActorWhereInput = {
    AND?: ActorWhereInput | ActorWhereInput[]
    OR?: ActorWhereInput[]
    NOT?: ActorWhereInput | ActorWhereInput[]
    id?: IntFilter<"Actor"> | number
    postId?: IntFilter<"Actor"> | number
    userId?: IntFilter<"Actor"> | number
    settingId?: IntFilter<"Actor"> | number
    communityId?: IntFilter<"Actor"> | number
    key?: IntFilter<"Actor"> | number
    name?: StringNullableFilter<"Actor"> | string | null
    image?: StringNullableFilter<"Actor"> | string | null
    profile?: StringNullableFilter<"Actor"> | string | null
    snsLink?: StringNullableFilter<"Actor"> | string | null
    fk?: IntNullableFilter<"Actor"> | number | null
    posts?: PostListRelationFilter
    castings?: CastingListRelationFilter
  }

  export type ActorOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    key?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    profile?: SortOrderInput | SortOrder
    snsLink?: SortOrderInput | SortOrder
    fk?: SortOrderInput | SortOrder
    posts?: PostOrderByRelationAggregateInput
    castings?: CastingOrderByRelationAggregateInput
    _relevance?: ActorOrderByRelevanceInput
  }

  export type ActorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActorWhereInput | ActorWhereInput[]
    OR?: ActorWhereInput[]
    NOT?: ActorWhereInput | ActorWhereInput[]
    postId?: IntFilter<"Actor"> | number
    userId?: IntFilter<"Actor"> | number
    settingId?: IntFilter<"Actor"> | number
    communityId?: IntFilter<"Actor"> | number
    key?: IntFilter<"Actor"> | number
    name?: StringNullableFilter<"Actor"> | string | null
    image?: StringNullableFilter<"Actor"> | string | null
    profile?: StringNullableFilter<"Actor"> | string | null
    snsLink?: StringNullableFilter<"Actor"> | string | null
    fk?: IntNullableFilter<"Actor"> | number | null
    posts?: PostListRelationFilter
    castings?: CastingListRelationFilter
  }, "id">

  export type ActorOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    key?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    profile?: SortOrderInput | SortOrder
    snsLink?: SortOrderInput | SortOrder
    fk?: SortOrderInput | SortOrder
    _count?: ActorCountOrderByAggregateInput
    _avg?: ActorAvgOrderByAggregateInput
    _max?: ActorMaxOrderByAggregateInput
    _min?: ActorMinOrderByAggregateInput
    _sum?: ActorSumOrderByAggregateInput
  }

  export type ActorScalarWhereWithAggregatesInput = {
    AND?: ActorScalarWhereWithAggregatesInput | ActorScalarWhereWithAggregatesInput[]
    OR?: ActorScalarWhereWithAggregatesInput[]
    NOT?: ActorScalarWhereWithAggregatesInput | ActorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Actor"> | number
    postId?: IntWithAggregatesFilter<"Actor"> | number
    userId?: IntWithAggregatesFilter<"Actor"> | number
    settingId?: IntWithAggregatesFilter<"Actor"> | number
    communityId?: IntWithAggregatesFilter<"Actor"> | number
    key?: IntWithAggregatesFilter<"Actor"> | number
    name?: StringNullableWithAggregatesFilter<"Actor"> | string | null
    image?: StringNullableWithAggregatesFilter<"Actor"> | string | null
    profile?: StringNullableWithAggregatesFilter<"Actor"> | string | null
    snsLink?: StringNullableWithAggregatesFilter<"Actor"> | string | null
    fk?: IntNullableWithAggregatesFilter<"Actor"> | number | null
  }

  export type MusicalWhereInput = {
    AND?: MusicalWhereInput | MusicalWhereInput[]
    OR?: MusicalWhereInput[]
    NOT?: MusicalWhereInput | MusicalWhereInput[]
    id?: IntFilter<"Musical"> | number
    theaterId?: IntFilter<"Musical"> | number
    name?: StringNullableFilter<"Musical"> | string | null
    startDate?: DateTimeNullableFilter<"Musical"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Musical"> | Date | string | null
    poster?: StringNullableFilter<"Musical"> | string | null
    createdAt?: DateTimeNullableFilter<"Musical"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Musical"> | Date | string | null
    theater?: XOR<TheaterScalarRelationFilter, TheaterWhereInput>
    castings?: CastingListRelationFilter
    viewings?: ViewingRecordListRelationFilter
    communities?: MusicalCommunityListRelationFilter
  }

  export type MusicalOrderByWithRelationInput = {
    id?: SortOrder
    theaterId?: SortOrder
    name?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    poster?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    theater?: TheaterOrderByWithRelationInput
    castings?: CastingOrderByRelationAggregateInput
    viewings?: ViewingRecordOrderByRelationAggregateInput
    communities?: MusicalCommunityOrderByRelationAggregateInput
    _relevance?: MusicalOrderByRelevanceInput
  }

  export type MusicalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MusicalWhereInput | MusicalWhereInput[]
    OR?: MusicalWhereInput[]
    NOT?: MusicalWhereInput | MusicalWhereInput[]
    theaterId?: IntFilter<"Musical"> | number
    name?: StringNullableFilter<"Musical"> | string | null
    startDate?: DateTimeNullableFilter<"Musical"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Musical"> | Date | string | null
    poster?: StringNullableFilter<"Musical"> | string | null
    createdAt?: DateTimeNullableFilter<"Musical"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Musical"> | Date | string | null
    theater?: XOR<TheaterScalarRelationFilter, TheaterWhereInput>
    castings?: CastingListRelationFilter
    viewings?: ViewingRecordListRelationFilter
    communities?: MusicalCommunityListRelationFilter
  }, "id">

  export type MusicalOrderByWithAggregationInput = {
    id?: SortOrder
    theaterId?: SortOrder
    name?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    poster?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MusicalCountOrderByAggregateInput
    _avg?: MusicalAvgOrderByAggregateInput
    _max?: MusicalMaxOrderByAggregateInput
    _min?: MusicalMinOrderByAggregateInput
    _sum?: MusicalSumOrderByAggregateInput
  }

  export type MusicalScalarWhereWithAggregatesInput = {
    AND?: MusicalScalarWhereWithAggregatesInput | MusicalScalarWhereWithAggregatesInput[]
    OR?: MusicalScalarWhereWithAggregatesInput[]
    NOT?: MusicalScalarWhereWithAggregatesInput | MusicalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Musical"> | number
    theaterId?: IntWithAggregatesFilter<"Musical"> | number
    name?: StringNullableWithAggregatesFilter<"Musical"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Musical"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Musical"> | Date | string | null
    poster?: StringNullableWithAggregatesFilter<"Musical"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Musical"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Musical"> | Date | string | null
  }

  export type TheaterWhereInput = {
    AND?: TheaterWhereInput | TheaterWhereInput[]
    OR?: TheaterWhereInput[]
    NOT?: TheaterWhereInput | TheaterWhereInput[]
    id?: IntFilter<"Theater"> | number
    regionId?: IntFilter<"Theater"> | number
    name?: StringNullableFilter<"Theater"> | string | null
    seatCount?: IntNullableFilter<"Theater"> | number | null
    roadAddress?: StringNullableFilter<"Theater"> | string | null
    createdAt?: DateTimeNullableFilter<"Theater"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Theater"> | Date | string | null
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    musicals?: MusicalListRelationFilter
    seats?: SeatListRelationFilter
  }

  export type TheaterOrderByWithRelationInput = {
    id?: SortOrder
    regionId?: SortOrder
    name?: SortOrderInput | SortOrder
    seatCount?: SortOrderInput | SortOrder
    roadAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    region?: RegionOrderByWithRelationInput
    musicals?: MusicalOrderByRelationAggregateInput
    seats?: SeatOrderByRelationAggregateInput
    _relevance?: TheaterOrderByRelevanceInput
  }

  export type TheaterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TheaterWhereInput | TheaterWhereInput[]
    OR?: TheaterWhereInput[]
    NOT?: TheaterWhereInput | TheaterWhereInput[]
    regionId?: IntFilter<"Theater"> | number
    name?: StringNullableFilter<"Theater"> | string | null
    seatCount?: IntNullableFilter<"Theater"> | number | null
    roadAddress?: StringNullableFilter<"Theater"> | string | null
    createdAt?: DateTimeNullableFilter<"Theater"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Theater"> | Date | string | null
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    musicals?: MusicalListRelationFilter
    seats?: SeatListRelationFilter
  }, "id">

  export type TheaterOrderByWithAggregationInput = {
    id?: SortOrder
    regionId?: SortOrder
    name?: SortOrderInput | SortOrder
    seatCount?: SortOrderInput | SortOrder
    roadAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: TheaterCountOrderByAggregateInput
    _avg?: TheaterAvgOrderByAggregateInput
    _max?: TheaterMaxOrderByAggregateInput
    _min?: TheaterMinOrderByAggregateInput
    _sum?: TheaterSumOrderByAggregateInput
  }

  export type TheaterScalarWhereWithAggregatesInput = {
    AND?: TheaterScalarWhereWithAggregatesInput | TheaterScalarWhereWithAggregatesInput[]
    OR?: TheaterScalarWhereWithAggregatesInput[]
    NOT?: TheaterScalarWhereWithAggregatesInput | TheaterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Theater"> | number
    regionId?: IntWithAggregatesFilter<"Theater"> | number
    name?: StringNullableWithAggregatesFilter<"Theater"> | string | null
    seatCount?: IntNullableWithAggregatesFilter<"Theater"> | number | null
    roadAddress?: StringNullableWithAggregatesFilter<"Theater"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Theater"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Theater"> | Date | string | null
  }

  export type SeatWhereInput = {
    AND?: SeatWhereInput | SeatWhereInput[]
    OR?: SeatWhereInput[]
    NOT?: SeatWhereInput | SeatWhereInput[]
    id?: IntFilter<"Seat"> | number
    theaterId?: IntFilter<"Seat"> | number
    locationId?: IntFilter<"Seat"> | number
    field?: StringNullableFilter<"Seat"> | string | null
    field2?: StringNullableFilter<"Seat"> | string | null
    field3?: StringNullableFilter<"Seat"> | string | null
    floor?: StringNullableFilter<"Seat"> | string | null
    theater?: XOR<TheaterScalarRelationFilter, TheaterWhereInput>
  }

  export type SeatOrderByWithRelationInput = {
    id?: SortOrder
    theaterId?: SortOrder
    locationId?: SortOrder
    field?: SortOrderInput | SortOrder
    field2?: SortOrderInput | SortOrder
    field3?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    theater?: TheaterOrderByWithRelationInput
    _relevance?: SeatOrderByRelevanceInput
  }

  export type SeatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeatWhereInput | SeatWhereInput[]
    OR?: SeatWhereInput[]
    NOT?: SeatWhereInput | SeatWhereInput[]
    theaterId?: IntFilter<"Seat"> | number
    locationId?: IntFilter<"Seat"> | number
    field?: StringNullableFilter<"Seat"> | string | null
    field2?: StringNullableFilter<"Seat"> | string | null
    field3?: StringNullableFilter<"Seat"> | string | null
    floor?: StringNullableFilter<"Seat"> | string | null
    theater?: XOR<TheaterScalarRelationFilter, TheaterWhereInput>
  }, "id">

  export type SeatOrderByWithAggregationInput = {
    id?: SortOrder
    theaterId?: SortOrder
    locationId?: SortOrder
    field?: SortOrderInput | SortOrder
    field2?: SortOrderInput | SortOrder
    field3?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    _count?: SeatCountOrderByAggregateInput
    _avg?: SeatAvgOrderByAggregateInput
    _max?: SeatMaxOrderByAggregateInput
    _min?: SeatMinOrderByAggregateInput
    _sum?: SeatSumOrderByAggregateInput
  }

  export type SeatScalarWhereWithAggregatesInput = {
    AND?: SeatScalarWhereWithAggregatesInput | SeatScalarWhereWithAggregatesInput[]
    OR?: SeatScalarWhereWithAggregatesInput[]
    NOT?: SeatScalarWhereWithAggregatesInput | SeatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Seat"> | number
    theaterId?: IntWithAggregatesFilter<"Seat"> | number
    locationId?: IntWithAggregatesFilter<"Seat"> | number
    field?: StringNullableWithAggregatesFilter<"Seat"> | string | null
    field2?: StringNullableWithAggregatesFilter<"Seat"> | string | null
    field3?: StringNullableWithAggregatesFilter<"Seat"> | string | null
    floor?: StringNullableWithAggregatesFilter<"Seat"> | string | null
  }

  export type CommunityWhereInput = {
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    id?: IntFilter<"Community"> | number
    createdAt?: DateTimeNullableFilter<"Community"> | Date | string | null
    name?: StringNullableFilter<"Community"> | string | null
    type?: StringNullableFilter<"Community"> | string | null
    description?: StringNullableFilter<"Community"> | string | null
    userCommunities?: UserCommunityListRelationFilter
    musicalCommunities?: MusicalCommunityListRelationFilter
  }

  export type CommunityOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    userCommunities?: UserCommunityOrderByRelationAggregateInput
    musicalCommunities?: MusicalCommunityOrderByRelationAggregateInput
    _relevance?: CommunityOrderByRelevanceInput
  }

  export type CommunityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    createdAt?: DateTimeNullableFilter<"Community"> | Date | string | null
    name?: StringNullableFilter<"Community"> | string | null
    type?: StringNullableFilter<"Community"> | string | null
    description?: StringNullableFilter<"Community"> | string | null
    userCommunities?: UserCommunityListRelationFilter
    musicalCommunities?: MusicalCommunityListRelationFilter
  }, "id">

  export type CommunityOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: CommunityCountOrderByAggregateInput
    _avg?: CommunityAvgOrderByAggregateInput
    _max?: CommunityMaxOrderByAggregateInput
    _min?: CommunityMinOrderByAggregateInput
    _sum?: CommunitySumOrderByAggregateInput
  }

  export type CommunityScalarWhereWithAggregatesInput = {
    AND?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    OR?: CommunityScalarWhereWithAggregatesInput[]
    NOT?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Community"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"Community"> | Date | string | null
    name?: StringNullableWithAggregatesFilter<"Community"> | string | null
    type?: StringNullableWithAggregatesFilter<"Community"> | string | null
    description?: StringNullableWithAggregatesFilter<"Community"> | string | null
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: IntFilter<"Setting"> | number
    useBackground?: BoolNullableFilter<"Setting"> | boolean | null
    useProfilePhoto?: BoolNullableFilter<"Setting"> | boolean | null
    allowRepost?: BoolNullableFilter<"Setting"> | boolean | null
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    posts?: PostListRelationFilter
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    useBackground?: SortOrderInput | SortOrder
    useProfilePhoto?: SortOrderInput | SortOrder
    allowRepost?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
    posts?: PostOrderByRelationAggregateInput
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    useBackground?: BoolNullableFilter<"Setting"> | boolean | null
    useProfilePhoto?: BoolNullableFilter<"Setting"> | boolean | null
    allowRepost?: BoolNullableFilter<"Setting"> | boolean | null
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    posts?: PostListRelationFilter
  }, "id">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    useBackground?: SortOrderInput | SortOrder
    useProfilePhoto?: SortOrderInput | SortOrder
    allowRepost?: SortOrderInput | SortOrder
    _count?: SettingCountOrderByAggregateInput
    _avg?: SettingAvgOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
    _sum?: SettingSumOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Setting"> | number
    useBackground?: BoolNullableWithAggregatesFilter<"Setting"> | boolean | null
    useProfilePhoto?: BoolNullableWithAggregatesFilter<"Setting"> | boolean | null
    allowRepost?: BoolNullableWithAggregatesFilter<"Setting"> | boolean | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    type?: StringNullableFilter<"Tag"> | string | null
    posts?: PostListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    posts?: PostOrderByRelationAggregateInput
    _relevance?: TagOrderByRelevanceInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    type?: StringNullableFilter<"Tag"> | string | null
    posts?: PostListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    name?: StringWithAggregatesFilter<"Tag"> | string
    type?: StringNullableWithAggregatesFilter<"Tag"> | string | null
  }

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    id?: IntFilter<"Image"> | number
    postId?: IntFilter<"Image"> | number
    url?: StringNullableFilter<"Image"> | string | null
    caption?: StringNullableFilter<"Image"> | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    post?: PostOrderByWithRelationInput
    _relevance?: ImageOrderByRelevanceInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    postId?: IntFilter<"Image"> | number
    url?: StringNullableFilter<"Image"> | string | null
    caption?: StringNullableFilter<"Image"> | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id">

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    _count?: ImageCountOrderByAggregateInput
    _avg?: ImageAvgOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
    _sum?: ImageSumOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Image"> | number
    postId?: IntWithAggregatesFilter<"Image"> | number
    url?: StringNullableWithAggregatesFilter<"Image"> | string | null
    caption?: StringNullableWithAggregatesFilter<"Image"> | string | null
  }

  export type SubscribeWhereInput = {
    AND?: SubscribeWhereInput | SubscribeWhereInput[]
    OR?: SubscribeWhereInput[]
    NOT?: SubscribeWhereInput | SubscribeWhereInput[]
    id?: IntFilter<"Subscribe"> | number
    userId?: IntFilter<"Subscribe"> | number
    startDate?: DateTimeNullableFilter<"Subscribe"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Subscribe"> | Date | string | null
    isActive?: BoolNullableFilter<"Subscribe"> | boolean | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SubscribeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubscribeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubscribeWhereInput | SubscribeWhereInput[]
    OR?: SubscribeWhereInput[]
    NOT?: SubscribeWhereInput | SubscribeWhereInput[]
    userId?: IntFilter<"Subscribe"> | number
    startDate?: DateTimeNullableFilter<"Subscribe"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Subscribe"> | Date | string | null
    isActive?: BoolNullableFilter<"Subscribe"> | boolean | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SubscribeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    _count?: SubscribeCountOrderByAggregateInput
    _avg?: SubscribeAvgOrderByAggregateInput
    _max?: SubscribeMaxOrderByAggregateInput
    _min?: SubscribeMinOrderByAggregateInput
    _sum?: SubscribeSumOrderByAggregateInput
  }

  export type SubscribeScalarWhereWithAggregatesInput = {
    AND?: SubscribeScalarWhereWithAggregatesInput | SubscribeScalarWhereWithAggregatesInput[]
    OR?: SubscribeScalarWhereWithAggregatesInput[]
    NOT?: SubscribeScalarWhereWithAggregatesInput | SubscribeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subscribe"> | number
    userId?: IntWithAggregatesFilter<"Subscribe"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"Subscribe"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Subscribe"> | Date | string | null
    isActive?: BoolNullableWithAggregatesFilter<"Subscribe"> | boolean | null
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: IntFilter<"Follow"> | number
    followerId?: IntFilter<"Follow"> | number
    followingId?: IntFilter<"Follow"> | number
    createdAt?: DateTimeNullableFilter<"Follow"> | Date | string | null
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: IntFilter<"Follow"> | number
    followingId?: IntFilter<"Follow"> | number
    createdAt?: DateTimeNullableFilter<"Follow"> | Date | string | null
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: FollowCountOrderByAggregateInput
    _avg?: FollowAvgOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
    _sum?: FollowSumOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Follow"> | number
    followerId?: IntWithAggregatesFilter<"Follow"> | number
    followingId?: IntWithAggregatesFilter<"Follow"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"Follow"> | Date | string | null
  }

  export type ViewingRecordWhereInput = {
    AND?: ViewingRecordWhereInput | ViewingRecordWhereInput[]
    OR?: ViewingRecordWhereInput[]
    NOT?: ViewingRecordWhereInput | ViewingRecordWhereInput[]
    id?: IntFilter<"ViewingRecord"> | number
    userId?: IntFilter<"ViewingRecord"> | number
    musicalId?: IntFilter<"ViewingRecord"> | number
    date?: DateTimeNullableFilter<"ViewingRecord"> | Date | string | null
    seat?: StringNullableFilter<"ViewingRecord"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    musical?: XOR<MusicalScalarRelationFilter, MusicalWhereInput>
  }

  export type ViewingRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    musicalId?: SortOrder
    date?: SortOrderInput | SortOrder
    seat?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    musical?: MusicalOrderByWithRelationInput
    _relevance?: ViewingRecordOrderByRelevanceInput
  }

  export type ViewingRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ViewingRecordWhereInput | ViewingRecordWhereInput[]
    OR?: ViewingRecordWhereInput[]
    NOT?: ViewingRecordWhereInput | ViewingRecordWhereInput[]
    userId?: IntFilter<"ViewingRecord"> | number
    musicalId?: IntFilter<"ViewingRecord"> | number
    date?: DateTimeNullableFilter<"ViewingRecord"> | Date | string | null
    seat?: StringNullableFilter<"ViewingRecord"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    musical?: XOR<MusicalScalarRelationFilter, MusicalWhereInput>
  }, "id">

  export type ViewingRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    musicalId?: SortOrder
    date?: SortOrderInput | SortOrder
    seat?: SortOrderInput | SortOrder
    _count?: ViewingRecordCountOrderByAggregateInput
    _avg?: ViewingRecordAvgOrderByAggregateInput
    _max?: ViewingRecordMaxOrderByAggregateInput
    _min?: ViewingRecordMinOrderByAggregateInput
    _sum?: ViewingRecordSumOrderByAggregateInput
  }

  export type ViewingRecordScalarWhereWithAggregatesInput = {
    AND?: ViewingRecordScalarWhereWithAggregatesInput | ViewingRecordScalarWhereWithAggregatesInput[]
    OR?: ViewingRecordScalarWhereWithAggregatesInput[]
    NOT?: ViewingRecordScalarWhereWithAggregatesInput | ViewingRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ViewingRecord"> | number
    userId?: IntWithAggregatesFilter<"ViewingRecord"> | number
    musicalId?: IntWithAggregatesFilter<"ViewingRecord"> | number
    date?: DateTimeNullableWithAggregatesFilter<"ViewingRecord"> | Date | string | null
    seat?: StringNullableWithAggregatesFilter<"ViewingRecord"> | string | null
  }

  export type PostLikeWhereInput = {
    AND?: PostLikeWhereInput | PostLikeWhereInput[]
    OR?: PostLikeWhereInput[]
    NOT?: PostLikeWhereInput | PostLikeWhereInput[]
    id?: IntFilter<"PostLike"> | number
    postId?: IntFilter<"PostLike"> | number
    userId?: IntFilter<"PostLike"> | number
    likedAt?: DateTimeNullableFilter<"PostLike"> | Date | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PostLikeOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    likedAt?: SortOrderInput | SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PostLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostLikeWhereInput | PostLikeWhereInput[]
    OR?: PostLikeWhereInput[]
    NOT?: PostLikeWhereInput | PostLikeWhereInput[]
    postId?: IntFilter<"PostLike"> | number
    userId?: IntFilter<"PostLike"> | number
    likedAt?: DateTimeNullableFilter<"PostLike"> | Date | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PostLikeOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    likedAt?: SortOrderInput | SortOrder
    _count?: PostLikeCountOrderByAggregateInput
    _avg?: PostLikeAvgOrderByAggregateInput
    _max?: PostLikeMaxOrderByAggregateInput
    _min?: PostLikeMinOrderByAggregateInput
    _sum?: PostLikeSumOrderByAggregateInput
  }

  export type PostLikeScalarWhereWithAggregatesInput = {
    AND?: PostLikeScalarWhereWithAggregatesInput | PostLikeScalarWhereWithAggregatesInput[]
    OR?: PostLikeScalarWhereWithAggregatesInput[]
    NOT?: PostLikeScalarWhereWithAggregatesInput | PostLikeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PostLike"> | number
    postId?: IntWithAggregatesFilter<"PostLike"> | number
    userId?: IntWithAggregatesFilter<"PostLike"> | number
    likedAt?: DateTimeNullableWithAggregatesFilter<"PostLike"> | Date | string | null
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: IntFilter<"Question"> | number
    userId?: IntFilter<"Question"> | number
    title?: StringFilter<"Question"> | string
    content?: StringFilter<"Question"> | string
    createdAt?: DateTimeNullableFilter<"Question"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    answers?: AnswerListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    answers?: AnswerOrderByRelationAggregateInput
    _relevance?: QuestionOrderByRelevanceInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    userId?: IntFilter<"Question"> | number
    title?: StringFilter<"Question"> | string
    content?: StringFilter<"Question"> | string
    createdAt?: DateTimeNullableFilter<"Question"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    answers?: AnswerListRelationFilter
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Question"> | number
    userId?: IntWithAggregatesFilter<"Question"> | number
    title?: StringWithAggregatesFilter<"Question"> | string
    content?: StringWithAggregatesFilter<"Question"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Question"> | Date | string | null
  }

  export type AnswerWhereInput = {
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    id?: IntFilter<"Answer"> | number
    questionId?: IntFilter<"Answer"> | number
    userId?: IntFilter<"Answer"> | number
    content?: StringFilter<"Answer"> | string
    createdAt?: DateTimeNullableFilter<"Answer"> | Date | string | null
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AnswerOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    question?: QuestionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: AnswerOrderByRelevanceInput
  }

  export type AnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    questionId?: IntFilter<"Answer"> | number
    userId?: IntFilter<"Answer"> | number
    content?: StringFilter<"Answer"> | string
    createdAt?: DateTimeNullableFilter<"Answer"> | Date | string | null
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AnswerOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: AnswerCountOrderByAggregateInput
    _avg?: AnswerAvgOrderByAggregateInput
    _max?: AnswerMaxOrderByAggregateInput
    _min?: AnswerMinOrderByAggregateInput
    _sum?: AnswerSumOrderByAggregateInput
  }

  export type AnswerScalarWhereWithAggregatesInput = {
    AND?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    OR?: AnswerScalarWhereWithAggregatesInput[]
    NOT?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Answer"> | number
    questionId?: IntWithAggregatesFilter<"Answer"> | number
    userId?: IntWithAggregatesFilter<"Answer"> | number
    content?: StringWithAggregatesFilter<"Answer"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Answer"> | Date | string | null
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: IntFilter<"Region"> | number
    name?: StringFilter<"Region"> | string
    theaters?: TheaterListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    theaters?: TheaterOrderByRelationAggregateInput
    _relevance?: RegionOrderByRelevanceInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    name?: StringFilter<"Region"> | string
    theaters?: TheaterListRelationFilter
  }, "id">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Region"> | number
    name?: StringWithAggregatesFilter<"Region"> | string
  }

  export type CastingWhereInput = {
    AND?: CastingWhereInput | CastingWhereInput[]
    OR?: CastingWhereInput[]
    NOT?: CastingWhereInput | CastingWhereInput[]
    id?: IntFilter<"Casting"> | number
    musicalId?: IntFilter<"Casting"> | number
    actorId?: IntFilter<"Casting"> | number
    role?: StringNullableFilter<"Casting"> | string | null
    musical?: XOR<MusicalScalarRelationFilter, MusicalWhereInput>
    actor?: XOR<ActorScalarRelationFilter, ActorWhereInput>
  }

  export type CastingOrderByWithRelationInput = {
    id?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
    role?: SortOrderInput | SortOrder
    musical?: MusicalOrderByWithRelationInput
    actor?: ActorOrderByWithRelationInput
    _relevance?: CastingOrderByRelevanceInput
  }

  export type CastingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CastingWhereInput | CastingWhereInput[]
    OR?: CastingWhereInput[]
    NOT?: CastingWhereInput | CastingWhereInput[]
    musicalId?: IntFilter<"Casting"> | number
    actorId?: IntFilter<"Casting"> | number
    role?: StringNullableFilter<"Casting"> | string | null
    musical?: XOR<MusicalScalarRelationFilter, MusicalWhereInput>
    actor?: XOR<ActorScalarRelationFilter, ActorWhereInput>
  }, "id">

  export type CastingOrderByWithAggregationInput = {
    id?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
    role?: SortOrderInput | SortOrder
    _count?: CastingCountOrderByAggregateInput
    _avg?: CastingAvgOrderByAggregateInput
    _max?: CastingMaxOrderByAggregateInput
    _min?: CastingMinOrderByAggregateInput
    _sum?: CastingSumOrderByAggregateInput
  }

  export type CastingScalarWhereWithAggregatesInput = {
    AND?: CastingScalarWhereWithAggregatesInput | CastingScalarWhereWithAggregatesInput[]
    OR?: CastingScalarWhereWithAggregatesInput[]
    NOT?: CastingScalarWhereWithAggregatesInput | CastingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Casting"> | number
    musicalId?: IntWithAggregatesFilter<"Casting"> | number
    actorId?: IntWithAggregatesFilter<"Casting"> | number
    role?: StringNullableWithAggregatesFilter<"Casting"> | string | null
  }

  export type UserCommunityWhereInput = {
    AND?: UserCommunityWhereInput | UserCommunityWhereInput[]
    OR?: UserCommunityWhereInput[]
    NOT?: UserCommunityWhereInput | UserCommunityWhereInput[]
    id?: IntFilter<"UserCommunity"> | number
    userId?: IntFilter<"UserCommunity"> | number
    communityId?: IntFilter<"UserCommunity"> | number
    joinedAt?: DateTimeNullableFilter<"UserCommunity"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
  }

  export type UserCommunityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    community?: CommunityOrderByWithRelationInput
  }

  export type UserCommunityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserCommunityWhereInput | UserCommunityWhereInput[]
    OR?: UserCommunityWhereInput[]
    NOT?: UserCommunityWhereInput | UserCommunityWhereInput[]
    userId?: IntFilter<"UserCommunity"> | number
    communityId?: IntFilter<"UserCommunity"> | number
    joinedAt?: DateTimeNullableFilter<"UserCommunity"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
  }, "id">

  export type UserCommunityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    _count?: UserCommunityCountOrderByAggregateInput
    _avg?: UserCommunityAvgOrderByAggregateInput
    _max?: UserCommunityMaxOrderByAggregateInput
    _min?: UserCommunityMinOrderByAggregateInput
    _sum?: UserCommunitySumOrderByAggregateInput
  }

  export type UserCommunityScalarWhereWithAggregatesInput = {
    AND?: UserCommunityScalarWhereWithAggregatesInput | UserCommunityScalarWhereWithAggregatesInput[]
    OR?: UserCommunityScalarWhereWithAggregatesInput[]
    NOT?: UserCommunityScalarWhereWithAggregatesInput | UserCommunityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserCommunity"> | number
    userId?: IntWithAggregatesFilter<"UserCommunity"> | number
    communityId?: IntWithAggregatesFilter<"UserCommunity"> | number
    joinedAt?: DateTimeNullableWithAggregatesFilter<"UserCommunity"> | Date | string | null
  }

  export type MusicalCommunityWhereInput = {
    AND?: MusicalCommunityWhereInput | MusicalCommunityWhereInput[]
    OR?: MusicalCommunityWhereInput[]
    NOT?: MusicalCommunityWhereInput | MusicalCommunityWhereInput[]
    id?: IntFilter<"MusicalCommunity"> | number
    musicalId?: IntFilter<"MusicalCommunity"> | number
    communityId?: IntFilter<"MusicalCommunity"> | number
    musical?: XOR<MusicalScalarRelationFilter, MusicalWhereInput>
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
  }

  export type MusicalCommunityOrderByWithRelationInput = {
    id?: SortOrder
    musicalId?: SortOrder
    communityId?: SortOrder
    musical?: MusicalOrderByWithRelationInput
    community?: CommunityOrderByWithRelationInput
  }

  export type MusicalCommunityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MusicalCommunityWhereInput | MusicalCommunityWhereInput[]
    OR?: MusicalCommunityWhereInput[]
    NOT?: MusicalCommunityWhereInput | MusicalCommunityWhereInput[]
    musicalId?: IntFilter<"MusicalCommunity"> | number
    communityId?: IntFilter<"MusicalCommunity"> | number
    musical?: XOR<MusicalScalarRelationFilter, MusicalWhereInput>
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
  }, "id">

  export type MusicalCommunityOrderByWithAggregationInput = {
    id?: SortOrder
    musicalId?: SortOrder
    communityId?: SortOrder
    _count?: MusicalCommunityCountOrderByAggregateInput
    _avg?: MusicalCommunityAvgOrderByAggregateInput
    _max?: MusicalCommunityMaxOrderByAggregateInput
    _min?: MusicalCommunityMinOrderByAggregateInput
    _sum?: MusicalCommunitySumOrderByAggregateInput
  }

  export type MusicalCommunityScalarWhereWithAggregatesInput = {
    AND?: MusicalCommunityScalarWhereWithAggregatesInput | MusicalCommunityScalarWhereWithAggregatesInput[]
    OR?: MusicalCommunityScalarWhereWithAggregatesInput[]
    NOT?: MusicalCommunityScalarWhereWithAggregatesInput | MusicalCommunityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MusicalCommunity"> | number
    musicalId?: IntWithAggregatesFilter<"MusicalCommunity"> | number
    communityId?: IntWithAggregatesFilter<"MusicalCommunity"> | number
  }

  export type MultiProfileWhereInput = {
    AND?: MultiProfileWhereInput | MultiProfileWhereInput[]
    OR?: MultiProfileWhereInput[]
    NOT?: MultiProfileWhereInput | MultiProfileWhereInput[]
    id?: IntFilter<"MultiProfile"> | number
    userId?: IntFilter<"MultiProfile"> | number
    nickname?: StringFilter<"MultiProfile"> | string
    image?: StringNullableFilter<"MultiProfile"> | string | null
    bio?: StringNullableFilter<"MultiProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MultiProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    nickname?: SortOrder
    image?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: MultiProfileOrderByRelevanceInput
  }

  export type MultiProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MultiProfileWhereInput | MultiProfileWhereInput[]
    OR?: MultiProfileWhereInput[]
    NOT?: MultiProfileWhereInput | MultiProfileWhereInput[]
    userId?: IntFilter<"MultiProfile"> | number
    nickname?: StringFilter<"MultiProfile"> | string
    image?: StringNullableFilter<"MultiProfile"> | string | null
    bio?: StringNullableFilter<"MultiProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MultiProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    nickname?: SortOrder
    image?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    _count?: MultiProfileCountOrderByAggregateInput
    _avg?: MultiProfileAvgOrderByAggregateInput
    _max?: MultiProfileMaxOrderByAggregateInput
    _min?: MultiProfileMinOrderByAggregateInput
    _sum?: MultiProfileSumOrderByAggregateInput
  }

  export type MultiProfileScalarWhereWithAggregatesInput = {
    AND?: MultiProfileScalarWhereWithAggregatesInput | MultiProfileScalarWhereWithAggregatesInput[]
    OR?: MultiProfileScalarWhereWithAggregatesInput[]
    NOT?: MultiProfileScalarWhereWithAggregatesInput | MultiProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MultiProfile"> | number
    userId?: IntWithAggregatesFilter<"MultiProfile"> | number
    nickname?: StringWithAggregatesFilter<"MultiProfile"> | string
    image?: StringNullableWithAggregatesFilter<"MultiProfile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"MultiProfile"> | string | null
  }

  export type UserCreateInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
  }

  export type UserUpdateManyMutationInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PostCreateInput = {
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    extraField?: string | null
    user: UserCreateNestedOneWithoutPostsInput
    actor?: ActorCreateNestedOneWithoutPostsInput
    setting: SettingCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postLikes?: PostLikeCreateNestedManyWithoutPostInput
    images?: ImageCreateNestedManyWithoutPostInput
    reviews?: ReviewCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    userId: number
    settingId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    actorId?: number | null
    extraField?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    images?: ImageUncheckedCreateNestedManyWithoutPostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostUpdateInput = {
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    actor?: ActorUpdateOneWithoutPostsNestedInput
    setting?: SettingUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUpdateManyWithoutPostNestedInput
    images?: ImageUpdateManyWithoutPostNestedInput
    reviews?: ReviewUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    images?: ImageUncheckedUpdateManyWithoutPostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostCreateManyInput = {
    id?: number
    userId: number
    settingId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    actorId?: number | null
    extraField?: string | null
  }

  export type PostUpdateManyMutationInput = {
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateInput = {
    settingId: number
    communityId: number
    content?: string | null
    createdAt?: Date | string | null
    anonymous?: boolean | null
    post: PostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    settingId: number
    communityId: number
    content?: string | null
    createdAt?: Date | string | null
    anonymous?: boolean | null
  }

  export type CommentUpdateInput = {
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommentCreateManyInput = {
    id?: number
    postId: number
    userId: number
    settingId: number
    communityId: number
    content?: string | null
    createdAt?: Date | string | null
    anonymous?: boolean | null
  }

  export type CommentUpdateManyMutationInput = {
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ReviewCreateInput = {
    settingId: number
    theaterId: number
    key: number
    content?: string | null
    rating?: number | null
    spoiler?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    liked?: string | null
    likeCount?: number | null
    comment?: string | null
    imageUrl?: string | null
    reported?: boolean | null
    watchDate?: Date | string | null
    watchTime?: Date | string | null
    extraField2?: string | null
    user: UserCreateNestedOneWithoutReviewsInput
    post?: PostCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: number
    userId: number
    settingId: number
    theaterId: number
    key: number
    postId?: number | null
    content?: string | null
    rating?: number | null
    spoiler?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    liked?: string | null
    likeCount?: number | null
    comment?: string | null
    imageUrl?: string | null
    reported?: boolean | null
    watchDate?: Date | string | null
    watchTime?: Date | string | null
    extraField2?: string | null
  }

  export type ReviewUpdateInput = {
    settingId?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    spoiler?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liked?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reported?: NullableBoolFieldUpdateOperationsInput | boolean | null
    watchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraField2?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    post?: PostUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    spoiler?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liked?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reported?: NullableBoolFieldUpdateOperationsInput | boolean | null
    watchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraField2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewCreateManyInput = {
    id?: number
    userId: number
    settingId: number
    theaterId: number
    key: number
    postId?: number | null
    content?: string | null
    rating?: number | null
    spoiler?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    liked?: string | null
    likeCount?: number | null
    comment?: string | null
    imageUrl?: string | null
    reported?: boolean | null
    watchDate?: Date | string | null
    watchTime?: Date | string | null
    extraField2?: string | null
  }

  export type ReviewUpdateManyMutationInput = {
    settingId?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    spoiler?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liked?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reported?: NullableBoolFieldUpdateOperationsInput | boolean | null
    watchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraField2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    spoiler?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liked?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reported?: NullableBoolFieldUpdateOperationsInput | boolean | null
    watchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraField2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActorCreateInput = {
    postId: number
    userId: number
    settingId: number
    communityId: number
    key: number
    name?: string | null
    image?: string | null
    profile?: string | null
    snsLink?: string | null
    fk?: number | null
    posts?: PostCreateNestedManyWithoutActorInput
    castings?: CastingCreateNestedManyWithoutActorInput
  }

  export type ActorUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    settingId: number
    communityId: number
    key: number
    name?: string | null
    image?: string | null
    profile?: string | null
    snsLink?: string | null
    fk?: number | null
    posts?: PostUncheckedCreateNestedManyWithoutActorInput
    castings?: CastingUncheckedCreateNestedManyWithoutActorInput
  }

  export type ActorUpdateInput = {
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    snsLink?: NullableStringFieldUpdateOperationsInput | string | null
    fk?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUpdateManyWithoutActorNestedInput
    castings?: CastingUpdateManyWithoutActorNestedInput
  }

  export type ActorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    snsLink?: NullableStringFieldUpdateOperationsInput | string | null
    fk?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUncheckedUpdateManyWithoutActorNestedInput
    castings?: CastingUncheckedUpdateManyWithoutActorNestedInput
  }

  export type ActorCreateManyInput = {
    id?: number
    postId: number
    userId: number
    settingId: number
    communityId: number
    key: number
    name?: string | null
    image?: string | null
    profile?: string | null
    snsLink?: string | null
    fk?: number | null
  }

  export type ActorUpdateManyMutationInput = {
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    snsLink?: NullableStringFieldUpdateOperationsInput | string | null
    fk?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    snsLink?: NullableStringFieldUpdateOperationsInput | string | null
    fk?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MusicalCreateInput = {
    id: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    theater: TheaterCreateNestedOneWithoutMusicalsInput
    castings?: CastingCreateNestedManyWithoutMusicalInput
    viewings?: ViewingRecordCreateNestedManyWithoutMusicalInput
    communities?: MusicalCommunityCreateNestedManyWithoutMusicalInput
  }

  export type MusicalUncheckedCreateInput = {
    id: number
    theaterId: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    castings?: CastingUncheckedCreateNestedManyWithoutMusicalInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutMusicalInput
    communities?: MusicalCommunityUncheckedCreateNestedManyWithoutMusicalInput
  }

  export type MusicalUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theater?: TheaterUpdateOneRequiredWithoutMusicalsNestedInput
    castings?: CastingUpdateManyWithoutMusicalNestedInput
    viewings?: ViewingRecordUpdateManyWithoutMusicalNestedInput
    communities?: MusicalCommunityUpdateManyWithoutMusicalNestedInput
  }

  export type MusicalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    castings?: CastingUncheckedUpdateManyWithoutMusicalNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutMusicalNestedInput
    communities?: MusicalCommunityUncheckedUpdateManyWithoutMusicalNestedInput
  }

  export type MusicalCreateManyInput = {
    id: number
    theaterId: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MusicalUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MusicalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TheaterCreateInput = {
    id: number
    name?: string | null
    seatCount?: number | null
    roadAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    region: RegionCreateNestedOneWithoutTheatersInput
    musicals?: MusicalCreateNestedManyWithoutTheaterInput
    seats?: SeatCreateNestedManyWithoutTheaterInput
  }

  export type TheaterUncheckedCreateInput = {
    id: number
    regionId: number
    name?: string | null
    seatCount?: number | null
    roadAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    musicals?: MusicalUncheckedCreateNestedManyWithoutTheaterInput
    seats?: SeatUncheckedCreateNestedManyWithoutTheaterInput
  }

  export type TheaterUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    seatCount?: NullableIntFieldUpdateOperationsInput | number | null
    roadAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneRequiredWithoutTheatersNestedInput
    musicals?: MusicalUpdateManyWithoutTheaterNestedInput
    seats?: SeatUpdateManyWithoutTheaterNestedInput
  }

  export type TheaterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    seatCount?: NullableIntFieldUpdateOperationsInput | number | null
    roadAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    musicals?: MusicalUncheckedUpdateManyWithoutTheaterNestedInput
    seats?: SeatUncheckedUpdateManyWithoutTheaterNestedInput
  }

  export type TheaterCreateManyInput = {
    id: number
    regionId: number
    name?: string | null
    seatCount?: number | null
    roadAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TheaterUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    seatCount?: NullableIntFieldUpdateOperationsInput | number | null
    roadAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TheaterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    seatCount?: NullableIntFieldUpdateOperationsInput | number | null
    roadAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SeatCreateInput = {
    id: number
    locationId: number
    field?: string | null
    field2?: string | null
    field3?: string | null
    floor?: string | null
    theater: TheaterCreateNestedOneWithoutSeatsInput
  }

  export type SeatUncheckedCreateInput = {
    id: number
    theaterId: number
    locationId: number
    field?: string | null
    field2?: string | null
    field3?: string | null
    floor?: string | null
  }

  export type SeatUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    field?: NullableStringFieldUpdateOperationsInput | string | null
    field2?: NullableStringFieldUpdateOperationsInput | string | null
    field3?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    theater?: TheaterUpdateOneRequiredWithoutSeatsNestedInput
  }

  export type SeatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    field?: NullableStringFieldUpdateOperationsInput | string | null
    field2?: NullableStringFieldUpdateOperationsInput | string | null
    field3?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeatCreateManyInput = {
    id: number
    theaterId: number
    locationId: number
    field?: string | null
    field2?: string | null
    field3?: string | null
    floor?: string | null
  }

  export type SeatUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    field?: NullableStringFieldUpdateOperationsInput | string | null
    field2?: NullableStringFieldUpdateOperationsInput | string | null
    field3?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    field?: NullableStringFieldUpdateOperationsInput | string | null
    field2?: NullableStringFieldUpdateOperationsInput | string | null
    field3?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityCreateInput = {
    createdAt?: Date | string | null
    name?: string | null
    type?: string | null
    description?: string | null
    userCommunities?: UserCommunityCreateNestedManyWithoutCommunityInput
    musicalCommunities?: MusicalCommunityCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string | null
    name?: string | null
    type?: string | null
    description?: string | null
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutCommunityInput
    musicalCommunities?: MusicalCommunityUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userCommunities?: UserCommunityUpdateManyWithoutCommunityNestedInput
    musicalCommunities?: MusicalCommunityUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutCommunityNestedInput
    musicalCommunities?: MusicalCommunityUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityCreateManyInput = {
    id?: number
    createdAt?: Date | string | null
    name?: string | null
    type?: string | null
    description?: string | null
  }

  export type CommunityUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingCreateInput = {
    useBackground?: boolean | null
    useProfilePhoto?: boolean | null
    allowRepost?: boolean | null
    users?: UserCreateNestedOneWithoutSettingInput
    posts?: PostCreateNestedManyWithoutSettingInput
  }

  export type SettingUncheckedCreateInput = {
    id?: number
    useBackground?: boolean | null
    useProfilePhoto?: boolean | null
    allowRepost?: boolean | null
    users?: UserUncheckedCreateNestedOneWithoutSettingInput
    posts?: PostUncheckedCreateNestedManyWithoutSettingInput
  }

  export type SettingUpdateInput = {
    useBackground?: NullableBoolFieldUpdateOperationsInput | boolean | null
    useProfilePhoto?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowRepost?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: UserUpdateOneWithoutSettingNestedInput
    posts?: PostUpdateManyWithoutSettingNestedInput
  }

  export type SettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    useBackground?: NullableBoolFieldUpdateOperationsInput | boolean | null
    useProfilePhoto?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowRepost?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: UserUncheckedUpdateOneWithoutSettingNestedInput
    posts?: PostUncheckedUpdateManyWithoutSettingNestedInput
  }

  export type SettingCreateManyInput = {
    id?: number
    useBackground?: boolean | null
    useProfilePhoto?: boolean | null
    allowRepost?: boolean | null
  }

  export type SettingUpdateManyMutationInput = {
    useBackground?: NullableBoolFieldUpdateOperationsInput | boolean | null
    useProfilePhoto?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowRepost?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    useBackground?: NullableBoolFieldUpdateOperationsInput | boolean | null
    useProfilePhoto?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowRepost?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TagCreateInput = {
    name: string
    type?: string | null
    posts?: PostCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    name: string
    type?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    name: string
    type?: string | null
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageCreateInput = {
    url?: string | null
    caption?: string | null
    post: PostCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateInput = {
    id?: number
    postId: number
    url?: string | null
    caption?: string | null
  }

  export type ImageUpdateInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    post?: PostUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageCreateManyInput = {
    id?: number
    postId: number
    url?: string | null
    caption?: string | null
  }

  export type ImageUpdateManyMutationInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscribeCreateInput = {
    id: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean | null
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscribeUncheckedCreateInput = {
    id: number
    userId: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean | null
  }

  export type SubscribeUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscribeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SubscribeCreateManyInput = {
    id: number
    userId: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean | null
  }

  export type SubscribeUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SubscribeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FollowCreateInput = {
    id: number
    createdAt?: Date | string | null
    follower: UserCreateNestedOneWithoutFollowersInput
    following: UserCreateNestedOneWithoutFollowsInput
  }

  export type FollowUncheckedCreateInput = {
    id: number
    followerId: number
    followingId: number
    createdAt?: Date | string | null
  }

  export type FollowUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
    following?: UserUpdateOneRequiredWithoutFollowsNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    followerId?: IntFieldUpdateOperationsInput | number
    followingId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FollowCreateManyInput = {
    id: number
    followerId: number
    followingId: number
    createdAt?: Date | string | null
  }

  export type FollowUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FollowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    followerId?: IntFieldUpdateOperationsInput | number
    followingId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ViewingRecordCreateInput = {
    id: number
    date?: Date | string | null
    seat?: string | null
    user: UserCreateNestedOneWithoutViewingsInput
    musical: MusicalCreateNestedOneWithoutViewingsInput
  }

  export type ViewingRecordUncheckedCreateInput = {
    id: number
    userId: number
    musicalId: number
    date?: Date | string | null
    seat?: string | null
  }

  export type ViewingRecordUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seat?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutViewingsNestedInput
    musical?: MusicalUpdateOneRequiredWithoutViewingsNestedInput
  }

  export type ViewingRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seat?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewingRecordCreateManyInput = {
    id: number
    userId: number
    musicalId: number
    date?: Date | string | null
    seat?: string | null
  }

  export type ViewingRecordUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seat?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewingRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seat?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostLikeCreateInput = {
    likedAt?: Date | string | null
    post: PostCreateNestedOneWithoutPostLikesInput
    user: UserCreateNestedOneWithoutPostLikesInput
  }

  export type PostLikeUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    likedAt?: Date | string | null
  }

  export type PostLikeUpdateInput = {
    likedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutPostLikesNestedInput
    user?: UserUpdateOneRequiredWithoutPostLikesNestedInput
  }

  export type PostLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    likedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostLikeCreateManyInput = {
    id?: number
    postId: number
    userId: number
    likedAt?: Date | string | null
  }

  export type PostLikeUpdateManyMutationInput = {
    likedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    likedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionCreateInput = {
    title: string
    content: string
    createdAt?: Date | string | null
    user: UserCreateNestedOneWithoutQuestionsInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: number
    userId: number
    title: string
    content: string
    createdAt?: Date | string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutQuestionsNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: number
    userId: number
    title: string
    content: string
    createdAt?: Date | string | null
  }

  export type QuestionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerCreateInput = {
    content: string
    createdAt?: Date | string | null
    question: QuestionCreateNestedOneWithoutAnswersInput
    user: UserCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateInput = {
    id?: number
    questionId: number
    userId: number
    content: string
    createdAt?: Date | string | null
  }

  export type AnswerUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
    user?: UserUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerCreateManyInput = {
    id?: number
    questionId: number
    userId: number
    content: string
    createdAt?: Date | string | null
  }

  export type AnswerUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RegionCreateInput = {
    name: string
    theaters?: TheaterCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: number
    name: string
    theaters?: TheaterUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    theaters?: TheaterUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    theaters?: TheaterUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id?: number
    name: string
  }

  export type RegionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CastingCreateInput = {
    role?: string | null
    musical: MusicalCreateNestedOneWithoutCastingsInput
    actor: ActorCreateNestedOneWithoutCastingsInput
  }

  export type CastingUncheckedCreateInput = {
    id?: number
    musicalId: number
    actorId: number
    role?: string | null
  }

  export type CastingUpdateInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    musical?: MusicalUpdateOneRequiredWithoutCastingsNestedInput
    actor?: ActorUpdateOneRequiredWithoutCastingsNestedInput
  }

  export type CastingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
    actorId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CastingCreateManyInput = {
    id?: number
    musicalId: number
    actorId: number
    role?: string | null
  }

  export type CastingUpdateManyMutationInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CastingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
    actorId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommunityCreateInput = {
    joinedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUserCommunitiesInput
    community: CommunityCreateNestedOneWithoutUserCommunitiesInput
  }

  export type UserCommunityUncheckedCreateInput = {
    id?: number
    userId: number
    communityId: number
    joinedAt?: Date | string | null
  }

  export type UserCommunityUpdateInput = {
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserCommunitiesNestedInput
    community?: CommunityUpdateOneRequiredWithoutUserCommunitiesNestedInput
  }

  export type UserCommunityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCommunityCreateManyInput = {
    id?: number
    userId: number
    communityId: number
    joinedAt?: Date | string | null
  }

  export type UserCommunityUpdateManyMutationInput = {
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCommunityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MusicalCommunityCreateInput = {
    musical: MusicalCreateNestedOneWithoutCommunitiesInput
    community: CommunityCreateNestedOneWithoutMusicalCommunitiesInput
  }

  export type MusicalCommunityUncheckedCreateInput = {
    id?: number
    musicalId: number
    communityId: number
  }

  export type MusicalCommunityUpdateInput = {
    musical?: MusicalUpdateOneRequiredWithoutCommunitiesNestedInput
    community?: CommunityUpdateOneRequiredWithoutMusicalCommunitiesNestedInput
  }

  export type MusicalCommunityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
  }

  export type MusicalCommunityCreateManyInput = {
    id?: number
    musicalId: number
    communityId: number
  }

  export type MusicalCommunityUpdateManyMutationInput = {

  }

  export type MusicalCommunityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
  }

  export type MultiProfileCreateInput = {
    nickname: string
    image?: string | null
    bio?: string | null
    user: UserCreateNestedOneWithoutMultiProfilesInput
  }

  export type MultiProfileUncheckedCreateInput = {
    id?: number
    userId: number
    nickname: string
    image?: string | null
    bio?: string | null
  }

  export type MultiProfileUpdateInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutMultiProfilesNestedInput
  }

  export type MultiProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MultiProfileCreateManyInput = {
    id?: number
    userId: number
    nickname: string
    image?: string | null
    bio?: string | null
  }

  export type MultiProfileUpdateManyMutationInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MultiProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type SettingScalarRelationFilter = {
    is?: SettingWhereInput
    isNot?: SettingWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type PostLikeListRelationFilter = {
    every?: PostLikeWhereInput
    some?: PostLikeWhereInput
    none?: PostLikeWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type AnswerListRelationFilter = {
    every?: AnswerWhereInput
    some?: AnswerWhereInput
    none?: AnswerWhereInput
  }

  export type SubscribeListRelationFilter = {
    every?: SubscribeWhereInput
    some?: SubscribeWhereInput
    none?: SubscribeWhereInput
  }

  export type ViewingRecordListRelationFilter = {
    every?: ViewingRecordWhereInput
    some?: ViewingRecordWhereInput
    none?: ViewingRecordWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type MultiProfileListRelationFilter = {
    every?: MultiProfileWhereInput
    some?: MultiProfileWhereInput
    none?: MultiProfileWhereInput
  }

  export type UserCommunityListRelationFilter = {
    every?: UserCommunityWhereInput
    some?: UserCommunityWhereInput
    none?: UserCommunityWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscribeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViewingRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MultiProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCommunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    settingId?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    nickname?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bio?: SortOrder
    birthDate?: SortOrder
    isSubscribed?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    settingId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    settingId?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    nickname?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bio?: SortOrder
    birthDate?: SortOrder
    isSubscribed?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    settingId?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    nickname?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bio?: SortOrder
    birthDate?: SortOrder
    isSubscribed?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    settingId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumImageOrVideoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageOrVideo | EnumImageOrVideoFieldRefInput<$PrismaModel> | null
    in?: $Enums.ImageOrVideo[] | null
    notIn?: $Enums.ImageOrVideo[] | null
    not?: NestedEnumImageOrVideoNullableFilter<$PrismaModel> | $Enums.ImageOrVideo | null
  }

  export type EnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | null
    notIn?: $Enums.Category[] | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ActorNullableScalarRelationFilter = {
    is?: ActorWhereInput | null
    isNot?: ActorWhereInput | null
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelevanceInput = {
    fields: PostOrderByRelevanceFieldEnum | PostOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    like?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    repost?: SortOrder
    bookmark?: SortOrder
    communityGroup?: SortOrder
    viewCount?: SortOrder
    tag?: SortOrder
    mediaType?: SortOrder
    isPinned?: SortOrder
    tabCategory?: SortOrder
    isShared?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
    extraField?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    repost?: SortOrder
    bookmark?: SortOrder
    viewCount?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    like?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    repost?: SortOrder
    bookmark?: SortOrder
    communityGroup?: SortOrder
    viewCount?: SortOrder
    tag?: SortOrder
    mediaType?: SortOrder
    isPinned?: SortOrder
    tabCategory?: SortOrder
    isShared?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
    extraField?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    like?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    repost?: SortOrder
    bookmark?: SortOrder
    communityGroup?: SortOrder
    viewCount?: SortOrder
    tag?: SortOrder
    mediaType?: SortOrder
    isPinned?: SortOrder
    tabCategory?: SortOrder
    isShared?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
    extraField?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    repost?: SortOrder
    bookmark?: SortOrder
    viewCount?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumImageOrVideoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageOrVideo | EnumImageOrVideoFieldRefInput<$PrismaModel> | null
    in?: $Enums.ImageOrVideo[] | null
    notIn?: $Enums.ImageOrVideo[] | null
    not?: NestedEnumImageOrVideoNullableWithAggregatesFilter<$PrismaModel> | $Enums.ImageOrVideo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumImageOrVideoNullableFilter<$PrismaModel>
    _max?: NestedEnumImageOrVideoNullableFilter<$PrismaModel>
  }

  export type EnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | null
    notIn?: $Enums.Category[] | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type CommentOrderByRelevanceInput = {
    fields: CommentOrderByRelevanceFieldEnum | CommentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    anonymous?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    anonymous?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    anonymous?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
  }

  export type PostNullableScalarRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type ReviewOrderByRelevanceInput = {
    fields: ReviewOrderByRelevanceFieldEnum | ReviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    theaterId?: SortOrder
    key?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    spoiler?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    liked?: SortOrder
    likeCount?: SortOrder
    comment?: SortOrder
    imageUrl?: SortOrder
    reported?: SortOrder
    watchDate?: SortOrder
    watchTime?: SortOrder
    extraField2?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    theaterId?: SortOrder
    key?: SortOrder
    postId?: SortOrder
    rating?: SortOrder
    likeCount?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    theaterId?: SortOrder
    key?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    spoiler?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    liked?: SortOrder
    likeCount?: SortOrder
    comment?: SortOrder
    imageUrl?: SortOrder
    reported?: SortOrder
    watchDate?: SortOrder
    watchTime?: SortOrder
    extraField2?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    theaterId?: SortOrder
    key?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    spoiler?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    liked?: SortOrder
    likeCount?: SortOrder
    comment?: SortOrder
    imageUrl?: SortOrder
    reported?: SortOrder
    watchDate?: SortOrder
    watchTime?: SortOrder
    extraField2?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    theaterId?: SortOrder
    key?: SortOrder
    postId?: SortOrder
    rating?: SortOrder
    likeCount?: SortOrder
  }

  export type CastingListRelationFilter = {
    every?: CastingWhereInput
    some?: CastingWhereInput
    none?: CastingWhereInput
  }

  export type CastingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActorOrderByRelevanceInput = {
    fields: ActorOrderByRelevanceFieldEnum | ActorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActorCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    image?: SortOrder
    profile?: SortOrder
    snsLink?: SortOrder
    fk?: SortOrder
  }

  export type ActorAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    key?: SortOrder
    fk?: SortOrder
  }

  export type ActorMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    image?: SortOrder
    profile?: SortOrder
    snsLink?: SortOrder
    fk?: SortOrder
  }

  export type ActorMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    image?: SortOrder
    profile?: SortOrder
    snsLink?: SortOrder
    fk?: SortOrder
  }

  export type ActorSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    communityId?: SortOrder
    key?: SortOrder
    fk?: SortOrder
  }

  export type TheaterScalarRelationFilter = {
    is?: TheaterWhereInput
    isNot?: TheaterWhereInput
  }

  export type MusicalCommunityListRelationFilter = {
    every?: MusicalCommunityWhereInput
    some?: MusicalCommunityWhereInput
    none?: MusicalCommunityWhereInput
  }

  export type MusicalCommunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MusicalOrderByRelevanceInput = {
    fields: MusicalOrderByRelevanceFieldEnum | MusicalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MusicalCountOrderByAggregateInput = {
    id?: SortOrder
    theaterId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    poster?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MusicalAvgOrderByAggregateInput = {
    id?: SortOrder
    theaterId?: SortOrder
  }

  export type MusicalMaxOrderByAggregateInput = {
    id?: SortOrder
    theaterId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    poster?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MusicalMinOrderByAggregateInput = {
    id?: SortOrder
    theaterId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    poster?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MusicalSumOrderByAggregateInput = {
    id?: SortOrder
    theaterId?: SortOrder
  }

  export type RegionScalarRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type MusicalListRelationFilter = {
    every?: MusicalWhereInput
    some?: MusicalWhereInput
    none?: MusicalWhereInput
  }

  export type SeatListRelationFilter = {
    every?: SeatWhereInput
    some?: SeatWhereInput
    none?: SeatWhereInput
  }

  export type MusicalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TheaterOrderByRelevanceInput = {
    fields: TheaterOrderByRelevanceFieldEnum | TheaterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TheaterCountOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    name?: SortOrder
    seatCount?: SortOrder
    roadAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TheaterAvgOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    seatCount?: SortOrder
  }

  export type TheaterMaxOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    name?: SortOrder
    seatCount?: SortOrder
    roadAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TheaterMinOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    name?: SortOrder
    seatCount?: SortOrder
    roadAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TheaterSumOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    seatCount?: SortOrder
  }

  export type SeatOrderByRelevanceInput = {
    fields: SeatOrderByRelevanceFieldEnum | SeatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SeatCountOrderByAggregateInput = {
    id?: SortOrder
    theaterId?: SortOrder
    locationId?: SortOrder
    field?: SortOrder
    field2?: SortOrder
    field3?: SortOrder
    floor?: SortOrder
  }

  export type SeatAvgOrderByAggregateInput = {
    id?: SortOrder
    theaterId?: SortOrder
    locationId?: SortOrder
  }

  export type SeatMaxOrderByAggregateInput = {
    id?: SortOrder
    theaterId?: SortOrder
    locationId?: SortOrder
    field?: SortOrder
    field2?: SortOrder
    field3?: SortOrder
    floor?: SortOrder
  }

  export type SeatMinOrderByAggregateInput = {
    id?: SortOrder
    theaterId?: SortOrder
    locationId?: SortOrder
    field?: SortOrder
    field2?: SortOrder
    field3?: SortOrder
    floor?: SortOrder
  }

  export type SeatSumOrderByAggregateInput = {
    id?: SortOrder
    theaterId?: SortOrder
    locationId?: SortOrder
  }

  export type CommunityOrderByRelevanceInput = {
    fields: CommunityOrderByRelevanceFieldEnum | CommunityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CommunityCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
  }

  export type CommunityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CommunityMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
  }

  export type CommunityMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
  }

  export type CommunitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    useBackground?: SortOrder
    useProfilePhoto?: SortOrder
    allowRepost?: SortOrder
  }

  export type SettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    useBackground?: SortOrder
    useProfilePhoto?: SortOrder
    allowRepost?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    useBackground?: SortOrder
    useProfilePhoto?: SortOrder
    allowRepost?: SortOrder
  }

  export type SettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagOrderByRelevanceInput = {
    fields: TagOrderByRelevanceFieldEnum | TagOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ImageOrderByRelevanceInput = {
    fields: ImageOrderByRelevanceFieldEnum | ImageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    caption?: SortOrder
  }

  export type ImageAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    caption?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    caption?: SortOrder
  }

  export type ImageSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
  }

  export type SubscribeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
  }

  export type SubscribeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SubscribeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
  }

  export type SubscribeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
  }

  export type SubscribeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowAvgOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowSumOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
  }

  export type MusicalScalarRelationFilter = {
    is?: MusicalWhereInput
    isNot?: MusicalWhereInput
  }

  export type ViewingRecordOrderByRelevanceInput = {
    fields: ViewingRecordOrderByRelevanceFieldEnum | ViewingRecordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ViewingRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    musicalId?: SortOrder
    date?: SortOrder
    seat?: SortOrder
  }

  export type ViewingRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    musicalId?: SortOrder
  }

  export type ViewingRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    musicalId?: SortOrder
    date?: SortOrder
    seat?: SortOrder
  }

  export type ViewingRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    musicalId?: SortOrder
    date?: SortOrder
    seat?: SortOrder
  }

  export type ViewingRecordSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    musicalId?: SortOrder
  }

  export type PostLikeCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    likedAt?: SortOrder
  }

  export type PostLikeAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type PostLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    likedAt?: SortOrder
  }

  export type PostLikeMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    likedAt?: SortOrder
  }

  export type PostLikeSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type QuestionOrderByRelevanceInput = {
    fields: QuestionOrderByRelevanceFieldEnum | QuestionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type QuestionScalarRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type AnswerOrderByRelevanceInput = {
    fields: AnswerOrderByRelevanceFieldEnum | AnswerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AnswerCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
  }

  export type AnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AnswerMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AnswerSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
  }

  export type TheaterListRelationFilter = {
    every?: TheaterWhereInput
    some?: TheaterWhereInput
    none?: TheaterWhereInput
  }

  export type TheaterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionOrderByRelevanceInput = {
    fields: RegionOrderByRelevanceFieldEnum | RegionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActorScalarRelationFilter = {
    is?: ActorWhereInput
    isNot?: ActorWhereInput
  }

  export type CastingOrderByRelevanceInput = {
    fields: CastingOrderByRelevanceFieldEnum | CastingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CastingCountOrderByAggregateInput = {
    id?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
    role?: SortOrder
  }

  export type CastingAvgOrderByAggregateInput = {
    id?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
  }

  export type CastingMaxOrderByAggregateInput = {
    id?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
    role?: SortOrder
  }

  export type CastingMinOrderByAggregateInput = {
    id?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
    role?: SortOrder
  }

  export type CastingSumOrderByAggregateInput = {
    id?: SortOrder
    musicalId?: SortOrder
    actorId?: SortOrder
  }

  export type CommunityScalarRelationFilter = {
    is?: CommunityWhereInput
    isNot?: CommunityWhereInput
  }

  export type UserCommunityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
    joinedAt?: SortOrder
  }

  export type UserCommunityAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
  }

  export type UserCommunityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
    joinedAt?: SortOrder
  }

  export type UserCommunityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
    joinedAt?: SortOrder
  }

  export type UserCommunitySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
  }

  export type MusicalCommunityCountOrderByAggregateInput = {
    id?: SortOrder
    musicalId?: SortOrder
    communityId?: SortOrder
  }

  export type MusicalCommunityAvgOrderByAggregateInput = {
    id?: SortOrder
    musicalId?: SortOrder
    communityId?: SortOrder
  }

  export type MusicalCommunityMaxOrderByAggregateInput = {
    id?: SortOrder
    musicalId?: SortOrder
    communityId?: SortOrder
  }

  export type MusicalCommunityMinOrderByAggregateInput = {
    id?: SortOrder
    musicalId?: SortOrder
    communityId?: SortOrder
  }

  export type MusicalCommunitySumOrderByAggregateInput = {
    id?: SortOrder
    musicalId?: SortOrder
    communityId?: SortOrder
  }

  export type MultiProfileOrderByRelevanceInput = {
    fields: MultiProfileOrderByRelevanceFieldEnum | MultiProfileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MultiProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nickname?: SortOrder
    image?: SortOrder
    bio?: SortOrder
  }

  export type MultiProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MultiProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nickname?: SortOrder
    image?: SortOrder
    bio?: SortOrder
  }

  export type MultiProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nickname?: SortOrder
    image?: SortOrder
    bio?: SortOrder
  }

  export type MultiProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SettingCreateNestedOneWithoutUsersInput = {
    create?: XOR<SettingCreateWithoutUsersInput, SettingUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SettingCreateOrConnectWithoutUsersInput
    connect?: SettingWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PostLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput> | PostLikeCreateWithoutUserInput[] | PostLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutUserInput | PostLikeCreateOrConnectWithoutUserInput[]
    createMany?: PostLikeCreateManyUserInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type QuestionCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput> | QuestionCreateWithoutUserInput[] | QuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutUserInput | QuestionCreateOrConnectWithoutUserInput[]
    createMany?: QuestionCreateManyUserInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type AnswerCreateNestedManyWithoutUserInput = {
    create?: XOR<AnswerCreateWithoutUserInput, AnswerUncheckedCreateWithoutUserInput> | AnswerCreateWithoutUserInput[] | AnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutUserInput | AnswerCreateOrConnectWithoutUserInput[]
    createMany?: AnswerCreateManyUserInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type SubscribeCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscribeCreateWithoutUserInput, SubscribeUncheckedCreateWithoutUserInput> | SubscribeCreateWithoutUserInput[] | SubscribeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscribeCreateOrConnectWithoutUserInput | SubscribeCreateOrConnectWithoutUserInput[]
    createMany?: SubscribeCreateManyUserInputEnvelope
    connect?: SubscribeWhereUniqueInput | SubscribeWhereUniqueInput[]
  }

  export type ViewingRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewingRecordCreateWithoutUserInput, ViewingRecordUncheckedCreateWithoutUserInput> | ViewingRecordCreateWithoutUserInput[] | ViewingRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewingRecordCreateOrConnectWithoutUserInput | ViewingRecordCreateOrConnectWithoutUserInput[]
    createMany?: ViewingRecordCreateManyUserInputEnvelope
    connect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type MultiProfileCreateNestedManyWithoutUserInput = {
    create?: XOR<MultiProfileCreateWithoutUserInput, MultiProfileUncheckedCreateWithoutUserInput> | MultiProfileCreateWithoutUserInput[] | MultiProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiProfileCreateOrConnectWithoutUserInput | MultiProfileCreateOrConnectWithoutUserInput[]
    createMany?: MultiProfileCreateManyUserInputEnvelope
    connect?: MultiProfileWhereUniqueInput | MultiProfileWhereUniqueInput[]
  }

  export type UserCommunityCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCommunityCreateWithoutUserInput, UserCommunityUncheckedCreateWithoutUserInput> | UserCommunityCreateWithoutUserInput[] | UserCommunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCommunityCreateOrConnectWithoutUserInput | UserCommunityCreateOrConnectWithoutUserInput[]
    createMany?: UserCommunityCreateManyUserInputEnvelope
    connect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PostLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput> | PostLikeCreateWithoutUserInput[] | PostLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutUserInput | PostLikeCreateOrConnectWithoutUserInput[]
    createMany?: PostLikeCreateManyUserInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput> | QuestionCreateWithoutUserInput[] | QuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutUserInput | QuestionCreateOrConnectWithoutUserInput[]
    createMany?: QuestionCreateManyUserInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type AnswerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnswerCreateWithoutUserInput, AnswerUncheckedCreateWithoutUserInput> | AnswerCreateWithoutUserInput[] | AnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutUserInput | AnswerCreateOrConnectWithoutUserInput[]
    createMany?: AnswerCreateManyUserInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type SubscribeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscribeCreateWithoutUserInput, SubscribeUncheckedCreateWithoutUserInput> | SubscribeCreateWithoutUserInput[] | SubscribeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscribeCreateOrConnectWithoutUserInput | SubscribeCreateOrConnectWithoutUserInput[]
    createMany?: SubscribeCreateManyUserInputEnvelope
    connect?: SubscribeWhereUniqueInput | SubscribeWhereUniqueInput[]
  }

  export type ViewingRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewingRecordCreateWithoutUserInput, ViewingRecordUncheckedCreateWithoutUserInput> | ViewingRecordCreateWithoutUserInput[] | ViewingRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewingRecordCreateOrConnectWithoutUserInput | ViewingRecordCreateOrConnectWithoutUserInput[]
    createMany?: ViewingRecordCreateManyUserInputEnvelope
    connect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type MultiProfileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MultiProfileCreateWithoutUserInput, MultiProfileUncheckedCreateWithoutUserInput> | MultiProfileCreateWithoutUserInput[] | MultiProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiProfileCreateOrConnectWithoutUserInput | MultiProfileCreateOrConnectWithoutUserInput[]
    createMany?: MultiProfileCreateManyUserInputEnvelope
    connect?: MultiProfileWhereUniqueInput | MultiProfileWhereUniqueInput[]
  }

  export type UserCommunityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCommunityCreateWithoutUserInput, UserCommunityUncheckedCreateWithoutUserInput> | UserCommunityCreateWithoutUserInput[] | UserCommunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCommunityCreateOrConnectWithoutUserInput | UserCommunityCreateOrConnectWithoutUserInput[]
    createMany?: UserCommunityCreateManyUserInputEnvelope
    connect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type SettingUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SettingCreateWithoutUsersInput, SettingUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SettingCreateOrConnectWithoutUsersInput
    upsert?: SettingUpsertWithoutUsersInput
    connect?: SettingWhereUniqueInput
    update?: XOR<XOR<SettingUpdateToOneWithWhereWithoutUsersInput, SettingUpdateWithoutUsersInput>, SettingUncheckedUpdateWithoutUsersInput>
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PostLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput> | PostLikeCreateWithoutUserInput[] | PostLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutUserInput | PostLikeCreateOrConnectWithoutUserInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutUserInput | PostLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostLikeCreateManyUserInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutUserInput | PostLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutUserInput | PostLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type QuestionUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput> | QuestionCreateWithoutUserInput[] | QuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutUserInput | QuestionCreateOrConnectWithoutUserInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutUserInput | QuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionCreateManyUserInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutUserInput | QuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutUserInput | QuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type AnswerUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnswerCreateWithoutUserInput, AnswerUncheckedCreateWithoutUserInput> | AnswerCreateWithoutUserInput[] | AnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutUserInput | AnswerCreateOrConnectWithoutUserInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutUserInput | AnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnswerCreateManyUserInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutUserInput | AnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutUserInput | AnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type SubscribeUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscribeCreateWithoutUserInput, SubscribeUncheckedCreateWithoutUserInput> | SubscribeCreateWithoutUserInput[] | SubscribeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscribeCreateOrConnectWithoutUserInput | SubscribeCreateOrConnectWithoutUserInput[]
    upsert?: SubscribeUpsertWithWhereUniqueWithoutUserInput | SubscribeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscribeCreateManyUserInputEnvelope
    set?: SubscribeWhereUniqueInput | SubscribeWhereUniqueInput[]
    disconnect?: SubscribeWhereUniqueInput | SubscribeWhereUniqueInput[]
    delete?: SubscribeWhereUniqueInput | SubscribeWhereUniqueInput[]
    connect?: SubscribeWhereUniqueInput | SubscribeWhereUniqueInput[]
    update?: SubscribeUpdateWithWhereUniqueWithoutUserInput | SubscribeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscribeUpdateManyWithWhereWithoutUserInput | SubscribeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscribeScalarWhereInput | SubscribeScalarWhereInput[]
  }

  export type ViewingRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewingRecordCreateWithoutUserInput, ViewingRecordUncheckedCreateWithoutUserInput> | ViewingRecordCreateWithoutUserInput[] | ViewingRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewingRecordCreateOrConnectWithoutUserInput | ViewingRecordCreateOrConnectWithoutUserInput[]
    upsert?: ViewingRecordUpsertWithWhereUniqueWithoutUserInput | ViewingRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewingRecordCreateManyUserInputEnvelope
    set?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    disconnect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    delete?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    connect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    update?: ViewingRecordUpdateWithWhereUniqueWithoutUserInput | ViewingRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewingRecordUpdateManyWithWhereWithoutUserInput | ViewingRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewingRecordScalarWhereInput | ViewingRecordScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type MultiProfileUpdateManyWithoutUserNestedInput = {
    create?: XOR<MultiProfileCreateWithoutUserInput, MultiProfileUncheckedCreateWithoutUserInput> | MultiProfileCreateWithoutUserInput[] | MultiProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiProfileCreateOrConnectWithoutUserInput | MultiProfileCreateOrConnectWithoutUserInput[]
    upsert?: MultiProfileUpsertWithWhereUniqueWithoutUserInput | MultiProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MultiProfileCreateManyUserInputEnvelope
    set?: MultiProfileWhereUniqueInput | MultiProfileWhereUniqueInput[]
    disconnect?: MultiProfileWhereUniqueInput | MultiProfileWhereUniqueInput[]
    delete?: MultiProfileWhereUniqueInput | MultiProfileWhereUniqueInput[]
    connect?: MultiProfileWhereUniqueInput | MultiProfileWhereUniqueInput[]
    update?: MultiProfileUpdateWithWhereUniqueWithoutUserInput | MultiProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MultiProfileUpdateManyWithWhereWithoutUserInput | MultiProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MultiProfileScalarWhereInput | MultiProfileScalarWhereInput[]
  }

  export type UserCommunityUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCommunityCreateWithoutUserInput, UserCommunityUncheckedCreateWithoutUserInput> | UserCommunityCreateWithoutUserInput[] | UserCommunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCommunityCreateOrConnectWithoutUserInput | UserCommunityCreateOrConnectWithoutUserInput[]
    upsert?: UserCommunityUpsertWithWhereUniqueWithoutUserInput | UserCommunityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCommunityCreateManyUserInputEnvelope
    set?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    disconnect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    delete?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    connect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    update?: UserCommunityUpdateWithWhereUniqueWithoutUserInput | UserCommunityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCommunityUpdateManyWithWhereWithoutUserInput | UserCommunityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCommunityScalarWhereInput | UserCommunityScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PostLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput> | PostLikeCreateWithoutUserInput[] | PostLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutUserInput | PostLikeCreateOrConnectWithoutUserInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutUserInput | PostLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostLikeCreateManyUserInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutUserInput | PostLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutUserInput | PostLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput> | QuestionCreateWithoutUserInput[] | QuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutUserInput | QuestionCreateOrConnectWithoutUserInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutUserInput | QuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionCreateManyUserInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutUserInput | QuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutUserInput | QuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type AnswerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnswerCreateWithoutUserInput, AnswerUncheckedCreateWithoutUserInput> | AnswerCreateWithoutUserInput[] | AnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutUserInput | AnswerCreateOrConnectWithoutUserInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutUserInput | AnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnswerCreateManyUserInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutUserInput | AnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutUserInput | AnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type SubscribeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscribeCreateWithoutUserInput, SubscribeUncheckedCreateWithoutUserInput> | SubscribeCreateWithoutUserInput[] | SubscribeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscribeCreateOrConnectWithoutUserInput | SubscribeCreateOrConnectWithoutUserInput[]
    upsert?: SubscribeUpsertWithWhereUniqueWithoutUserInput | SubscribeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscribeCreateManyUserInputEnvelope
    set?: SubscribeWhereUniqueInput | SubscribeWhereUniqueInput[]
    disconnect?: SubscribeWhereUniqueInput | SubscribeWhereUniqueInput[]
    delete?: SubscribeWhereUniqueInput | SubscribeWhereUniqueInput[]
    connect?: SubscribeWhereUniqueInput | SubscribeWhereUniqueInput[]
    update?: SubscribeUpdateWithWhereUniqueWithoutUserInput | SubscribeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscribeUpdateManyWithWhereWithoutUserInput | SubscribeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscribeScalarWhereInput | SubscribeScalarWhereInput[]
  }

  export type ViewingRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewingRecordCreateWithoutUserInput, ViewingRecordUncheckedCreateWithoutUserInput> | ViewingRecordCreateWithoutUserInput[] | ViewingRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewingRecordCreateOrConnectWithoutUserInput | ViewingRecordCreateOrConnectWithoutUserInput[]
    upsert?: ViewingRecordUpsertWithWhereUniqueWithoutUserInput | ViewingRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewingRecordCreateManyUserInputEnvelope
    set?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    disconnect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    delete?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    connect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    update?: ViewingRecordUpdateWithWhereUniqueWithoutUserInput | ViewingRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewingRecordUpdateManyWithWhereWithoutUserInput | ViewingRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewingRecordScalarWhereInput | ViewingRecordScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type MultiProfileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MultiProfileCreateWithoutUserInput, MultiProfileUncheckedCreateWithoutUserInput> | MultiProfileCreateWithoutUserInput[] | MultiProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiProfileCreateOrConnectWithoutUserInput | MultiProfileCreateOrConnectWithoutUserInput[]
    upsert?: MultiProfileUpsertWithWhereUniqueWithoutUserInput | MultiProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MultiProfileCreateManyUserInputEnvelope
    set?: MultiProfileWhereUniqueInput | MultiProfileWhereUniqueInput[]
    disconnect?: MultiProfileWhereUniqueInput | MultiProfileWhereUniqueInput[]
    delete?: MultiProfileWhereUniqueInput | MultiProfileWhereUniqueInput[]
    connect?: MultiProfileWhereUniqueInput | MultiProfileWhereUniqueInput[]
    update?: MultiProfileUpdateWithWhereUniqueWithoutUserInput | MultiProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MultiProfileUpdateManyWithWhereWithoutUserInput | MultiProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MultiProfileScalarWhereInput | MultiProfileScalarWhereInput[]
  }

  export type UserCommunityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCommunityCreateWithoutUserInput, UserCommunityUncheckedCreateWithoutUserInput> | UserCommunityCreateWithoutUserInput[] | UserCommunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCommunityCreateOrConnectWithoutUserInput | UserCommunityCreateOrConnectWithoutUserInput[]
    upsert?: UserCommunityUpsertWithWhereUniqueWithoutUserInput | UserCommunityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCommunityCreateManyUserInputEnvelope
    set?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    disconnect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    delete?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    connect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    update?: UserCommunityUpdateWithWhereUniqueWithoutUserInput | UserCommunityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCommunityUpdateManyWithWhereWithoutUserInput | UserCommunityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCommunityScalarWhereInput | UserCommunityScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type ActorCreateNestedOneWithoutPostsInput = {
    create?: XOR<ActorCreateWithoutPostsInput, ActorUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ActorCreateOrConnectWithoutPostsInput
    connect?: ActorWhereUniqueInput
  }

  export type SettingCreateNestedOneWithoutPostsInput = {
    create?: XOR<SettingCreateWithoutPostsInput, SettingUncheckedCreateWithoutPostsInput>
    connectOrCreate?: SettingCreateOrConnectWithoutPostsInput
    connect?: SettingWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostLikeCreateNestedManyWithoutPostInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type ImageCreateNestedManyWithoutPostInput = {
    create?: XOR<ImageCreateWithoutPostInput, ImageUncheckedCreateWithoutPostInput> | ImageCreateWithoutPostInput[] | ImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutPostInput | ImageCreateOrConnectWithoutPostInput[]
    createMany?: ImageCreateManyPostInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutPostInput = {
    create?: XOR<ReviewCreateWithoutPostInput, ReviewUncheckedCreateWithoutPostInput> | ReviewCreateWithoutPostInput[] | ReviewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutPostInput | ReviewCreateOrConnectWithoutPostInput[]
    createMany?: ReviewCreateManyPostInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutPostsInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput> | TagCreateWithoutPostsInput[] | TagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput | TagCreateOrConnectWithoutPostsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostLikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ImageCreateWithoutPostInput, ImageUncheckedCreateWithoutPostInput> | ImageCreateWithoutPostInput[] | ImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutPostInput | ImageCreateOrConnectWithoutPostInput[]
    createMany?: ImageCreateManyPostInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ReviewCreateWithoutPostInput, ReviewUncheckedCreateWithoutPostInput> | ReviewCreateWithoutPostInput[] | ReviewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutPostInput | ReviewCreateOrConnectWithoutPostInput[]
    createMany?: ReviewCreateManyPostInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput> | TagCreateWithoutPostsInput[] | TagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput | TagCreateOrConnectWithoutPostsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumImageOrVideoFieldUpdateOperationsInput = {
    set?: $Enums.ImageOrVideo | null
  }

  export type NullableEnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category | null
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type ActorUpdateOneWithoutPostsNestedInput = {
    create?: XOR<ActorCreateWithoutPostsInput, ActorUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ActorCreateOrConnectWithoutPostsInput
    upsert?: ActorUpsertWithoutPostsInput
    disconnect?: ActorWhereInput | boolean
    delete?: ActorWhereInput | boolean
    connect?: ActorWhereUniqueInput
    update?: XOR<XOR<ActorUpdateToOneWithWhereWithoutPostsInput, ActorUpdateWithoutPostsInput>, ActorUncheckedUpdateWithoutPostsInput>
  }

  export type SettingUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<SettingCreateWithoutPostsInput, SettingUncheckedCreateWithoutPostsInput>
    connectOrCreate?: SettingCreateOrConnectWithoutPostsInput
    upsert?: SettingUpsertWithoutPostsInput
    connect?: SettingWhereUniqueInput
    update?: XOR<XOR<SettingUpdateToOneWithWhereWithoutPostsInput, SettingUpdateWithoutPostsInput>, SettingUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostLikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutPostInput | PostLikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutPostInput | PostLikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutPostInput | PostLikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type ImageUpdateManyWithoutPostNestedInput = {
    create?: XOR<ImageCreateWithoutPostInput, ImageUncheckedCreateWithoutPostInput> | ImageCreateWithoutPostInput[] | ImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutPostInput | ImageCreateOrConnectWithoutPostInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutPostInput | ImageUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ImageCreateManyPostInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutPostInput | ImageUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutPostInput | ImageUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReviewCreateWithoutPostInput, ReviewUncheckedCreateWithoutPostInput> | ReviewCreateWithoutPostInput[] | ReviewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutPostInput | ReviewCreateOrConnectWithoutPostInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutPostInput | ReviewUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReviewCreateManyPostInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutPostInput | ReviewUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutPostInput | ReviewUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type TagUpdateManyWithoutPostsNestedInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput> | TagCreateWithoutPostsInput[] | TagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput | TagCreateOrConnectWithoutPostsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutPostsInput | TagUpsertWithWhereUniqueWithoutPostsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutPostsInput | TagUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutPostsInput | TagUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostLikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutPostInput | PostLikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutPostInput | PostLikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutPostInput | PostLikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ImageCreateWithoutPostInput, ImageUncheckedCreateWithoutPostInput> | ImageCreateWithoutPostInput[] | ImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutPostInput | ImageCreateOrConnectWithoutPostInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutPostInput | ImageUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ImageCreateManyPostInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutPostInput | ImageUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutPostInput | ImageUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReviewCreateWithoutPostInput, ReviewUncheckedCreateWithoutPostInput> | ReviewCreateWithoutPostInput[] | ReviewUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutPostInput | ReviewCreateOrConnectWithoutPostInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutPostInput | ReviewUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReviewCreateManyPostInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutPostInput | ReviewUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutPostInput | ReviewUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput> | TagCreateWithoutPostsInput[] | TagUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput | TagCreateOrConnectWithoutPostsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutPostsInput | TagUpsertWithWhereUniqueWithoutPostsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutPostsInput | TagUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutPostsInput | TagUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutReviewsInput = {
    create?: XOR<PostCreateWithoutReviewsInput, PostUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReviewsInput
    connect?: PostWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type PostUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<PostCreateWithoutReviewsInput, PostUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReviewsInput
    upsert?: PostUpsertWithoutReviewsInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutReviewsInput, PostUpdateWithoutReviewsInput>, PostUncheckedUpdateWithoutReviewsInput>
  }

  export type PostCreateNestedManyWithoutActorInput = {
    create?: XOR<PostCreateWithoutActorInput, PostUncheckedCreateWithoutActorInput> | PostCreateWithoutActorInput[] | PostUncheckedCreateWithoutActorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutActorInput | PostCreateOrConnectWithoutActorInput[]
    createMany?: PostCreateManyActorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CastingCreateNestedManyWithoutActorInput = {
    create?: XOR<CastingCreateWithoutActorInput, CastingUncheckedCreateWithoutActorInput> | CastingCreateWithoutActorInput[] | CastingUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CastingCreateOrConnectWithoutActorInput | CastingCreateOrConnectWithoutActorInput[]
    createMany?: CastingCreateManyActorInputEnvelope
    connect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<PostCreateWithoutActorInput, PostUncheckedCreateWithoutActorInput> | PostCreateWithoutActorInput[] | PostUncheckedCreateWithoutActorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutActorInput | PostCreateOrConnectWithoutActorInput[]
    createMany?: PostCreateManyActorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CastingUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<CastingCreateWithoutActorInput, CastingUncheckedCreateWithoutActorInput> | CastingCreateWithoutActorInput[] | CastingUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CastingCreateOrConnectWithoutActorInput | CastingCreateOrConnectWithoutActorInput[]
    createMany?: CastingCreateManyActorInputEnvelope
    connect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
  }

  export type PostUpdateManyWithoutActorNestedInput = {
    create?: XOR<PostCreateWithoutActorInput, PostUncheckedCreateWithoutActorInput> | PostCreateWithoutActorInput[] | PostUncheckedCreateWithoutActorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutActorInput | PostCreateOrConnectWithoutActorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutActorInput | PostUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: PostCreateManyActorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutActorInput | PostUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutActorInput | PostUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CastingUpdateManyWithoutActorNestedInput = {
    create?: XOR<CastingCreateWithoutActorInput, CastingUncheckedCreateWithoutActorInput> | CastingCreateWithoutActorInput[] | CastingUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CastingCreateOrConnectWithoutActorInput | CastingCreateOrConnectWithoutActorInput[]
    upsert?: CastingUpsertWithWhereUniqueWithoutActorInput | CastingUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: CastingCreateManyActorInputEnvelope
    set?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    disconnect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    delete?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    connect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    update?: CastingUpdateWithWhereUniqueWithoutActorInput | CastingUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: CastingUpdateManyWithWhereWithoutActorInput | CastingUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: CastingScalarWhereInput | CastingScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<PostCreateWithoutActorInput, PostUncheckedCreateWithoutActorInput> | PostCreateWithoutActorInput[] | PostUncheckedCreateWithoutActorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutActorInput | PostCreateOrConnectWithoutActorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutActorInput | PostUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: PostCreateManyActorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutActorInput | PostUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutActorInput | PostUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CastingUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<CastingCreateWithoutActorInput, CastingUncheckedCreateWithoutActorInput> | CastingCreateWithoutActorInput[] | CastingUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CastingCreateOrConnectWithoutActorInput | CastingCreateOrConnectWithoutActorInput[]
    upsert?: CastingUpsertWithWhereUniqueWithoutActorInput | CastingUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: CastingCreateManyActorInputEnvelope
    set?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    disconnect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    delete?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    connect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    update?: CastingUpdateWithWhereUniqueWithoutActorInput | CastingUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: CastingUpdateManyWithWhereWithoutActorInput | CastingUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: CastingScalarWhereInput | CastingScalarWhereInput[]
  }

  export type TheaterCreateNestedOneWithoutMusicalsInput = {
    create?: XOR<TheaterCreateWithoutMusicalsInput, TheaterUncheckedCreateWithoutMusicalsInput>
    connectOrCreate?: TheaterCreateOrConnectWithoutMusicalsInput
    connect?: TheaterWhereUniqueInput
  }

  export type CastingCreateNestedManyWithoutMusicalInput = {
    create?: XOR<CastingCreateWithoutMusicalInput, CastingUncheckedCreateWithoutMusicalInput> | CastingCreateWithoutMusicalInput[] | CastingUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: CastingCreateOrConnectWithoutMusicalInput | CastingCreateOrConnectWithoutMusicalInput[]
    createMany?: CastingCreateManyMusicalInputEnvelope
    connect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
  }

  export type ViewingRecordCreateNestedManyWithoutMusicalInput = {
    create?: XOR<ViewingRecordCreateWithoutMusicalInput, ViewingRecordUncheckedCreateWithoutMusicalInput> | ViewingRecordCreateWithoutMusicalInput[] | ViewingRecordUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: ViewingRecordCreateOrConnectWithoutMusicalInput | ViewingRecordCreateOrConnectWithoutMusicalInput[]
    createMany?: ViewingRecordCreateManyMusicalInputEnvelope
    connect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
  }

  export type MusicalCommunityCreateNestedManyWithoutMusicalInput = {
    create?: XOR<MusicalCommunityCreateWithoutMusicalInput, MusicalCommunityUncheckedCreateWithoutMusicalInput> | MusicalCommunityCreateWithoutMusicalInput[] | MusicalCommunityUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: MusicalCommunityCreateOrConnectWithoutMusicalInput | MusicalCommunityCreateOrConnectWithoutMusicalInput[]
    createMany?: MusicalCommunityCreateManyMusicalInputEnvelope
    connect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
  }

  export type CastingUncheckedCreateNestedManyWithoutMusicalInput = {
    create?: XOR<CastingCreateWithoutMusicalInput, CastingUncheckedCreateWithoutMusicalInput> | CastingCreateWithoutMusicalInput[] | CastingUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: CastingCreateOrConnectWithoutMusicalInput | CastingCreateOrConnectWithoutMusicalInput[]
    createMany?: CastingCreateManyMusicalInputEnvelope
    connect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
  }

  export type ViewingRecordUncheckedCreateNestedManyWithoutMusicalInput = {
    create?: XOR<ViewingRecordCreateWithoutMusicalInput, ViewingRecordUncheckedCreateWithoutMusicalInput> | ViewingRecordCreateWithoutMusicalInput[] | ViewingRecordUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: ViewingRecordCreateOrConnectWithoutMusicalInput | ViewingRecordCreateOrConnectWithoutMusicalInput[]
    createMany?: ViewingRecordCreateManyMusicalInputEnvelope
    connect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
  }

  export type MusicalCommunityUncheckedCreateNestedManyWithoutMusicalInput = {
    create?: XOR<MusicalCommunityCreateWithoutMusicalInput, MusicalCommunityUncheckedCreateWithoutMusicalInput> | MusicalCommunityCreateWithoutMusicalInput[] | MusicalCommunityUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: MusicalCommunityCreateOrConnectWithoutMusicalInput | MusicalCommunityCreateOrConnectWithoutMusicalInput[]
    createMany?: MusicalCommunityCreateManyMusicalInputEnvelope
    connect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
  }

  export type TheaterUpdateOneRequiredWithoutMusicalsNestedInput = {
    create?: XOR<TheaterCreateWithoutMusicalsInput, TheaterUncheckedCreateWithoutMusicalsInput>
    connectOrCreate?: TheaterCreateOrConnectWithoutMusicalsInput
    upsert?: TheaterUpsertWithoutMusicalsInput
    connect?: TheaterWhereUniqueInput
    update?: XOR<XOR<TheaterUpdateToOneWithWhereWithoutMusicalsInput, TheaterUpdateWithoutMusicalsInput>, TheaterUncheckedUpdateWithoutMusicalsInput>
  }

  export type CastingUpdateManyWithoutMusicalNestedInput = {
    create?: XOR<CastingCreateWithoutMusicalInput, CastingUncheckedCreateWithoutMusicalInput> | CastingCreateWithoutMusicalInput[] | CastingUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: CastingCreateOrConnectWithoutMusicalInput | CastingCreateOrConnectWithoutMusicalInput[]
    upsert?: CastingUpsertWithWhereUniqueWithoutMusicalInput | CastingUpsertWithWhereUniqueWithoutMusicalInput[]
    createMany?: CastingCreateManyMusicalInputEnvelope
    set?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    disconnect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    delete?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    connect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    update?: CastingUpdateWithWhereUniqueWithoutMusicalInput | CastingUpdateWithWhereUniqueWithoutMusicalInput[]
    updateMany?: CastingUpdateManyWithWhereWithoutMusicalInput | CastingUpdateManyWithWhereWithoutMusicalInput[]
    deleteMany?: CastingScalarWhereInput | CastingScalarWhereInput[]
  }

  export type ViewingRecordUpdateManyWithoutMusicalNestedInput = {
    create?: XOR<ViewingRecordCreateWithoutMusicalInput, ViewingRecordUncheckedCreateWithoutMusicalInput> | ViewingRecordCreateWithoutMusicalInput[] | ViewingRecordUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: ViewingRecordCreateOrConnectWithoutMusicalInput | ViewingRecordCreateOrConnectWithoutMusicalInput[]
    upsert?: ViewingRecordUpsertWithWhereUniqueWithoutMusicalInput | ViewingRecordUpsertWithWhereUniqueWithoutMusicalInput[]
    createMany?: ViewingRecordCreateManyMusicalInputEnvelope
    set?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    disconnect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    delete?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    connect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    update?: ViewingRecordUpdateWithWhereUniqueWithoutMusicalInput | ViewingRecordUpdateWithWhereUniqueWithoutMusicalInput[]
    updateMany?: ViewingRecordUpdateManyWithWhereWithoutMusicalInput | ViewingRecordUpdateManyWithWhereWithoutMusicalInput[]
    deleteMany?: ViewingRecordScalarWhereInput | ViewingRecordScalarWhereInput[]
  }

  export type MusicalCommunityUpdateManyWithoutMusicalNestedInput = {
    create?: XOR<MusicalCommunityCreateWithoutMusicalInput, MusicalCommunityUncheckedCreateWithoutMusicalInput> | MusicalCommunityCreateWithoutMusicalInput[] | MusicalCommunityUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: MusicalCommunityCreateOrConnectWithoutMusicalInput | MusicalCommunityCreateOrConnectWithoutMusicalInput[]
    upsert?: MusicalCommunityUpsertWithWhereUniqueWithoutMusicalInput | MusicalCommunityUpsertWithWhereUniqueWithoutMusicalInput[]
    createMany?: MusicalCommunityCreateManyMusicalInputEnvelope
    set?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    disconnect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    delete?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    connect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    update?: MusicalCommunityUpdateWithWhereUniqueWithoutMusicalInput | MusicalCommunityUpdateWithWhereUniqueWithoutMusicalInput[]
    updateMany?: MusicalCommunityUpdateManyWithWhereWithoutMusicalInput | MusicalCommunityUpdateManyWithWhereWithoutMusicalInput[]
    deleteMany?: MusicalCommunityScalarWhereInput | MusicalCommunityScalarWhereInput[]
  }

  export type CastingUncheckedUpdateManyWithoutMusicalNestedInput = {
    create?: XOR<CastingCreateWithoutMusicalInput, CastingUncheckedCreateWithoutMusicalInput> | CastingCreateWithoutMusicalInput[] | CastingUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: CastingCreateOrConnectWithoutMusicalInput | CastingCreateOrConnectWithoutMusicalInput[]
    upsert?: CastingUpsertWithWhereUniqueWithoutMusicalInput | CastingUpsertWithWhereUniqueWithoutMusicalInput[]
    createMany?: CastingCreateManyMusicalInputEnvelope
    set?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    disconnect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    delete?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    connect?: CastingWhereUniqueInput | CastingWhereUniqueInput[]
    update?: CastingUpdateWithWhereUniqueWithoutMusicalInput | CastingUpdateWithWhereUniqueWithoutMusicalInput[]
    updateMany?: CastingUpdateManyWithWhereWithoutMusicalInput | CastingUpdateManyWithWhereWithoutMusicalInput[]
    deleteMany?: CastingScalarWhereInput | CastingScalarWhereInput[]
  }

  export type ViewingRecordUncheckedUpdateManyWithoutMusicalNestedInput = {
    create?: XOR<ViewingRecordCreateWithoutMusicalInput, ViewingRecordUncheckedCreateWithoutMusicalInput> | ViewingRecordCreateWithoutMusicalInput[] | ViewingRecordUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: ViewingRecordCreateOrConnectWithoutMusicalInput | ViewingRecordCreateOrConnectWithoutMusicalInput[]
    upsert?: ViewingRecordUpsertWithWhereUniqueWithoutMusicalInput | ViewingRecordUpsertWithWhereUniqueWithoutMusicalInput[]
    createMany?: ViewingRecordCreateManyMusicalInputEnvelope
    set?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    disconnect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    delete?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    connect?: ViewingRecordWhereUniqueInput | ViewingRecordWhereUniqueInput[]
    update?: ViewingRecordUpdateWithWhereUniqueWithoutMusicalInput | ViewingRecordUpdateWithWhereUniqueWithoutMusicalInput[]
    updateMany?: ViewingRecordUpdateManyWithWhereWithoutMusicalInput | ViewingRecordUpdateManyWithWhereWithoutMusicalInput[]
    deleteMany?: ViewingRecordScalarWhereInput | ViewingRecordScalarWhereInput[]
  }

  export type MusicalCommunityUncheckedUpdateManyWithoutMusicalNestedInput = {
    create?: XOR<MusicalCommunityCreateWithoutMusicalInput, MusicalCommunityUncheckedCreateWithoutMusicalInput> | MusicalCommunityCreateWithoutMusicalInput[] | MusicalCommunityUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: MusicalCommunityCreateOrConnectWithoutMusicalInput | MusicalCommunityCreateOrConnectWithoutMusicalInput[]
    upsert?: MusicalCommunityUpsertWithWhereUniqueWithoutMusicalInput | MusicalCommunityUpsertWithWhereUniqueWithoutMusicalInput[]
    createMany?: MusicalCommunityCreateManyMusicalInputEnvelope
    set?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    disconnect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    delete?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    connect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    update?: MusicalCommunityUpdateWithWhereUniqueWithoutMusicalInput | MusicalCommunityUpdateWithWhereUniqueWithoutMusicalInput[]
    updateMany?: MusicalCommunityUpdateManyWithWhereWithoutMusicalInput | MusicalCommunityUpdateManyWithWhereWithoutMusicalInput[]
    deleteMany?: MusicalCommunityScalarWhereInput | MusicalCommunityScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutTheatersInput = {
    create?: XOR<RegionCreateWithoutTheatersInput, RegionUncheckedCreateWithoutTheatersInput>
    connectOrCreate?: RegionCreateOrConnectWithoutTheatersInput
    connect?: RegionWhereUniqueInput
  }

  export type MusicalCreateNestedManyWithoutTheaterInput = {
    create?: XOR<MusicalCreateWithoutTheaterInput, MusicalUncheckedCreateWithoutTheaterInput> | MusicalCreateWithoutTheaterInput[] | MusicalUncheckedCreateWithoutTheaterInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutTheaterInput | MusicalCreateOrConnectWithoutTheaterInput[]
    createMany?: MusicalCreateManyTheaterInputEnvelope
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
  }

  export type SeatCreateNestedManyWithoutTheaterInput = {
    create?: XOR<SeatCreateWithoutTheaterInput, SeatUncheckedCreateWithoutTheaterInput> | SeatCreateWithoutTheaterInput[] | SeatUncheckedCreateWithoutTheaterInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutTheaterInput | SeatCreateOrConnectWithoutTheaterInput[]
    createMany?: SeatCreateManyTheaterInputEnvelope
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
  }

  export type MusicalUncheckedCreateNestedManyWithoutTheaterInput = {
    create?: XOR<MusicalCreateWithoutTheaterInput, MusicalUncheckedCreateWithoutTheaterInput> | MusicalCreateWithoutTheaterInput[] | MusicalUncheckedCreateWithoutTheaterInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutTheaterInput | MusicalCreateOrConnectWithoutTheaterInput[]
    createMany?: MusicalCreateManyTheaterInputEnvelope
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
  }

  export type SeatUncheckedCreateNestedManyWithoutTheaterInput = {
    create?: XOR<SeatCreateWithoutTheaterInput, SeatUncheckedCreateWithoutTheaterInput> | SeatCreateWithoutTheaterInput[] | SeatUncheckedCreateWithoutTheaterInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutTheaterInput | SeatCreateOrConnectWithoutTheaterInput[]
    createMany?: SeatCreateManyTheaterInputEnvelope
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
  }

  export type RegionUpdateOneRequiredWithoutTheatersNestedInput = {
    create?: XOR<RegionCreateWithoutTheatersInput, RegionUncheckedCreateWithoutTheatersInput>
    connectOrCreate?: RegionCreateOrConnectWithoutTheatersInput
    upsert?: RegionUpsertWithoutTheatersInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutTheatersInput, RegionUpdateWithoutTheatersInput>, RegionUncheckedUpdateWithoutTheatersInput>
  }

  export type MusicalUpdateManyWithoutTheaterNestedInput = {
    create?: XOR<MusicalCreateWithoutTheaterInput, MusicalUncheckedCreateWithoutTheaterInput> | MusicalCreateWithoutTheaterInput[] | MusicalUncheckedCreateWithoutTheaterInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutTheaterInput | MusicalCreateOrConnectWithoutTheaterInput[]
    upsert?: MusicalUpsertWithWhereUniqueWithoutTheaterInput | MusicalUpsertWithWhereUniqueWithoutTheaterInput[]
    createMany?: MusicalCreateManyTheaterInputEnvelope
    set?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    disconnect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    delete?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    update?: MusicalUpdateWithWhereUniqueWithoutTheaterInput | MusicalUpdateWithWhereUniqueWithoutTheaterInput[]
    updateMany?: MusicalUpdateManyWithWhereWithoutTheaterInput | MusicalUpdateManyWithWhereWithoutTheaterInput[]
    deleteMany?: MusicalScalarWhereInput | MusicalScalarWhereInput[]
  }

  export type SeatUpdateManyWithoutTheaterNestedInput = {
    create?: XOR<SeatCreateWithoutTheaterInput, SeatUncheckedCreateWithoutTheaterInput> | SeatCreateWithoutTheaterInput[] | SeatUncheckedCreateWithoutTheaterInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutTheaterInput | SeatCreateOrConnectWithoutTheaterInput[]
    upsert?: SeatUpsertWithWhereUniqueWithoutTheaterInput | SeatUpsertWithWhereUniqueWithoutTheaterInput[]
    createMany?: SeatCreateManyTheaterInputEnvelope
    set?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    disconnect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    delete?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    update?: SeatUpdateWithWhereUniqueWithoutTheaterInput | SeatUpdateWithWhereUniqueWithoutTheaterInput[]
    updateMany?: SeatUpdateManyWithWhereWithoutTheaterInput | SeatUpdateManyWithWhereWithoutTheaterInput[]
    deleteMany?: SeatScalarWhereInput | SeatScalarWhereInput[]
  }

  export type MusicalUncheckedUpdateManyWithoutTheaterNestedInput = {
    create?: XOR<MusicalCreateWithoutTheaterInput, MusicalUncheckedCreateWithoutTheaterInput> | MusicalCreateWithoutTheaterInput[] | MusicalUncheckedCreateWithoutTheaterInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutTheaterInput | MusicalCreateOrConnectWithoutTheaterInput[]
    upsert?: MusicalUpsertWithWhereUniqueWithoutTheaterInput | MusicalUpsertWithWhereUniqueWithoutTheaterInput[]
    createMany?: MusicalCreateManyTheaterInputEnvelope
    set?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    disconnect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    delete?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    update?: MusicalUpdateWithWhereUniqueWithoutTheaterInput | MusicalUpdateWithWhereUniqueWithoutTheaterInput[]
    updateMany?: MusicalUpdateManyWithWhereWithoutTheaterInput | MusicalUpdateManyWithWhereWithoutTheaterInput[]
    deleteMany?: MusicalScalarWhereInput | MusicalScalarWhereInput[]
  }

  export type SeatUncheckedUpdateManyWithoutTheaterNestedInput = {
    create?: XOR<SeatCreateWithoutTheaterInput, SeatUncheckedCreateWithoutTheaterInput> | SeatCreateWithoutTheaterInput[] | SeatUncheckedCreateWithoutTheaterInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutTheaterInput | SeatCreateOrConnectWithoutTheaterInput[]
    upsert?: SeatUpsertWithWhereUniqueWithoutTheaterInput | SeatUpsertWithWhereUniqueWithoutTheaterInput[]
    createMany?: SeatCreateManyTheaterInputEnvelope
    set?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    disconnect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    delete?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    update?: SeatUpdateWithWhereUniqueWithoutTheaterInput | SeatUpdateWithWhereUniqueWithoutTheaterInput[]
    updateMany?: SeatUpdateManyWithWhereWithoutTheaterInput | SeatUpdateManyWithWhereWithoutTheaterInput[]
    deleteMany?: SeatScalarWhereInput | SeatScalarWhereInput[]
  }

  export type TheaterCreateNestedOneWithoutSeatsInput = {
    create?: XOR<TheaterCreateWithoutSeatsInput, TheaterUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: TheaterCreateOrConnectWithoutSeatsInput
    connect?: TheaterWhereUniqueInput
  }

  export type TheaterUpdateOneRequiredWithoutSeatsNestedInput = {
    create?: XOR<TheaterCreateWithoutSeatsInput, TheaterUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: TheaterCreateOrConnectWithoutSeatsInput
    upsert?: TheaterUpsertWithoutSeatsInput
    connect?: TheaterWhereUniqueInput
    update?: XOR<XOR<TheaterUpdateToOneWithWhereWithoutSeatsInput, TheaterUpdateWithoutSeatsInput>, TheaterUncheckedUpdateWithoutSeatsInput>
  }

  export type UserCommunityCreateNestedManyWithoutCommunityInput = {
    create?: XOR<UserCommunityCreateWithoutCommunityInput, UserCommunityUncheckedCreateWithoutCommunityInput> | UserCommunityCreateWithoutCommunityInput[] | UserCommunityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: UserCommunityCreateOrConnectWithoutCommunityInput | UserCommunityCreateOrConnectWithoutCommunityInput[]
    createMany?: UserCommunityCreateManyCommunityInputEnvelope
    connect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
  }

  export type MusicalCommunityCreateNestedManyWithoutCommunityInput = {
    create?: XOR<MusicalCommunityCreateWithoutCommunityInput, MusicalCommunityUncheckedCreateWithoutCommunityInput> | MusicalCommunityCreateWithoutCommunityInput[] | MusicalCommunityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: MusicalCommunityCreateOrConnectWithoutCommunityInput | MusicalCommunityCreateOrConnectWithoutCommunityInput[]
    createMany?: MusicalCommunityCreateManyCommunityInputEnvelope
    connect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
  }

  export type UserCommunityUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<UserCommunityCreateWithoutCommunityInput, UserCommunityUncheckedCreateWithoutCommunityInput> | UserCommunityCreateWithoutCommunityInput[] | UserCommunityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: UserCommunityCreateOrConnectWithoutCommunityInput | UserCommunityCreateOrConnectWithoutCommunityInput[]
    createMany?: UserCommunityCreateManyCommunityInputEnvelope
    connect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
  }

  export type MusicalCommunityUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<MusicalCommunityCreateWithoutCommunityInput, MusicalCommunityUncheckedCreateWithoutCommunityInput> | MusicalCommunityCreateWithoutCommunityInput[] | MusicalCommunityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: MusicalCommunityCreateOrConnectWithoutCommunityInput | MusicalCommunityCreateOrConnectWithoutCommunityInput[]
    createMany?: MusicalCommunityCreateManyCommunityInputEnvelope
    connect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
  }

  export type UserCommunityUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<UserCommunityCreateWithoutCommunityInput, UserCommunityUncheckedCreateWithoutCommunityInput> | UserCommunityCreateWithoutCommunityInput[] | UserCommunityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: UserCommunityCreateOrConnectWithoutCommunityInput | UserCommunityCreateOrConnectWithoutCommunityInput[]
    upsert?: UserCommunityUpsertWithWhereUniqueWithoutCommunityInput | UserCommunityUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: UserCommunityCreateManyCommunityInputEnvelope
    set?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    disconnect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    delete?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    connect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    update?: UserCommunityUpdateWithWhereUniqueWithoutCommunityInput | UserCommunityUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: UserCommunityUpdateManyWithWhereWithoutCommunityInput | UserCommunityUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: UserCommunityScalarWhereInput | UserCommunityScalarWhereInput[]
  }

  export type MusicalCommunityUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<MusicalCommunityCreateWithoutCommunityInput, MusicalCommunityUncheckedCreateWithoutCommunityInput> | MusicalCommunityCreateWithoutCommunityInput[] | MusicalCommunityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: MusicalCommunityCreateOrConnectWithoutCommunityInput | MusicalCommunityCreateOrConnectWithoutCommunityInput[]
    upsert?: MusicalCommunityUpsertWithWhereUniqueWithoutCommunityInput | MusicalCommunityUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: MusicalCommunityCreateManyCommunityInputEnvelope
    set?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    disconnect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    delete?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    connect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    update?: MusicalCommunityUpdateWithWhereUniqueWithoutCommunityInput | MusicalCommunityUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: MusicalCommunityUpdateManyWithWhereWithoutCommunityInput | MusicalCommunityUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: MusicalCommunityScalarWhereInput | MusicalCommunityScalarWhereInput[]
  }

  export type UserCommunityUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<UserCommunityCreateWithoutCommunityInput, UserCommunityUncheckedCreateWithoutCommunityInput> | UserCommunityCreateWithoutCommunityInput[] | UserCommunityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: UserCommunityCreateOrConnectWithoutCommunityInput | UserCommunityCreateOrConnectWithoutCommunityInput[]
    upsert?: UserCommunityUpsertWithWhereUniqueWithoutCommunityInput | UserCommunityUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: UserCommunityCreateManyCommunityInputEnvelope
    set?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    disconnect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    delete?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    connect?: UserCommunityWhereUniqueInput | UserCommunityWhereUniqueInput[]
    update?: UserCommunityUpdateWithWhereUniqueWithoutCommunityInput | UserCommunityUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: UserCommunityUpdateManyWithWhereWithoutCommunityInput | UserCommunityUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: UserCommunityScalarWhereInput | UserCommunityScalarWhereInput[]
  }

  export type MusicalCommunityUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<MusicalCommunityCreateWithoutCommunityInput, MusicalCommunityUncheckedCreateWithoutCommunityInput> | MusicalCommunityCreateWithoutCommunityInput[] | MusicalCommunityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: MusicalCommunityCreateOrConnectWithoutCommunityInput | MusicalCommunityCreateOrConnectWithoutCommunityInput[]
    upsert?: MusicalCommunityUpsertWithWhereUniqueWithoutCommunityInput | MusicalCommunityUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: MusicalCommunityCreateManyCommunityInputEnvelope
    set?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    disconnect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    delete?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    connect?: MusicalCommunityWhereUniqueInput | MusicalCommunityWhereUniqueInput[]
    update?: MusicalCommunityUpdateWithWhereUniqueWithoutCommunityInput | MusicalCommunityUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: MusicalCommunityUpdateManyWithWhereWithoutCommunityInput | MusicalCommunityUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: MusicalCommunityScalarWhereInput | MusicalCommunityScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSettingInput = {
    create?: XOR<UserCreateWithoutSettingInput, UserUncheckedCreateWithoutSettingInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutSettingInput = {
    create?: XOR<PostCreateWithoutSettingInput, PostUncheckedCreateWithoutSettingInput> | PostCreateWithoutSettingInput[] | PostUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSettingInput | PostCreateOrConnectWithoutSettingInput[]
    createMany?: PostCreateManySettingInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutSettingInput = {
    create?: XOR<UserCreateWithoutSettingInput, UserUncheckedCreateWithoutSettingInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingInput
    connect?: UserWhereUniqueInput
  }

  export type PostUncheckedCreateNestedManyWithoutSettingInput = {
    create?: XOR<PostCreateWithoutSettingInput, PostUncheckedCreateWithoutSettingInput> | PostCreateWithoutSettingInput[] | PostUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSettingInput | PostCreateOrConnectWithoutSettingInput[]
    createMany?: PostCreateManySettingInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutSettingNestedInput = {
    create?: XOR<UserCreateWithoutSettingInput, UserUncheckedCreateWithoutSettingInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingInput
    upsert?: UserUpsertWithoutSettingInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingInput, UserUpdateWithoutSettingInput>, UserUncheckedUpdateWithoutSettingInput>
  }

  export type PostUpdateManyWithoutSettingNestedInput = {
    create?: XOR<PostCreateWithoutSettingInput, PostUncheckedCreateWithoutSettingInput> | PostCreateWithoutSettingInput[] | PostUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSettingInput | PostCreateOrConnectWithoutSettingInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutSettingInput | PostUpsertWithWhereUniqueWithoutSettingInput[]
    createMany?: PostCreateManySettingInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutSettingInput | PostUpdateWithWhereUniqueWithoutSettingInput[]
    updateMany?: PostUpdateManyWithWhereWithoutSettingInput | PostUpdateManyWithWhereWithoutSettingInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutSettingNestedInput = {
    create?: XOR<UserCreateWithoutSettingInput, UserUncheckedCreateWithoutSettingInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingInput
    upsert?: UserUpsertWithoutSettingInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingInput, UserUpdateWithoutSettingInput>, UserUncheckedUpdateWithoutSettingInput>
  }

  export type PostUncheckedUpdateManyWithoutSettingNestedInput = {
    create?: XOR<PostCreateWithoutSettingInput, PostUncheckedCreateWithoutSettingInput> | PostCreateWithoutSettingInput[] | PostUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSettingInput | PostCreateOrConnectWithoutSettingInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutSettingInput | PostUpsertWithWhereUniqueWithoutSettingInput[]
    createMany?: PostCreateManySettingInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutSettingInput | PostUpdateWithWhereUniqueWithoutSettingInput[]
    updateMany?: PostUpdateManyWithWhereWithoutSettingInput | PostUpdateManyWithWhereWithoutSettingInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostCreateNestedManyWithoutTagsInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutTagsInput | PostUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutTagsInput | PostUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutTagsInput | PostUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutTagsInput | PostUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutTagsInput | PostUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutTagsInput | PostUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutImagesInput = {
    create?: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PostCreateOrConnectWithoutImagesInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PostCreateOrConnectWithoutImagesInput
    upsert?: PostUpsertWithoutImagesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutImagesInput, PostUpdateWithoutImagesInput>, PostUncheckedUpdateWithoutImagesInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowsInput = {
    create?: XOR<UserCreateWithoutFollowsInput, UserUncheckedCreateWithoutFollowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateOneRequiredWithoutFollowsNestedInput = {
    create?: XOR<UserCreateWithoutFollowsInput, UserUncheckedCreateWithoutFollowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowsInput
    upsert?: UserUpsertWithoutFollowsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowsInput, UserUpdateWithoutFollowsInput>, UserUncheckedUpdateWithoutFollowsInput>
  }

  export type UserCreateNestedOneWithoutViewingsInput = {
    create?: XOR<UserCreateWithoutViewingsInput, UserUncheckedCreateWithoutViewingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewingsInput
    connect?: UserWhereUniqueInput
  }

  export type MusicalCreateNestedOneWithoutViewingsInput = {
    create?: XOR<MusicalCreateWithoutViewingsInput, MusicalUncheckedCreateWithoutViewingsInput>
    connectOrCreate?: MusicalCreateOrConnectWithoutViewingsInput
    connect?: MusicalWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutViewingsNestedInput = {
    create?: XOR<UserCreateWithoutViewingsInput, UserUncheckedCreateWithoutViewingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewingsInput
    upsert?: UserUpsertWithoutViewingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutViewingsInput, UserUpdateWithoutViewingsInput>, UserUncheckedUpdateWithoutViewingsInput>
  }

  export type MusicalUpdateOneRequiredWithoutViewingsNestedInput = {
    create?: XOR<MusicalCreateWithoutViewingsInput, MusicalUncheckedCreateWithoutViewingsInput>
    connectOrCreate?: MusicalCreateOrConnectWithoutViewingsInput
    upsert?: MusicalUpsertWithoutViewingsInput
    connect?: MusicalWhereUniqueInput
    update?: XOR<XOR<MusicalUpdateToOneWithWhereWithoutViewingsInput, MusicalUpdateWithoutViewingsInput>, MusicalUncheckedUpdateWithoutViewingsInput>
  }

  export type PostCreateNestedOneWithoutPostLikesInput = {
    create?: XOR<PostCreateWithoutPostLikesInput, PostUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostLikesInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostLikesInput = {
    create?: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostLikesInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutPostLikesNestedInput = {
    create?: XOR<PostCreateWithoutPostLikesInput, PostUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostLikesInput
    upsert?: PostUpsertWithoutPostLikesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutPostLikesInput, PostUpdateWithoutPostLikesInput>, PostUncheckedUpdateWithoutPostLikesInput>
  }

  export type UserUpdateOneRequiredWithoutPostLikesNestedInput = {
    create?: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostLikesInput
    upsert?: UserUpsertWithoutPostLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostLikesInput, UserUpdateWithoutPostLikesInput>, UserUncheckedUpdateWithoutPostLikesInput>
  }

  export type UserCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type AnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type AnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsInput
    upsert?: UserUpsertWithoutQuestionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuestionsInput, UserUpdateWithoutQuestionsInput>, UserUncheckedUpdateWithoutQuestionsInput>
  }

  export type AnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutQuestionInput | AnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutQuestionInput | AnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutQuestionInput | AnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type AnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutQuestionInput | AnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutQuestionInput | AnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutQuestionInput | AnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type QuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnswersInput = {
    create?: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnswersInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuestionUpsertWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutAnswersInput, QuestionUpdateWithoutAnswersInput>, QuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type UserUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnswersInput
    upsert?: UserUpsertWithoutAnswersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnswersInput, UserUpdateWithoutAnswersInput>, UserUncheckedUpdateWithoutAnswersInput>
  }

  export type TheaterCreateNestedManyWithoutRegionInput = {
    create?: XOR<TheaterCreateWithoutRegionInput, TheaterUncheckedCreateWithoutRegionInput> | TheaterCreateWithoutRegionInput[] | TheaterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: TheaterCreateOrConnectWithoutRegionInput | TheaterCreateOrConnectWithoutRegionInput[]
    createMany?: TheaterCreateManyRegionInputEnvelope
    connect?: TheaterWhereUniqueInput | TheaterWhereUniqueInput[]
  }

  export type TheaterUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<TheaterCreateWithoutRegionInput, TheaterUncheckedCreateWithoutRegionInput> | TheaterCreateWithoutRegionInput[] | TheaterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: TheaterCreateOrConnectWithoutRegionInput | TheaterCreateOrConnectWithoutRegionInput[]
    createMany?: TheaterCreateManyRegionInputEnvelope
    connect?: TheaterWhereUniqueInput | TheaterWhereUniqueInput[]
  }

  export type TheaterUpdateManyWithoutRegionNestedInput = {
    create?: XOR<TheaterCreateWithoutRegionInput, TheaterUncheckedCreateWithoutRegionInput> | TheaterCreateWithoutRegionInput[] | TheaterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: TheaterCreateOrConnectWithoutRegionInput | TheaterCreateOrConnectWithoutRegionInput[]
    upsert?: TheaterUpsertWithWhereUniqueWithoutRegionInput | TheaterUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: TheaterCreateManyRegionInputEnvelope
    set?: TheaterWhereUniqueInput | TheaterWhereUniqueInput[]
    disconnect?: TheaterWhereUniqueInput | TheaterWhereUniqueInput[]
    delete?: TheaterWhereUniqueInput | TheaterWhereUniqueInput[]
    connect?: TheaterWhereUniqueInput | TheaterWhereUniqueInput[]
    update?: TheaterUpdateWithWhereUniqueWithoutRegionInput | TheaterUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: TheaterUpdateManyWithWhereWithoutRegionInput | TheaterUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: TheaterScalarWhereInput | TheaterScalarWhereInput[]
  }

  export type TheaterUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<TheaterCreateWithoutRegionInput, TheaterUncheckedCreateWithoutRegionInput> | TheaterCreateWithoutRegionInput[] | TheaterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: TheaterCreateOrConnectWithoutRegionInput | TheaterCreateOrConnectWithoutRegionInput[]
    upsert?: TheaterUpsertWithWhereUniqueWithoutRegionInput | TheaterUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: TheaterCreateManyRegionInputEnvelope
    set?: TheaterWhereUniqueInput | TheaterWhereUniqueInput[]
    disconnect?: TheaterWhereUniqueInput | TheaterWhereUniqueInput[]
    delete?: TheaterWhereUniqueInput | TheaterWhereUniqueInput[]
    connect?: TheaterWhereUniqueInput | TheaterWhereUniqueInput[]
    update?: TheaterUpdateWithWhereUniqueWithoutRegionInput | TheaterUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: TheaterUpdateManyWithWhereWithoutRegionInput | TheaterUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: TheaterScalarWhereInput | TheaterScalarWhereInput[]
  }

  export type MusicalCreateNestedOneWithoutCastingsInput = {
    create?: XOR<MusicalCreateWithoutCastingsInput, MusicalUncheckedCreateWithoutCastingsInput>
    connectOrCreate?: MusicalCreateOrConnectWithoutCastingsInput
    connect?: MusicalWhereUniqueInput
  }

  export type ActorCreateNestedOneWithoutCastingsInput = {
    create?: XOR<ActorCreateWithoutCastingsInput, ActorUncheckedCreateWithoutCastingsInput>
    connectOrCreate?: ActorCreateOrConnectWithoutCastingsInput
    connect?: ActorWhereUniqueInput
  }

  export type MusicalUpdateOneRequiredWithoutCastingsNestedInput = {
    create?: XOR<MusicalCreateWithoutCastingsInput, MusicalUncheckedCreateWithoutCastingsInput>
    connectOrCreate?: MusicalCreateOrConnectWithoutCastingsInput
    upsert?: MusicalUpsertWithoutCastingsInput
    connect?: MusicalWhereUniqueInput
    update?: XOR<XOR<MusicalUpdateToOneWithWhereWithoutCastingsInput, MusicalUpdateWithoutCastingsInput>, MusicalUncheckedUpdateWithoutCastingsInput>
  }

  export type ActorUpdateOneRequiredWithoutCastingsNestedInput = {
    create?: XOR<ActorCreateWithoutCastingsInput, ActorUncheckedCreateWithoutCastingsInput>
    connectOrCreate?: ActorCreateOrConnectWithoutCastingsInput
    upsert?: ActorUpsertWithoutCastingsInput
    connect?: ActorWhereUniqueInput
    update?: XOR<XOR<ActorUpdateToOneWithWhereWithoutCastingsInput, ActorUpdateWithoutCastingsInput>, ActorUncheckedUpdateWithoutCastingsInput>
  }

  export type UserCreateNestedOneWithoutUserCommunitiesInput = {
    create?: XOR<UserCreateWithoutUserCommunitiesInput, UserUncheckedCreateWithoutUserCommunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCommunitiesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityCreateNestedOneWithoutUserCommunitiesInput = {
    create?: XOR<CommunityCreateWithoutUserCommunitiesInput, CommunityUncheckedCreateWithoutUserCommunitiesInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutUserCommunitiesInput
    connect?: CommunityWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserCommunitiesNestedInput = {
    create?: XOR<UserCreateWithoutUserCommunitiesInput, UserUncheckedCreateWithoutUserCommunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCommunitiesInput
    upsert?: UserUpsertWithoutUserCommunitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserCommunitiesInput, UserUpdateWithoutUserCommunitiesInput>, UserUncheckedUpdateWithoutUserCommunitiesInput>
  }

  export type CommunityUpdateOneRequiredWithoutUserCommunitiesNestedInput = {
    create?: XOR<CommunityCreateWithoutUserCommunitiesInput, CommunityUncheckedCreateWithoutUserCommunitiesInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutUserCommunitiesInput
    upsert?: CommunityUpsertWithoutUserCommunitiesInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutUserCommunitiesInput, CommunityUpdateWithoutUserCommunitiesInput>, CommunityUncheckedUpdateWithoutUserCommunitiesInput>
  }

  export type MusicalCreateNestedOneWithoutCommunitiesInput = {
    create?: XOR<MusicalCreateWithoutCommunitiesInput, MusicalUncheckedCreateWithoutCommunitiesInput>
    connectOrCreate?: MusicalCreateOrConnectWithoutCommunitiesInput
    connect?: MusicalWhereUniqueInput
  }

  export type CommunityCreateNestedOneWithoutMusicalCommunitiesInput = {
    create?: XOR<CommunityCreateWithoutMusicalCommunitiesInput, CommunityUncheckedCreateWithoutMusicalCommunitiesInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutMusicalCommunitiesInput
    connect?: CommunityWhereUniqueInput
  }

  export type MusicalUpdateOneRequiredWithoutCommunitiesNestedInput = {
    create?: XOR<MusicalCreateWithoutCommunitiesInput, MusicalUncheckedCreateWithoutCommunitiesInput>
    connectOrCreate?: MusicalCreateOrConnectWithoutCommunitiesInput
    upsert?: MusicalUpsertWithoutCommunitiesInput
    connect?: MusicalWhereUniqueInput
    update?: XOR<XOR<MusicalUpdateToOneWithWhereWithoutCommunitiesInput, MusicalUpdateWithoutCommunitiesInput>, MusicalUncheckedUpdateWithoutCommunitiesInput>
  }

  export type CommunityUpdateOneRequiredWithoutMusicalCommunitiesNestedInput = {
    create?: XOR<CommunityCreateWithoutMusicalCommunitiesInput, CommunityUncheckedCreateWithoutMusicalCommunitiesInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutMusicalCommunitiesInput
    upsert?: CommunityUpsertWithoutMusicalCommunitiesInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutMusicalCommunitiesInput, CommunityUpdateWithoutMusicalCommunitiesInput>, CommunityUncheckedUpdateWithoutMusicalCommunitiesInput>
  }

  export type UserCreateNestedOneWithoutMultiProfilesInput = {
    create?: XOR<UserCreateWithoutMultiProfilesInput, UserUncheckedCreateWithoutMultiProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMultiProfilesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMultiProfilesNestedInput = {
    create?: XOR<UserCreateWithoutMultiProfilesInput, UserUncheckedCreateWithoutMultiProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMultiProfilesInput
    upsert?: UserUpsertWithoutMultiProfilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMultiProfilesInput, UserUpdateWithoutMultiProfilesInput>, UserUncheckedUpdateWithoutMultiProfilesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumImageOrVideoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageOrVideo | EnumImageOrVideoFieldRefInput<$PrismaModel> | null
    in?: $Enums.ImageOrVideo[] | null
    notIn?: $Enums.ImageOrVideo[] | null
    not?: NestedEnumImageOrVideoNullableFilter<$PrismaModel> | $Enums.ImageOrVideo | null
  }

  export type NestedEnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | null
    notIn?: $Enums.Category[] | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumImageOrVideoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageOrVideo | EnumImageOrVideoFieldRefInput<$PrismaModel> | null
    in?: $Enums.ImageOrVideo[] | null
    notIn?: $Enums.ImageOrVideo[] | null
    not?: NestedEnumImageOrVideoNullableWithAggregatesFilter<$PrismaModel> | $Enums.ImageOrVideo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumImageOrVideoNullableFilter<$PrismaModel>
    _max?: NestedEnumImageOrVideoNullableFilter<$PrismaModel>
  }

  export type NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | null
    notIn?: $Enums.Category[] | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type SettingCreateWithoutUsersInput = {
    useBackground?: boolean | null
    useProfilePhoto?: boolean | null
    allowRepost?: boolean | null
    posts?: PostCreateNestedManyWithoutSettingInput
  }

  export type SettingUncheckedCreateWithoutUsersInput = {
    id?: number
    useBackground?: boolean | null
    useProfilePhoto?: boolean | null
    allowRepost?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutSettingInput
  }

  export type SettingCreateOrConnectWithoutUsersInput = {
    where: SettingWhereUniqueInput
    create: XOR<SettingCreateWithoutUsersInput, SettingUncheckedCreateWithoutUsersInput>
  }

  export type PostCreateWithoutUserInput = {
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    extraField?: string | null
    actor?: ActorCreateNestedOneWithoutPostsInput
    setting: SettingCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postLikes?: PostLikeCreateNestedManyWithoutPostInput
    images?: ImageCreateNestedManyWithoutPostInput
    reviews?: ReviewCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: number
    settingId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    actorId?: number | null
    extraField?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    images?: ImageUncheckedCreateNestedManyWithoutPostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: PostCreateManyUserInput | PostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    settingId: number
    communityId: number
    content?: string | null
    createdAt?: Date | string | null
    anonymous?: boolean | null
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    settingId: number
    communityId: number
    content?: string | null
    createdAt?: Date | string | null
    anonymous?: boolean | null
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    settingId: number
    theaterId: number
    key: number
    content?: string | null
    rating?: number | null
    spoiler?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    liked?: string | null
    likeCount?: number | null
    comment?: string | null
    imageUrl?: string | null
    reported?: boolean | null
    watchDate?: Date | string | null
    watchTime?: Date | string | null
    extraField2?: string | null
    post?: PostCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: number
    settingId: number
    theaterId: number
    key: number
    postId?: number | null
    content?: string | null
    rating?: number | null
    spoiler?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    liked?: string | null
    likeCount?: number | null
    comment?: string | null
    imageUrl?: string | null
    reported?: boolean | null
    watchDate?: Date | string | null
    watchTime?: Date | string | null
    extraField2?: string | null
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostLikeCreateWithoutUserInput = {
    likedAt?: Date | string | null
    post: PostCreateNestedOneWithoutPostLikesInput
  }

  export type PostLikeUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    likedAt?: Date | string | null
  }

  export type PostLikeCreateOrConnectWithoutUserInput = {
    where: PostLikeWhereUniqueInput
    create: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput>
  }

  export type PostLikeCreateManyUserInputEnvelope = {
    data: PostLikeCreateManyUserInput | PostLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutUserInput = {
    title: string
    content: string
    createdAt?: Date | string | null
    answers?: AnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutUserInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput>
  }

  export type QuestionCreateManyUserInputEnvelope = {
    data: QuestionCreateManyUserInput | QuestionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnswerCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string | null
    question: QuestionCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutUserInput = {
    id?: number
    questionId: number
    content: string
    createdAt?: Date | string | null
  }

  export type AnswerCreateOrConnectWithoutUserInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutUserInput, AnswerUncheckedCreateWithoutUserInput>
  }

  export type AnswerCreateManyUserInputEnvelope = {
    data: AnswerCreateManyUserInput | AnswerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscribeCreateWithoutUserInput = {
    id: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean | null
  }

  export type SubscribeUncheckedCreateWithoutUserInput = {
    id: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean | null
  }

  export type SubscribeCreateOrConnectWithoutUserInput = {
    where: SubscribeWhereUniqueInput
    create: XOR<SubscribeCreateWithoutUserInput, SubscribeUncheckedCreateWithoutUserInput>
  }

  export type SubscribeCreateManyUserInputEnvelope = {
    data: SubscribeCreateManyUserInput | SubscribeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ViewingRecordCreateWithoutUserInput = {
    id: number
    date?: Date | string | null
    seat?: string | null
    musical: MusicalCreateNestedOneWithoutViewingsInput
  }

  export type ViewingRecordUncheckedCreateWithoutUserInput = {
    id: number
    musicalId: number
    date?: Date | string | null
    seat?: string | null
  }

  export type ViewingRecordCreateOrConnectWithoutUserInput = {
    where: ViewingRecordWhereUniqueInput
    create: XOR<ViewingRecordCreateWithoutUserInput, ViewingRecordUncheckedCreateWithoutUserInput>
  }

  export type ViewingRecordCreateManyUserInputEnvelope = {
    data: ViewingRecordCreateManyUserInput | ViewingRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowingInput = {
    id: number
    createdAt?: Date | string | null
    follower: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    id: number
    followerId: number
    createdAt?: Date | string | null
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowerInput = {
    id: number
    createdAt?: Date | string | null
    following: UserCreateNestedOneWithoutFollowsInput
  }

  export type FollowUncheckedCreateWithoutFollowerInput = {
    id: number
    followingId: number
    createdAt?: Date | string | null
  }

  export type FollowCreateOrConnectWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowCreateManyFollowerInputEnvelope = {
    data: FollowCreateManyFollowerInput | FollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type MultiProfileCreateWithoutUserInput = {
    nickname: string
    image?: string | null
    bio?: string | null
  }

  export type MultiProfileUncheckedCreateWithoutUserInput = {
    id?: number
    nickname: string
    image?: string | null
    bio?: string | null
  }

  export type MultiProfileCreateOrConnectWithoutUserInput = {
    where: MultiProfileWhereUniqueInput
    create: XOR<MultiProfileCreateWithoutUserInput, MultiProfileUncheckedCreateWithoutUserInput>
  }

  export type MultiProfileCreateManyUserInputEnvelope = {
    data: MultiProfileCreateManyUserInput | MultiProfileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCommunityCreateWithoutUserInput = {
    joinedAt?: Date | string | null
    community: CommunityCreateNestedOneWithoutUserCommunitiesInput
  }

  export type UserCommunityUncheckedCreateWithoutUserInput = {
    id?: number
    communityId: number
    joinedAt?: Date | string | null
  }

  export type UserCommunityCreateOrConnectWithoutUserInput = {
    where: UserCommunityWhereUniqueInput
    create: XOR<UserCommunityCreateWithoutUserInput, UserCommunityUncheckedCreateWithoutUserInput>
  }

  export type UserCommunityCreateManyUserInputEnvelope = {
    data: UserCommunityCreateManyUserInput | UserCommunityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SettingUpsertWithoutUsersInput = {
    update: XOR<SettingUpdateWithoutUsersInput, SettingUncheckedUpdateWithoutUsersInput>
    create: XOR<SettingCreateWithoutUsersInput, SettingUncheckedCreateWithoutUsersInput>
    where?: SettingWhereInput
  }

  export type SettingUpdateToOneWithWhereWithoutUsersInput = {
    where?: SettingWhereInput
    data: XOR<SettingUpdateWithoutUsersInput, SettingUncheckedUpdateWithoutUsersInput>
  }

  export type SettingUpdateWithoutUsersInput = {
    useBackground?: NullableBoolFieldUpdateOperationsInput | boolean | null
    useProfilePhoto?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowRepost?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUpdateManyWithoutSettingNestedInput
  }

  export type SettingUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    useBackground?: NullableBoolFieldUpdateOperationsInput | boolean | null
    useProfilePhoto?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowRepost?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutSettingNestedInput
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutUserInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: IntFilter<"Post"> | number
    userId?: IntFilter<"Post"> | number
    settingId?: IntFilter<"Post"> | number
    communityId?: IntFilter<"Post"> | number
    title?: StringNullableFilter<"Post"> | string | null
    content?: StringNullableFilter<"Post"> | string | null
    category?: StringNullableFilter<"Post"> | string | null
    like?: StringNullableFilter<"Post"> | string | null
    likeCount?: IntNullableFilter<"Post"> | number | null
    commentCount?: IntNullableFilter<"Post"> | number | null
    createdAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    repost?: IntNullableFilter<"Post"> | number | null
    bookmark?: IntNullableFilter<"Post"> | number | null
    communityGroup?: StringNullableFilter<"Post"> | string | null
    viewCount?: IntNullableFilter<"Post"> | number | null
    tag?: StringNullableFilter<"Post"> | string | null
    mediaType?: EnumImageOrVideoNullableFilter<"Post"> | $Enums.ImageOrVideo | null
    isPinned?: BoolNullableFilter<"Post"> | boolean | null
    tabCategory?: EnumCategoryNullableFilter<"Post"> | $Enums.Category | null
    isShared?: BoolNullableFilter<"Post"> | boolean | null
    musicalId?: IntNullableFilter<"Post"> | number | null
    actorId?: IntNullableFilter<"Post"> | number | null
    extraField?: StringNullableFilter<"Post"> | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    settingId?: IntFilter<"Comment"> | number
    communityId?: IntFilter<"Comment"> | number
    content?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    anonymous?: BoolNullableFilter<"Comment"> | boolean | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    settingId?: IntFilter<"Review"> | number
    theaterId?: IntFilter<"Review"> | number
    key?: IntFilter<"Review"> | number
    postId?: IntNullableFilter<"Review"> | number | null
    content?: StringNullableFilter<"Review"> | string | null
    rating?: IntNullableFilter<"Review"> | number | null
    spoiler?: BoolNullableFilter<"Review"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    liked?: StringNullableFilter<"Review"> | string | null
    likeCount?: IntNullableFilter<"Review"> | number | null
    comment?: StringNullableFilter<"Review"> | string | null
    imageUrl?: StringNullableFilter<"Review"> | string | null
    reported?: BoolNullableFilter<"Review"> | boolean | null
    watchDate?: DateTimeNullableFilter<"Review"> | Date | string | null
    watchTime?: DateTimeNullableFilter<"Review"> | Date | string | null
    extraField2?: StringNullableFilter<"Review"> | string | null
  }

  export type PostLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: PostLikeWhereUniqueInput
    update: XOR<PostLikeUpdateWithoutUserInput, PostLikeUncheckedUpdateWithoutUserInput>
    create: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput>
  }

  export type PostLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: PostLikeWhereUniqueInput
    data: XOR<PostLikeUpdateWithoutUserInput, PostLikeUncheckedUpdateWithoutUserInput>
  }

  export type PostLikeUpdateManyWithWhereWithoutUserInput = {
    where: PostLikeScalarWhereInput
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type PostLikeScalarWhereInput = {
    AND?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
    OR?: PostLikeScalarWhereInput[]
    NOT?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
    id?: IntFilter<"PostLike"> | number
    postId?: IntFilter<"PostLike"> | number
    userId?: IntFilter<"PostLike"> | number
    likedAt?: DateTimeNullableFilter<"PostLike"> | Date | string | null
  }

  export type QuestionUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutUserInput, QuestionUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutUserInput, QuestionUncheckedUpdateWithoutUserInput>
  }

  export type QuestionUpdateManyWithWhereWithoutUserInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutUserInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: IntFilter<"Question"> | number
    userId?: IntFilter<"Question"> | number
    title?: StringFilter<"Question"> | string
    content?: StringFilter<"Question"> | string
    createdAt?: DateTimeNullableFilter<"Question"> | Date | string | null
  }

  export type AnswerUpsertWithWhereUniqueWithoutUserInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutUserInput, AnswerUncheckedUpdateWithoutUserInput>
    create: XOR<AnswerCreateWithoutUserInput, AnswerUncheckedCreateWithoutUserInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutUserInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutUserInput, AnswerUncheckedUpdateWithoutUserInput>
  }

  export type AnswerUpdateManyWithWhereWithoutUserInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutUserInput>
  }

  export type AnswerScalarWhereInput = {
    AND?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
    OR?: AnswerScalarWhereInput[]
    NOT?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
    id?: IntFilter<"Answer"> | number
    questionId?: IntFilter<"Answer"> | number
    userId?: IntFilter<"Answer"> | number
    content?: StringFilter<"Answer"> | string
    createdAt?: DateTimeNullableFilter<"Answer"> | Date | string | null
  }

  export type SubscribeUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscribeWhereUniqueInput
    update: XOR<SubscribeUpdateWithoutUserInput, SubscribeUncheckedUpdateWithoutUserInput>
    create: XOR<SubscribeCreateWithoutUserInput, SubscribeUncheckedCreateWithoutUserInput>
  }

  export type SubscribeUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscribeWhereUniqueInput
    data: XOR<SubscribeUpdateWithoutUserInput, SubscribeUncheckedUpdateWithoutUserInput>
  }

  export type SubscribeUpdateManyWithWhereWithoutUserInput = {
    where: SubscribeScalarWhereInput
    data: XOR<SubscribeUpdateManyMutationInput, SubscribeUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscribeScalarWhereInput = {
    AND?: SubscribeScalarWhereInput | SubscribeScalarWhereInput[]
    OR?: SubscribeScalarWhereInput[]
    NOT?: SubscribeScalarWhereInput | SubscribeScalarWhereInput[]
    id?: IntFilter<"Subscribe"> | number
    userId?: IntFilter<"Subscribe"> | number
    startDate?: DateTimeNullableFilter<"Subscribe"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Subscribe"> | Date | string | null
    isActive?: BoolNullableFilter<"Subscribe"> | boolean | null
  }

  export type ViewingRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: ViewingRecordWhereUniqueInput
    update: XOR<ViewingRecordUpdateWithoutUserInput, ViewingRecordUncheckedUpdateWithoutUserInput>
    create: XOR<ViewingRecordCreateWithoutUserInput, ViewingRecordUncheckedCreateWithoutUserInput>
  }

  export type ViewingRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: ViewingRecordWhereUniqueInput
    data: XOR<ViewingRecordUpdateWithoutUserInput, ViewingRecordUncheckedUpdateWithoutUserInput>
  }

  export type ViewingRecordUpdateManyWithWhereWithoutUserInput = {
    where: ViewingRecordScalarWhereInput
    data: XOR<ViewingRecordUpdateManyMutationInput, ViewingRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type ViewingRecordScalarWhereInput = {
    AND?: ViewingRecordScalarWhereInput | ViewingRecordScalarWhereInput[]
    OR?: ViewingRecordScalarWhereInput[]
    NOT?: ViewingRecordScalarWhereInput | ViewingRecordScalarWhereInput[]
    id?: IntFilter<"ViewingRecord"> | number
    userId?: IntFilter<"ViewingRecord"> | number
    musicalId?: IntFilter<"ViewingRecord"> | number
    date?: DateTimeNullableFilter<"ViewingRecord"> | Date | string | null
    seat?: StringNullableFilter<"ViewingRecord"> | string | null
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: IntFilter<"Follow"> | number
    followerId?: IntFilter<"Follow"> | number
    followingId?: IntFilter<"Follow"> | number
    createdAt?: DateTimeNullableFilter<"Follow"> | Date | string | null
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type MultiProfileUpsertWithWhereUniqueWithoutUserInput = {
    where: MultiProfileWhereUniqueInput
    update: XOR<MultiProfileUpdateWithoutUserInput, MultiProfileUncheckedUpdateWithoutUserInput>
    create: XOR<MultiProfileCreateWithoutUserInput, MultiProfileUncheckedCreateWithoutUserInput>
  }

  export type MultiProfileUpdateWithWhereUniqueWithoutUserInput = {
    where: MultiProfileWhereUniqueInput
    data: XOR<MultiProfileUpdateWithoutUserInput, MultiProfileUncheckedUpdateWithoutUserInput>
  }

  export type MultiProfileUpdateManyWithWhereWithoutUserInput = {
    where: MultiProfileScalarWhereInput
    data: XOR<MultiProfileUpdateManyMutationInput, MultiProfileUncheckedUpdateManyWithoutUserInput>
  }

  export type MultiProfileScalarWhereInput = {
    AND?: MultiProfileScalarWhereInput | MultiProfileScalarWhereInput[]
    OR?: MultiProfileScalarWhereInput[]
    NOT?: MultiProfileScalarWhereInput | MultiProfileScalarWhereInput[]
    id?: IntFilter<"MultiProfile"> | number
    userId?: IntFilter<"MultiProfile"> | number
    nickname?: StringFilter<"MultiProfile"> | string
    image?: StringNullableFilter<"MultiProfile"> | string | null
    bio?: StringNullableFilter<"MultiProfile"> | string | null
  }

  export type UserCommunityUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCommunityWhereUniqueInput
    update: XOR<UserCommunityUpdateWithoutUserInput, UserCommunityUncheckedUpdateWithoutUserInput>
    create: XOR<UserCommunityCreateWithoutUserInput, UserCommunityUncheckedCreateWithoutUserInput>
  }

  export type UserCommunityUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCommunityWhereUniqueInput
    data: XOR<UserCommunityUpdateWithoutUserInput, UserCommunityUncheckedUpdateWithoutUserInput>
  }

  export type UserCommunityUpdateManyWithWhereWithoutUserInput = {
    where: UserCommunityScalarWhereInput
    data: XOR<UserCommunityUpdateManyMutationInput, UserCommunityUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCommunityScalarWhereInput = {
    AND?: UserCommunityScalarWhereInput | UserCommunityScalarWhereInput[]
    OR?: UserCommunityScalarWhereInput[]
    NOT?: UserCommunityScalarWhereInput | UserCommunityScalarWhereInput[]
    id?: IntFilter<"UserCommunity"> | number
    userId?: IntFilter<"UserCommunity"> | number
    communityId?: IntFilter<"UserCommunity"> | number
    joinedAt?: DateTimeNullableFilter<"UserCommunity"> | Date | string | null
  }

  export type UserCreateWithoutPostsInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type ActorCreateWithoutPostsInput = {
    postId: number
    userId: number
    settingId: number
    communityId: number
    key: number
    name?: string | null
    image?: string | null
    profile?: string | null
    snsLink?: string | null
    fk?: number | null
    castings?: CastingCreateNestedManyWithoutActorInput
  }

  export type ActorUncheckedCreateWithoutPostsInput = {
    id?: number
    postId: number
    userId: number
    settingId: number
    communityId: number
    key: number
    name?: string | null
    image?: string | null
    profile?: string | null
    snsLink?: string | null
    fk?: number | null
    castings?: CastingUncheckedCreateNestedManyWithoutActorInput
  }

  export type ActorCreateOrConnectWithoutPostsInput = {
    where: ActorWhereUniqueInput
    create: XOR<ActorCreateWithoutPostsInput, ActorUncheckedCreateWithoutPostsInput>
  }

  export type SettingCreateWithoutPostsInput = {
    useBackground?: boolean | null
    useProfilePhoto?: boolean | null
    allowRepost?: boolean | null
    users?: UserCreateNestedOneWithoutSettingInput
  }

  export type SettingUncheckedCreateWithoutPostsInput = {
    id?: number
    useBackground?: boolean | null
    useProfilePhoto?: boolean | null
    allowRepost?: boolean | null
    users?: UserUncheckedCreateNestedOneWithoutSettingInput
  }

  export type SettingCreateOrConnectWithoutPostsInput = {
    where: SettingWhereUniqueInput
    create: XOR<SettingCreateWithoutPostsInput, SettingUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutPostInput = {
    settingId: number
    communityId: number
    content?: string | null
    createdAt?: Date | string | null
    anonymous?: boolean | null
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    settingId: number
    communityId: number
    content?: string | null
    createdAt?: Date | string | null
    anonymous?: boolean | null
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostLikeCreateWithoutPostInput = {
    likedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPostLikesInput
  }

  export type PostLikeUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    likedAt?: Date | string | null
  }

  export type PostLikeCreateOrConnectWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
  }

  export type PostLikeCreateManyPostInputEnvelope = {
    data: PostLikeCreateManyPostInput | PostLikeCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ImageCreateWithoutPostInput = {
    url?: string | null
    caption?: string | null
  }

  export type ImageUncheckedCreateWithoutPostInput = {
    id?: number
    url?: string | null
    caption?: string | null
  }

  export type ImageCreateOrConnectWithoutPostInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutPostInput, ImageUncheckedCreateWithoutPostInput>
  }

  export type ImageCreateManyPostInputEnvelope = {
    data: ImageCreateManyPostInput | ImageCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutPostInput = {
    settingId: number
    theaterId: number
    key: number
    content?: string | null
    rating?: number | null
    spoiler?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    liked?: string | null
    likeCount?: number | null
    comment?: string | null
    imageUrl?: string | null
    reported?: boolean | null
    watchDate?: Date | string | null
    watchTime?: Date | string | null
    extraField2?: string | null
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    settingId: number
    theaterId: number
    key: number
    content?: string | null
    rating?: number | null
    spoiler?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    liked?: string | null
    likeCount?: number | null
    comment?: string | null
    imageUrl?: string | null
    reported?: boolean | null
    watchDate?: Date | string | null
    watchTime?: Date | string | null
    extraField2?: string | null
  }

  export type ReviewCreateOrConnectWithoutPostInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutPostInput, ReviewUncheckedCreateWithoutPostInput>
  }

  export type ReviewCreateManyPostInputEnvelope = {
    data: ReviewCreateManyPostInput | ReviewCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutPostsInput = {
    name: string
    type?: string | null
  }

  export type TagUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
    type?: string | null
  }

  export type TagCreateOrConnectWithoutPostsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActorUpsertWithoutPostsInput = {
    update: XOR<ActorUpdateWithoutPostsInput, ActorUncheckedUpdateWithoutPostsInput>
    create: XOR<ActorCreateWithoutPostsInput, ActorUncheckedCreateWithoutPostsInput>
    where?: ActorWhereInput
  }

  export type ActorUpdateToOneWithWhereWithoutPostsInput = {
    where?: ActorWhereInput
    data: XOR<ActorUpdateWithoutPostsInput, ActorUncheckedUpdateWithoutPostsInput>
  }

  export type ActorUpdateWithoutPostsInput = {
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    snsLink?: NullableStringFieldUpdateOperationsInput | string | null
    fk?: NullableIntFieldUpdateOperationsInput | number | null
    castings?: CastingUpdateManyWithoutActorNestedInput
  }

  export type ActorUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    snsLink?: NullableStringFieldUpdateOperationsInput | string | null
    fk?: NullableIntFieldUpdateOperationsInput | number | null
    castings?: CastingUncheckedUpdateManyWithoutActorNestedInput
  }

  export type SettingUpsertWithoutPostsInput = {
    update: XOR<SettingUpdateWithoutPostsInput, SettingUncheckedUpdateWithoutPostsInput>
    create: XOR<SettingCreateWithoutPostsInput, SettingUncheckedCreateWithoutPostsInput>
    where?: SettingWhereInput
  }

  export type SettingUpdateToOneWithWhereWithoutPostsInput = {
    where?: SettingWhereInput
    data: XOR<SettingUpdateWithoutPostsInput, SettingUncheckedUpdateWithoutPostsInput>
  }

  export type SettingUpdateWithoutPostsInput = {
    useBackground?: NullableBoolFieldUpdateOperationsInput | boolean | null
    useProfilePhoto?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowRepost?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: UserUpdateOneWithoutSettingNestedInput
  }

  export type SettingUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    useBackground?: NullableBoolFieldUpdateOperationsInput | boolean | null
    useProfilePhoto?: NullableBoolFieldUpdateOperationsInput | boolean | null
    allowRepost?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: UserUncheckedUpdateOneWithoutSettingNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostLikeUpsertWithWhereUniqueWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    update: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
    create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
  }

  export type PostLikeUpdateWithWhereUniqueWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    data: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
  }

  export type PostLikeUpdateManyWithWhereWithoutPostInput = {
    where: PostLikeScalarWhereInput
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutPostInput>
  }

  export type ImageUpsertWithWhereUniqueWithoutPostInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutPostInput, ImageUncheckedUpdateWithoutPostInput>
    create: XOR<ImageCreateWithoutPostInput, ImageUncheckedCreateWithoutPostInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutPostInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutPostInput, ImageUncheckedUpdateWithoutPostInput>
  }

  export type ImageUpdateManyWithWhereWithoutPostInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutPostInput>
  }

  export type ImageScalarWhereInput = {
    AND?: ImageScalarWhereInput | ImageScalarWhereInput[]
    OR?: ImageScalarWhereInput[]
    NOT?: ImageScalarWhereInput | ImageScalarWhereInput[]
    id?: IntFilter<"Image"> | number
    postId?: IntFilter<"Image"> | number
    url?: StringNullableFilter<"Image"> | string | null
    caption?: StringNullableFilter<"Image"> | string | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutPostInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutPostInput, ReviewUncheckedUpdateWithoutPostInput>
    create: XOR<ReviewCreateWithoutPostInput, ReviewUncheckedCreateWithoutPostInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutPostInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutPostInput, ReviewUncheckedUpdateWithoutPostInput>
  }

  export type ReviewUpdateManyWithWhereWithoutPostInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutPostInput>
  }

  export type TagUpsertWithWhereUniqueWithoutPostsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutPostsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
  }

  export type TagUpdateManyWithWhereWithoutPostsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutPostsInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    type?: StringNullableFilter<"Tag"> | string | null
  }

  export type PostCreateWithoutCommentsInput = {
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    extraField?: string | null
    user: UserCreateNestedOneWithoutPostsInput
    actor?: ActorCreateNestedOneWithoutPostsInput
    setting: SettingCreateNestedOneWithoutPostsInput
    postLikes?: PostLikeCreateNestedManyWithoutPostInput
    images?: ImageCreateNestedManyWithoutPostInput
    reviews?: ReviewCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: number
    userId: number
    settingId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    actorId?: number | null
    extraField?: string | null
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    images?: ImageUncheckedCreateNestedManyWithoutPostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    actor?: ActorUpdateOneWithoutPostsNestedInput
    setting?: SettingUpdateOneRequiredWithoutPostsNestedInput
    postLikes?: PostLikeUpdateManyWithoutPostNestedInput
    images?: ImageUpdateManyWithoutPostNestedInput
    reviews?: ReviewUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    postLikes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    images?: ImageUncheckedUpdateManyWithoutPostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReviewsInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type PostCreateWithoutReviewsInput = {
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    extraField?: string | null
    user: UserCreateNestedOneWithoutPostsInput
    actor?: ActorCreateNestedOneWithoutPostsInput
    setting: SettingCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postLikes?: PostLikeCreateNestedManyWithoutPostInput
    images?: ImageCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutReviewsInput = {
    id?: number
    userId: number
    settingId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    actorId?: number | null
    extraField?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    images?: ImageUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutReviewsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutReviewsInput, PostUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostUpsertWithoutReviewsInput = {
    update: XOR<PostUpdateWithoutReviewsInput, PostUncheckedUpdateWithoutReviewsInput>
    create: XOR<PostCreateWithoutReviewsInput, PostUncheckedCreateWithoutReviewsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutReviewsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutReviewsInput, PostUncheckedUpdateWithoutReviewsInput>
  }

  export type PostUpdateWithoutReviewsInput = {
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    actor?: ActorUpdateOneWithoutPostsNestedInput
    setting?: SettingUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUpdateManyWithoutPostNestedInput
    images?: ImageUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    images?: ImageUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostCreateWithoutActorInput = {
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    extraField?: string | null
    user: UserCreateNestedOneWithoutPostsInput
    setting: SettingCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postLikes?: PostLikeCreateNestedManyWithoutPostInput
    images?: ImageCreateNestedManyWithoutPostInput
    reviews?: ReviewCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutActorInput = {
    id?: number
    userId: number
    settingId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    extraField?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    images?: ImageUncheckedCreateNestedManyWithoutPostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutActorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutActorInput, PostUncheckedCreateWithoutActorInput>
  }

  export type PostCreateManyActorInputEnvelope = {
    data: PostCreateManyActorInput | PostCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type CastingCreateWithoutActorInput = {
    role?: string | null
    musical: MusicalCreateNestedOneWithoutCastingsInput
  }

  export type CastingUncheckedCreateWithoutActorInput = {
    id?: number
    musicalId: number
    role?: string | null
  }

  export type CastingCreateOrConnectWithoutActorInput = {
    where: CastingWhereUniqueInput
    create: XOR<CastingCreateWithoutActorInput, CastingUncheckedCreateWithoutActorInput>
  }

  export type CastingCreateManyActorInputEnvelope = {
    data: CastingCreateManyActorInput | CastingCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithWhereUniqueWithoutActorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutActorInput, PostUncheckedUpdateWithoutActorInput>
    create: XOR<PostCreateWithoutActorInput, PostUncheckedCreateWithoutActorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutActorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutActorInput, PostUncheckedUpdateWithoutActorInput>
  }

  export type PostUpdateManyWithWhereWithoutActorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutActorInput>
  }

  export type CastingUpsertWithWhereUniqueWithoutActorInput = {
    where: CastingWhereUniqueInput
    update: XOR<CastingUpdateWithoutActorInput, CastingUncheckedUpdateWithoutActorInput>
    create: XOR<CastingCreateWithoutActorInput, CastingUncheckedCreateWithoutActorInput>
  }

  export type CastingUpdateWithWhereUniqueWithoutActorInput = {
    where: CastingWhereUniqueInput
    data: XOR<CastingUpdateWithoutActorInput, CastingUncheckedUpdateWithoutActorInput>
  }

  export type CastingUpdateManyWithWhereWithoutActorInput = {
    where: CastingScalarWhereInput
    data: XOR<CastingUpdateManyMutationInput, CastingUncheckedUpdateManyWithoutActorInput>
  }

  export type CastingScalarWhereInput = {
    AND?: CastingScalarWhereInput | CastingScalarWhereInput[]
    OR?: CastingScalarWhereInput[]
    NOT?: CastingScalarWhereInput | CastingScalarWhereInput[]
    id?: IntFilter<"Casting"> | number
    musicalId?: IntFilter<"Casting"> | number
    actorId?: IntFilter<"Casting"> | number
    role?: StringNullableFilter<"Casting"> | string | null
  }

  export type TheaterCreateWithoutMusicalsInput = {
    id: number
    name?: string | null
    seatCount?: number | null
    roadAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    region: RegionCreateNestedOneWithoutTheatersInput
    seats?: SeatCreateNestedManyWithoutTheaterInput
  }

  export type TheaterUncheckedCreateWithoutMusicalsInput = {
    id: number
    regionId: number
    name?: string | null
    seatCount?: number | null
    roadAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    seats?: SeatUncheckedCreateNestedManyWithoutTheaterInput
  }

  export type TheaterCreateOrConnectWithoutMusicalsInput = {
    where: TheaterWhereUniqueInput
    create: XOR<TheaterCreateWithoutMusicalsInput, TheaterUncheckedCreateWithoutMusicalsInput>
  }

  export type CastingCreateWithoutMusicalInput = {
    role?: string | null
    actor: ActorCreateNestedOneWithoutCastingsInput
  }

  export type CastingUncheckedCreateWithoutMusicalInput = {
    id?: number
    actorId: number
    role?: string | null
  }

  export type CastingCreateOrConnectWithoutMusicalInput = {
    where: CastingWhereUniqueInput
    create: XOR<CastingCreateWithoutMusicalInput, CastingUncheckedCreateWithoutMusicalInput>
  }

  export type CastingCreateManyMusicalInputEnvelope = {
    data: CastingCreateManyMusicalInput | CastingCreateManyMusicalInput[]
    skipDuplicates?: boolean
  }

  export type ViewingRecordCreateWithoutMusicalInput = {
    id: number
    date?: Date | string | null
    seat?: string | null
    user: UserCreateNestedOneWithoutViewingsInput
  }

  export type ViewingRecordUncheckedCreateWithoutMusicalInput = {
    id: number
    userId: number
    date?: Date | string | null
    seat?: string | null
  }

  export type ViewingRecordCreateOrConnectWithoutMusicalInput = {
    where: ViewingRecordWhereUniqueInput
    create: XOR<ViewingRecordCreateWithoutMusicalInput, ViewingRecordUncheckedCreateWithoutMusicalInput>
  }

  export type ViewingRecordCreateManyMusicalInputEnvelope = {
    data: ViewingRecordCreateManyMusicalInput | ViewingRecordCreateManyMusicalInput[]
    skipDuplicates?: boolean
  }

  export type MusicalCommunityCreateWithoutMusicalInput = {
    community: CommunityCreateNestedOneWithoutMusicalCommunitiesInput
  }

  export type MusicalCommunityUncheckedCreateWithoutMusicalInput = {
    id?: number
    communityId: number
  }

  export type MusicalCommunityCreateOrConnectWithoutMusicalInput = {
    where: MusicalCommunityWhereUniqueInput
    create: XOR<MusicalCommunityCreateWithoutMusicalInput, MusicalCommunityUncheckedCreateWithoutMusicalInput>
  }

  export type MusicalCommunityCreateManyMusicalInputEnvelope = {
    data: MusicalCommunityCreateManyMusicalInput | MusicalCommunityCreateManyMusicalInput[]
    skipDuplicates?: boolean
  }

  export type TheaterUpsertWithoutMusicalsInput = {
    update: XOR<TheaterUpdateWithoutMusicalsInput, TheaterUncheckedUpdateWithoutMusicalsInput>
    create: XOR<TheaterCreateWithoutMusicalsInput, TheaterUncheckedCreateWithoutMusicalsInput>
    where?: TheaterWhereInput
  }

  export type TheaterUpdateToOneWithWhereWithoutMusicalsInput = {
    where?: TheaterWhereInput
    data: XOR<TheaterUpdateWithoutMusicalsInput, TheaterUncheckedUpdateWithoutMusicalsInput>
  }

  export type TheaterUpdateWithoutMusicalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    seatCount?: NullableIntFieldUpdateOperationsInput | number | null
    roadAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneRequiredWithoutTheatersNestedInput
    seats?: SeatUpdateManyWithoutTheaterNestedInput
  }

  export type TheaterUncheckedUpdateWithoutMusicalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    seatCount?: NullableIntFieldUpdateOperationsInput | number | null
    roadAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seats?: SeatUncheckedUpdateManyWithoutTheaterNestedInput
  }

  export type CastingUpsertWithWhereUniqueWithoutMusicalInput = {
    where: CastingWhereUniqueInput
    update: XOR<CastingUpdateWithoutMusicalInput, CastingUncheckedUpdateWithoutMusicalInput>
    create: XOR<CastingCreateWithoutMusicalInput, CastingUncheckedCreateWithoutMusicalInput>
  }

  export type CastingUpdateWithWhereUniqueWithoutMusicalInput = {
    where: CastingWhereUniqueInput
    data: XOR<CastingUpdateWithoutMusicalInput, CastingUncheckedUpdateWithoutMusicalInput>
  }

  export type CastingUpdateManyWithWhereWithoutMusicalInput = {
    where: CastingScalarWhereInput
    data: XOR<CastingUpdateManyMutationInput, CastingUncheckedUpdateManyWithoutMusicalInput>
  }

  export type ViewingRecordUpsertWithWhereUniqueWithoutMusicalInput = {
    where: ViewingRecordWhereUniqueInput
    update: XOR<ViewingRecordUpdateWithoutMusicalInput, ViewingRecordUncheckedUpdateWithoutMusicalInput>
    create: XOR<ViewingRecordCreateWithoutMusicalInput, ViewingRecordUncheckedCreateWithoutMusicalInput>
  }

  export type ViewingRecordUpdateWithWhereUniqueWithoutMusicalInput = {
    where: ViewingRecordWhereUniqueInput
    data: XOR<ViewingRecordUpdateWithoutMusicalInput, ViewingRecordUncheckedUpdateWithoutMusicalInput>
  }

  export type ViewingRecordUpdateManyWithWhereWithoutMusicalInput = {
    where: ViewingRecordScalarWhereInput
    data: XOR<ViewingRecordUpdateManyMutationInput, ViewingRecordUncheckedUpdateManyWithoutMusicalInput>
  }

  export type MusicalCommunityUpsertWithWhereUniqueWithoutMusicalInput = {
    where: MusicalCommunityWhereUniqueInput
    update: XOR<MusicalCommunityUpdateWithoutMusicalInput, MusicalCommunityUncheckedUpdateWithoutMusicalInput>
    create: XOR<MusicalCommunityCreateWithoutMusicalInput, MusicalCommunityUncheckedCreateWithoutMusicalInput>
  }

  export type MusicalCommunityUpdateWithWhereUniqueWithoutMusicalInput = {
    where: MusicalCommunityWhereUniqueInput
    data: XOR<MusicalCommunityUpdateWithoutMusicalInput, MusicalCommunityUncheckedUpdateWithoutMusicalInput>
  }

  export type MusicalCommunityUpdateManyWithWhereWithoutMusicalInput = {
    where: MusicalCommunityScalarWhereInput
    data: XOR<MusicalCommunityUpdateManyMutationInput, MusicalCommunityUncheckedUpdateManyWithoutMusicalInput>
  }

  export type MusicalCommunityScalarWhereInput = {
    AND?: MusicalCommunityScalarWhereInput | MusicalCommunityScalarWhereInput[]
    OR?: MusicalCommunityScalarWhereInput[]
    NOT?: MusicalCommunityScalarWhereInput | MusicalCommunityScalarWhereInput[]
    id?: IntFilter<"MusicalCommunity"> | number
    musicalId?: IntFilter<"MusicalCommunity"> | number
    communityId?: IntFilter<"MusicalCommunity"> | number
  }

  export type RegionCreateWithoutTheatersInput = {
    name: string
  }

  export type RegionUncheckedCreateWithoutTheatersInput = {
    id?: number
    name: string
  }

  export type RegionCreateOrConnectWithoutTheatersInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutTheatersInput, RegionUncheckedCreateWithoutTheatersInput>
  }

  export type MusicalCreateWithoutTheaterInput = {
    id: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    castings?: CastingCreateNestedManyWithoutMusicalInput
    viewings?: ViewingRecordCreateNestedManyWithoutMusicalInput
    communities?: MusicalCommunityCreateNestedManyWithoutMusicalInput
  }

  export type MusicalUncheckedCreateWithoutTheaterInput = {
    id: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    castings?: CastingUncheckedCreateNestedManyWithoutMusicalInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutMusicalInput
    communities?: MusicalCommunityUncheckedCreateNestedManyWithoutMusicalInput
  }

  export type MusicalCreateOrConnectWithoutTheaterInput = {
    where: MusicalWhereUniqueInput
    create: XOR<MusicalCreateWithoutTheaterInput, MusicalUncheckedCreateWithoutTheaterInput>
  }

  export type MusicalCreateManyTheaterInputEnvelope = {
    data: MusicalCreateManyTheaterInput | MusicalCreateManyTheaterInput[]
    skipDuplicates?: boolean
  }

  export type SeatCreateWithoutTheaterInput = {
    id: number
    locationId: number
    field?: string | null
    field2?: string | null
    field3?: string | null
    floor?: string | null
  }

  export type SeatUncheckedCreateWithoutTheaterInput = {
    id: number
    locationId: number
    field?: string | null
    field2?: string | null
    field3?: string | null
    floor?: string | null
  }

  export type SeatCreateOrConnectWithoutTheaterInput = {
    where: SeatWhereUniqueInput
    create: XOR<SeatCreateWithoutTheaterInput, SeatUncheckedCreateWithoutTheaterInput>
  }

  export type SeatCreateManyTheaterInputEnvelope = {
    data: SeatCreateManyTheaterInput | SeatCreateManyTheaterInput[]
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutTheatersInput = {
    update: XOR<RegionUpdateWithoutTheatersInput, RegionUncheckedUpdateWithoutTheatersInput>
    create: XOR<RegionCreateWithoutTheatersInput, RegionUncheckedCreateWithoutTheatersInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutTheatersInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutTheatersInput, RegionUncheckedUpdateWithoutTheatersInput>
  }

  export type RegionUpdateWithoutTheatersInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateWithoutTheatersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MusicalUpsertWithWhereUniqueWithoutTheaterInput = {
    where: MusicalWhereUniqueInput
    update: XOR<MusicalUpdateWithoutTheaterInput, MusicalUncheckedUpdateWithoutTheaterInput>
    create: XOR<MusicalCreateWithoutTheaterInput, MusicalUncheckedCreateWithoutTheaterInput>
  }

  export type MusicalUpdateWithWhereUniqueWithoutTheaterInput = {
    where: MusicalWhereUniqueInput
    data: XOR<MusicalUpdateWithoutTheaterInput, MusicalUncheckedUpdateWithoutTheaterInput>
  }

  export type MusicalUpdateManyWithWhereWithoutTheaterInput = {
    where: MusicalScalarWhereInput
    data: XOR<MusicalUpdateManyMutationInput, MusicalUncheckedUpdateManyWithoutTheaterInput>
  }

  export type MusicalScalarWhereInput = {
    AND?: MusicalScalarWhereInput | MusicalScalarWhereInput[]
    OR?: MusicalScalarWhereInput[]
    NOT?: MusicalScalarWhereInput | MusicalScalarWhereInput[]
    id?: IntFilter<"Musical"> | number
    theaterId?: IntFilter<"Musical"> | number
    name?: StringNullableFilter<"Musical"> | string | null
    startDate?: DateTimeNullableFilter<"Musical"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Musical"> | Date | string | null
    poster?: StringNullableFilter<"Musical"> | string | null
    createdAt?: DateTimeNullableFilter<"Musical"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Musical"> | Date | string | null
  }

  export type SeatUpsertWithWhereUniqueWithoutTheaterInput = {
    where: SeatWhereUniqueInput
    update: XOR<SeatUpdateWithoutTheaterInput, SeatUncheckedUpdateWithoutTheaterInput>
    create: XOR<SeatCreateWithoutTheaterInput, SeatUncheckedCreateWithoutTheaterInput>
  }

  export type SeatUpdateWithWhereUniqueWithoutTheaterInput = {
    where: SeatWhereUniqueInput
    data: XOR<SeatUpdateWithoutTheaterInput, SeatUncheckedUpdateWithoutTheaterInput>
  }

  export type SeatUpdateManyWithWhereWithoutTheaterInput = {
    where: SeatScalarWhereInput
    data: XOR<SeatUpdateManyMutationInput, SeatUncheckedUpdateManyWithoutTheaterInput>
  }

  export type SeatScalarWhereInput = {
    AND?: SeatScalarWhereInput | SeatScalarWhereInput[]
    OR?: SeatScalarWhereInput[]
    NOT?: SeatScalarWhereInput | SeatScalarWhereInput[]
    id?: IntFilter<"Seat"> | number
    theaterId?: IntFilter<"Seat"> | number
    locationId?: IntFilter<"Seat"> | number
    field?: StringNullableFilter<"Seat"> | string | null
    field2?: StringNullableFilter<"Seat"> | string | null
    field3?: StringNullableFilter<"Seat"> | string | null
    floor?: StringNullableFilter<"Seat"> | string | null
  }

  export type TheaterCreateWithoutSeatsInput = {
    id: number
    name?: string | null
    seatCount?: number | null
    roadAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    region: RegionCreateNestedOneWithoutTheatersInput
    musicals?: MusicalCreateNestedManyWithoutTheaterInput
  }

  export type TheaterUncheckedCreateWithoutSeatsInput = {
    id: number
    regionId: number
    name?: string | null
    seatCount?: number | null
    roadAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    musicals?: MusicalUncheckedCreateNestedManyWithoutTheaterInput
  }

  export type TheaterCreateOrConnectWithoutSeatsInput = {
    where: TheaterWhereUniqueInput
    create: XOR<TheaterCreateWithoutSeatsInput, TheaterUncheckedCreateWithoutSeatsInput>
  }

  export type TheaterUpsertWithoutSeatsInput = {
    update: XOR<TheaterUpdateWithoutSeatsInput, TheaterUncheckedUpdateWithoutSeatsInput>
    create: XOR<TheaterCreateWithoutSeatsInput, TheaterUncheckedCreateWithoutSeatsInput>
    where?: TheaterWhereInput
  }

  export type TheaterUpdateToOneWithWhereWithoutSeatsInput = {
    where?: TheaterWhereInput
    data: XOR<TheaterUpdateWithoutSeatsInput, TheaterUncheckedUpdateWithoutSeatsInput>
  }

  export type TheaterUpdateWithoutSeatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    seatCount?: NullableIntFieldUpdateOperationsInput | number | null
    roadAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    region?: RegionUpdateOneRequiredWithoutTheatersNestedInput
    musicals?: MusicalUpdateManyWithoutTheaterNestedInput
  }

  export type TheaterUncheckedUpdateWithoutSeatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    seatCount?: NullableIntFieldUpdateOperationsInput | number | null
    roadAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    musicals?: MusicalUncheckedUpdateManyWithoutTheaterNestedInput
  }

  export type UserCommunityCreateWithoutCommunityInput = {
    joinedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUserCommunitiesInput
  }

  export type UserCommunityUncheckedCreateWithoutCommunityInput = {
    id?: number
    userId: number
    joinedAt?: Date | string | null
  }

  export type UserCommunityCreateOrConnectWithoutCommunityInput = {
    where: UserCommunityWhereUniqueInput
    create: XOR<UserCommunityCreateWithoutCommunityInput, UserCommunityUncheckedCreateWithoutCommunityInput>
  }

  export type UserCommunityCreateManyCommunityInputEnvelope = {
    data: UserCommunityCreateManyCommunityInput | UserCommunityCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type MusicalCommunityCreateWithoutCommunityInput = {
    musical: MusicalCreateNestedOneWithoutCommunitiesInput
  }

  export type MusicalCommunityUncheckedCreateWithoutCommunityInput = {
    id?: number
    musicalId: number
  }

  export type MusicalCommunityCreateOrConnectWithoutCommunityInput = {
    where: MusicalCommunityWhereUniqueInput
    create: XOR<MusicalCommunityCreateWithoutCommunityInput, MusicalCommunityUncheckedCreateWithoutCommunityInput>
  }

  export type MusicalCommunityCreateManyCommunityInputEnvelope = {
    data: MusicalCommunityCreateManyCommunityInput | MusicalCommunityCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type UserCommunityUpsertWithWhereUniqueWithoutCommunityInput = {
    where: UserCommunityWhereUniqueInput
    update: XOR<UserCommunityUpdateWithoutCommunityInput, UserCommunityUncheckedUpdateWithoutCommunityInput>
    create: XOR<UserCommunityCreateWithoutCommunityInput, UserCommunityUncheckedCreateWithoutCommunityInput>
  }

  export type UserCommunityUpdateWithWhereUniqueWithoutCommunityInput = {
    where: UserCommunityWhereUniqueInput
    data: XOR<UserCommunityUpdateWithoutCommunityInput, UserCommunityUncheckedUpdateWithoutCommunityInput>
  }

  export type UserCommunityUpdateManyWithWhereWithoutCommunityInput = {
    where: UserCommunityScalarWhereInput
    data: XOR<UserCommunityUpdateManyMutationInput, UserCommunityUncheckedUpdateManyWithoutCommunityInput>
  }

  export type MusicalCommunityUpsertWithWhereUniqueWithoutCommunityInput = {
    where: MusicalCommunityWhereUniqueInput
    update: XOR<MusicalCommunityUpdateWithoutCommunityInput, MusicalCommunityUncheckedUpdateWithoutCommunityInput>
    create: XOR<MusicalCommunityCreateWithoutCommunityInput, MusicalCommunityUncheckedCreateWithoutCommunityInput>
  }

  export type MusicalCommunityUpdateWithWhereUniqueWithoutCommunityInput = {
    where: MusicalCommunityWhereUniqueInput
    data: XOR<MusicalCommunityUpdateWithoutCommunityInput, MusicalCommunityUncheckedUpdateWithoutCommunityInput>
  }

  export type MusicalCommunityUpdateManyWithWhereWithoutCommunityInput = {
    where: MusicalCommunityScalarWhereInput
    data: XOR<MusicalCommunityUpdateManyMutationInput, MusicalCommunityUncheckedUpdateManyWithoutCommunityInput>
  }

  export type UserCreateWithoutSettingInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingInput = {
    id?: number
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingInput, UserUncheckedCreateWithoutSettingInput>
  }

  export type PostCreateWithoutSettingInput = {
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    extraField?: string | null
    user: UserCreateNestedOneWithoutPostsInput
    actor?: ActorCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postLikes?: PostLikeCreateNestedManyWithoutPostInput
    images?: ImageCreateNestedManyWithoutPostInput
    reviews?: ReviewCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutSettingInput = {
    id?: number
    userId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    actorId?: number | null
    extraField?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    images?: ImageUncheckedCreateNestedManyWithoutPostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutSettingInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutSettingInput, PostUncheckedCreateWithoutSettingInput>
  }

  export type PostCreateManySettingInputEnvelope = {
    data: PostCreateManySettingInput | PostCreateManySettingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSettingInput = {
    update: XOR<UserUpdateWithoutSettingInput, UserUncheckedUpdateWithoutSettingInput>
    create: XOR<UserCreateWithoutSettingInput, UserUncheckedCreateWithoutSettingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingInput, UserUncheckedUpdateWithoutSettingInput>
  }

  export type UserUpdateWithoutSettingInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostUpsertWithWhereUniqueWithoutSettingInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutSettingInput, PostUncheckedUpdateWithoutSettingInput>
    create: XOR<PostCreateWithoutSettingInput, PostUncheckedCreateWithoutSettingInput>
  }

  export type PostUpdateWithWhereUniqueWithoutSettingInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutSettingInput, PostUncheckedUpdateWithoutSettingInput>
  }

  export type PostUpdateManyWithWhereWithoutSettingInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutSettingInput>
  }

  export type PostCreateWithoutTagsInput = {
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    extraField?: string | null
    user: UserCreateNestedOneWithoutPostsInput
    actor?: ActorCreateNestedOneWithoutPostsInput
    setting: SettingCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postLikes?: PostLikeCreateNestedManyWithoutPostInput
    images?: ImageCreateNestedManyWithoutPostInput
    reviews?: ReviewCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutTagsInput = {
    id?: number
    userId: number
    settingId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    actorId?: number | null
    extraField?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    images?: ImageUncheckedCreateNestedManyWithoutPostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutTagsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
  }

  export type PostUpsertWithWhereUniqueWithoutTagsInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
  }

  export type PostUpdateWithWhereUniqueWithoutTagsInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
  }

  export type PostUpdateManyWithWhereWithoutTagsInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutTagsInput>
  }

  export type PostCreateWithoutImagesInput = {
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    extraField?: string | null
    user: UserCreateNestedOneWithoutPostsInput
    actor?: ActorCreateNestedOneWithoutPostsInput
    setting: SettingCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postLikes?: PostLikeCreateNestedManyWithoutPostInput
    reviews?: ReviewCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutImagesInput = {
    id?: number
    userId: number
    settingId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    actorId?: number | null
    extraField?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutImagesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
  }

  export type PostUpsertWithoutImagesInput = {
    update: XOR<PostUpdateWithoutImagesInput, PostUncheckedUpdateWithoutImagesInput>
    create: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutImagesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutImagesInput, PostUncheckedUpdateWithoutImagesInput>
  }

  export type PostUpdateWithoutImagesInput = {
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    actor?: ActorUpdateOneWithoutPostsNestedInput
    setting?: SettingUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUpdateManyWithoutPostNestedInput
    reviews?: ReviewUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type UserCreateWithoutSubscriptionsInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFollowersInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserCreateWithoutFollowsInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowsInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowsInput, UserUncheckedCreateWithoutFollowsInput>
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutFollowsInput = {
    update: XOR<UserUpdateWithoutFollowsInput, UserUncheckedUpdateWithoutFollowsInput>
    create: XOR<UserCreateWithoutFollowsInput, UserUncheckedCreateWithoutFollowsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowsInput, UserUncheckedUpdateWithoutFollowsInput>
  }

  export type UserUpdateWithoutFollowsInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowsInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutViewingsInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutViewingsInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutViewingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutViewingsInput, UserUncheckedCreateWithoutViewingsInput>
  }

  export type MusicalCreateWithoutViewingsInput = {
    id: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    theater: TheaterCreateNestedOneWithoutMusicalsInput
    castings?: CastingCreateNestedManyWithoutMusicalInput
    communities?: MusicalCommunityCreateNestedManyWithoutMusicalInput
  }

  export type MusicalUncheckedCreateWithoutViewingsInput = {
    id: number
    theaterId: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    castings?: CastingUncheckedCreateNestedManyWithoutMusicalInput
    communities?: MusicalCommunityUncheckedCreateNestedManyWithoutMusicalInput
  }

  export type MusicalCreateOrConnectWithoutViewingsInput = {
    where: MusicalWhereUniqueInput
    create: XOR<MusicalCreateWithoutViewingsInput, MusicalUncheckedCreateWithoutViewingsInput>
  }

  export type UserUpsertWithoutViewingsInput = {
    update: XOR<UserUpdateWithoutViewingsInput, UserUncheckedUpdateWithoutViewingsInput>
    create: XOR<UserCreateWithoutViewingsInput, UserUncheckedCreateWithoutViewingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutViewingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutViewingsInput, UserUncheckedUpdateWithoutViewingsInput>
  }

  export type UserUpdateWithoutViewingsInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutViewingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MusicalUpsertWithoutViewingsInput = {
    update: XOR<MusicalUpdateWithoutViewingsInput, MusicalUncheckedUpdateWithoutViewingsInput>
    create: XOR<MusicalCreateWithoutViewingsInput, MusicalUncheckedCreateWithoutViewingsInput>
    where?: MusicalWhereInput
  }

  export type MusicalUpdateToOneWithWhereWithoutViewingsInput = {
    where?: MusicalWhereInput
    data: XOR<MusicalUpdateWithoutViewingsInput, MusicalUncheckedUpdateWithoutViewingsInput>
  }

  export type MusicalUpdateWithoutViewingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theater?: TheaterUpdateOneRequiredWithoutMusicalsNestedInput
    castings?: CastingUpdateManyWithoutMusicalNestedInput
    communities?: MusicalCommunityUpdateManyWithoutMusicalNestedInput
  }

  export type MusicalUncheckedUpdateWithoutViewingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    castings?: CastingUncheckedUpdateManyWithoutMusicalNestedInput
    communities?: MusicalCommunityUncheckedUpdateManyWithoutMusicalNestedInput
  }

  export type PostCreateWithoutPostLikesInput = {
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    extraField?: string | null
    user: UserCreateNestedOneWithoutPostsInput
    actor?: ActorCreateNestedOneWithoutPostsInput
    setting: SettingCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    images?: ImageCreateNestedManyWithoutPostInput
    reviews?: ReviewCreateNestedManyWithoutPostInput
    tags?: TagCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutPostLikesInput = {
    id?: number
    userId: number
    settingId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    actorId?: number | null
    extraField?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    images?: ImageUncheckedCreateNestedManyWithoutPostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPostInput
    tags?: TagUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutPostLikesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostLikesInput, PostUncheckedCreateWithoutPostLikesInput>
  }

  export type UserCreateWithoutPostLikesInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostLikesInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
  }

  export type PostUpsertWithoutPostLikesInput = {
    update: XOR<PostUpdateWithoutPostLikesInput, PostUncheckedUpdateWithoutPostLikesInput>
    create: XOR<PostCreateWithoutPostLikesInput, PostUncheckedCreateWithoutPostLikesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutPostLikesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutPostLikesInput, PostUncheckedUpdateWithoutPostLikesInput>
  }

  export type PostUpdateWithoutPostLikesInput = {
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    actor?: ActorUpdateOneWithoutPostsNestedInput
    setting?: SettingUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    images?: ImageUpdateManyWithoutPostNestedInput
    reviews?: ReviewUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutPostLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    images?: ImageUncheckedUpdateManyWithoutPostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type UserUpsertWithoutPostLikesInput = {
    update: XOR<UserUpdateWithoutPostLikesInput, UserUncheckedUpdateWithoutPostLikesInput>
    create: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostLikesInput, UserUncheckedUpdateWithoutPostLikesInput>
  }

  export type UserUpdateWithoutPostLikesInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutQuestionsInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
  }

  export type AnswerCreateWithoutQuestionInput = {
    content: string
    createdAt?: Date | string | null
    user: UserCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutQuestionInput = {
    id?: number
    userId: number
    content: string
    createdAt?: Date | string | null
  }

  export type AnswerCreateOrConnectWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerCreateManyQuestionInputEnvelope = {
    data: AnswerCreateManyQuestionInput | AnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutQuestionsInput = {
    update: XOR<UserUpdateWithoutQuestionsInput, UserUncheckedUpdateWithoutQuestionsInput>
    create: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuestionsInput, UserUncheckedUpdateWithoutQuestionsInput>
  }

  export type UserUpdateWithoutQuestionsInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type AnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuestionCreateWithoutAnswersInput = {
    title: string
    content: string
    createdAt?: Date | string | null
    user: UserCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionUncheckedCreateWithoutAnswersInput = {
    id?: number
    userId: number
    title: string
    content: string
    createdAt?: Date | string | null
  }

  export type QuestionCreateOrConnectWithoutAnswersInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
  }

  export type UserCreateWithoutAnswersInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnswersInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnswersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
  }

  export type QuestionUpsertWithoutAnswersInput = {
    update: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionUpdateWithoutAnswersInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutAnswersInput = {
    update: XOR<UserUpdateWithoutAnswersInput, UserUncheckedUpdateWithoutAnswersInput>
    create: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnswersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnswersInput, UserUncheckedUpdateWithoutAnswersInput>
  }

  export type UserUpdateWithoutAnswersInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TheaterCreateWithoutRegionInput = {
    id: number
    name?: string | null
    seatCount?: number | null
    roadAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    musicals?: MusicalCreateNestedManyWithoutTheaterInput
    seats?: SeatCreateNestedManyWithoutTheaterInput
  }

  export type TheaterUncheckedCreateWithoutRegionInput = {
    id: number
    name?: string | null
    seatCount?: number | null
    roadAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    musicals?: MusicalUncheckedCreateNestedManyWithoutTheaterInput
    seats?: SeatUncheckedCreateNestedManyWithoutTheaterInput
  }

  export type TheaterCreateOrConnectWithoutRegionInput = {
    where: TheaterWhereUniqueInput
    create: XOR<TheaterCreateWithoutRegionInput, TheaterUncheckedCreateWithoutRegionInput>
  }

  export type TheaterCreateManyRegionInputEnvelope = {
    data: TheaterCreateManyRegionInput | TheaterCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type TheaterUpsertWithWhereUniqueWithoutRegionInput = {
    where: TheaterWhereUniqueInput
    update: XOR<TheaterUpdateWithoutRegionInput, TheaterUncheckedUpdateWithoutRegionInput>
    create: XOR<TheaterCreateWithoutRegionInput, TheaterUncheckedCreateWithoutRegionInput>
  }

  export type TheaterUpdateWithWhereUniqueWithoutRegionInput = {
    where: TheaterWhereUniqueInput
    data: XOR<TheaterUpdateWithoutRegionInput, TheaterUncheckedUpdateWithoutRegionInput>
  }

  export type TheaterUpdateManyWithWhereWithoutRegionInput = {
    where: TheaterScalarWhereInput
    data: XOR<TheaterUpdateManyMutationInput, TheaterUncheckedUpdateManyWithoutRegionInput>
  }

  export type TheaterScalarWhereInput = {
    AND?: TheaterScalarWhereInput | TheaterScalarWhereInput[]
    OR?: TheaterScalarWhereInput[]
    NOT?: TheaterScalarWhereInput | TheaterScalarWhereInput[]
    id?: IntFilter<"Theater"> | number
    regionId?: IntFilter<"Theater"> | number
    name?: StringNullableFilter<"Theater"> | string | null
    seatCount?: IntNullableFilter<"Theater"> | number | null
    roadAddress?: StringNullableFilter<"Theater"> | string | null
    createdAt?: DateTimeNullableFilter<"Theater"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Theater"> | Date | string | null
  }

  export type MusicalCreateWithoutCastingsInput = {
    id: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    theater: TheaterCreateNestedOneWithoutMusicalsInput
    viewings?: ViewingRecordCreateNestedManyWithoutMusicalInput
    communities?: MusicalCommunityCreateNestedManyWithoutMusicalInput
  }

  export type MusicalUncheckedCreateWithoutCastingsInput = {
    id: number
    theaterId: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutMusicalInput
    communities?: MusicalCommunityUncheckedCreateNestedManyWithoutMusicalInput
  }

  export type MusicalCreateOrConnectWithoutCastingsInput = {
    where: MusicalWhereUniqueInput
    create: XOR<MusicalCreateWithoutCastingsInput, MusicalUncheckedCreateWithoutCastingsInput>
  }

  export type ActorCreateWithoutCastingsInput = {
    postId: number
    userId: number
    settingId: number
    communityId: number
    key: number
    name?: string | null
    image?: string | null
    profile?: string | null
    snsLink?: string | null
    fk?: number | null
    posts?: PostCreateNestedManyWithoutActorInput
  }

  export type ActorUncheckedCreateWithoutCastingsInput = {
    id?: number
    postId: number
    userId: number
    settingId: number
    communityId: number
    key: number
    name?: string | null
    image?: string | null
    profile?: string | null
    snsLink?: string | null
    fk?: number | null
    posts?: PostUncheckedCreateNestedManyWithoutActorInput
  }

  export type ActorCreateOrConnectWithoutCastingsInput = {
    where: ActorWhereUniqueInput
    create: XOR<ActorCreateWithoutCastingsInput, ActorUncheckedCreateWithoutCastingsInput>
  }

  export type MusicalUpsertWithoutCastingsInput = {
    update: XOR<MusicalUpdateWithoutCastingsInput, MusicalUncheckedUpdateWithoutCastingsInput>
    create: XOR<MusicalCreateWithoutCastingsInput, MusicalUncheckedCreateWithoutCastingsInput>
    where?: MusicalWhereInput
  }

  export type MusicalUpdateToOneWithWhereWithoutCastingsInput = {
    where?: MusicalWhereInput
    data: XOR<MusicalUpdateWithoutCastingsInput, MusicalUncheckedUpdateWithoutCastingsInput>
  }

  export type MusicalUpdateWithoutCastingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theater?: TheaterUpdateOneRequiredWithoutMusicalsNestedInput
    viewings?: ViewingRecordUpdateManyWithoutMusicalNestedInput
    communities?: MusicalCommunityUpdateManyWithoutMusicalNestedInput
  }

  export type MusicalUncheckedUpdateWithoutCastingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewings?: ViewingRecordUncheckedUpdateManyWithoutMusicalNestedInput
    communities?: MusicalCommunityUncheckedUpdateManyWithoutMusicalNestedInput
  }

  export type ActorUpsertWithoutCastingsInput = {
    update: XOR<ActorUpdateWithoutCastingsInput, ActorUncheckedUpdateWithoutCastingsInput>
    create: XOR<ActorCreateWithoutCastingsInput, ActorUncheckedCreateWithoutCastingsInput>
    where?: ActorWhereInput
  }

  export type ActorUpdateToOneWithWhereWithoutCastingsInput = {
    where?: ActorWhereInput
    data: XOR<ActorUpdateWithoutCastingsInput, ActorUncheckedUpdateWithoutCastingsInput>
  }

  export type ActorUpdateWithoutCastingsInput = {
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    snsLink?: NullableStringFieldUpdateOperationsInput | string | null
    fk?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUpdateManyWithoutActorNestedInput
  }

  export type ActorUncheckedUpdateWithoutCastingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    snsLink?: NullableStringFieldUpdateOperationsInput | string | null
    fk?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutUserCommunitiesInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserCommunitiesInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    multiProfiles?: MultiProfileUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserCommunitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserCommunitiesInput, UserUncheckedCreateWithoutUserCommunitiesInput>
  }

  export type CommunityCreateWithoutUserCommunitiesInput = {
    createdAt?: Date | string | null
    name?: string | null
    type?: string | null
    description?: string | null
    musicalCommunities?: MusicalCommunityCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutUserCommunitiesInput = {
    id?: number
    createdAt?: Date | string | null
    name?: string | null
    type?: string | null
    description?: string | null
    musicalCommunities?: MusicalCommunityUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutUserCommunitiesInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutUserCommunitiesInput, CommunityUncheckedCreateWithoutUserCommunitiesInput>
  }

  export type UserUpsertWithoutUserCommunitiesInput = {
    update: XOR<UserUpdateWithoutUserCommunitiesInput, UserUncheckedUpdateWithoutUserCommunitiesInput>
    create: XOR<UserCreateWithoutUserCommunitiesInput, UserUncheckedCreateWithoutUserCommunitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserCommunitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserCommunitiesInput, UserUncheckedUpdateWithoutUserCommunitiesInput>
  }

  export type UserUpdateWithoutUserCommunitiesInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserCommunitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    multiProfiles?: MultiProfileUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityUpsertWithoutUserCommunitiesInput = {
    update: XOR<CommunityUpdateWithoutUserCommunitiesInput, CommunityUncheckedUpdateWithoutUserCommunitiesInput>
    create: XOR<CommunityCreateWithoutUserCommunitiesInput, CommunityUncheckedCreateWithoutUserCommunitiesInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutUserCommunitiesInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutUserCommunitiesInput, CommunityUncheckedUpdateWithoutUserCommunitiesInput>
  }

  export type CommunityUpdateWithoutUserCommunitiesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    musicalCommunities?: MusicalCommunityUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutUserCommunitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    musicalCommunities?: MusicalCommunityUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type MusicalCreateWithoutCommunitiesInput = {
    id: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    theater: TheaterCreateNestedOneWithoutMusicalsInput
    castings?: CastingCreateNestedManyWithoutMusicalInput
    viewings?: ViewingRecordCreateNestedManyWithoutMusicalInput
  }

  export type MusicalUncheckedCreateWithoutCommunitiesInput = {
    id: number
    theaterId: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    castings?: CastingUncheckedCreateNestedManyWithoutMusicalInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutMusicalInput
  }

  export type MusicalCreateOrConnectWithoutCommunitiesInput = {
    where: MusicalWhereUniqueInput
    create: XOR<MusicalCreateWithoutCommunitiesInput, MusicalUncheckedCreateWithoutCommunitiesInput>
  }

  export type CommunityCreateWithoutMusicalCommunitiesInput = {
    createdAt?: Date | string | null
    name?: string | null
    type?: string | null
    description?: string | null
    userCommunities?: UserCommunityCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutMusicalCommunitiesInput = {
    id?: number
    createdAt?: Date | string | null
    name?: string | null
    type?: string | null
    description?: string | null
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutMusicalCommunitiesInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutMusicalCommunitiesInput, CommunityUncheckedCreateWithoutMusicalCommunitiesInput>
  }

  export type MusicalUpsertWithoutCommunitiesInput = {
    update: XOR<MusicalUpdateWithoutCommunitiesInput, MusicalUncheckedUpdateWithoutCommunitiesInput>
    create: XOR<MusicalCreateWithoutCommunitiesInput, MusicalUncheckedCreateWithoutCommunitiesInput>
    where?: MusicalWhereInput
  }

  export type MusicalUpdateToOneWithWhereWithoutCommunitiesInput = {
    where?: MusicalWhereInput
    data: XOR<MusicalUpdateWithoutCommunitiesInput, MusicalUncheckedUpdateWithoutCommunitiesInput>
  }

  export type MusicalUpdateWithoutCommunitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theater?: TheaterUpdateOneRequiredWithoutMusicalsNestedInput
    castings?: CastingUpdateManyWithoutMusicalNestedInput
    viewings?: ViewingRecordUpdateManyWithoutMusicalNestedInput
  }

  export type MusicalUncheckedUpdateWithoutCommunitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    castings?: CastingUncheckedUpdateManyWithoutMusicalNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutMusicalNestedInput
  }

  export type CommunityUpsertWithoutMusicalCommunitiesInput = {
    update: XOR<CommunityUpdateWithoutMusicalCommunitiesInput, CommunityUncheckedUpdateWithoutMusicalCommunitiesInput>
    create: XOR<CommunityCreateWithoutMusicalCommunitiesInput, CommunityUncheckedCreateWithoutMusicalCommunitiesInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutMusicalCommunitiesInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutMusicalCommunitiesInput, CommunityUncheckedUpdateWithoutMusicalCommunitiesInput>
  }

  export type CommunityUpdateWithoutMusicalCommunitiesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userCommunities?: UserCommunityUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutMusicalCommunitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type UserCreateWithoutMultiProfilesInput = {
    loginId: string
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    setting: SettingCreateNestedOneWithoutUsersInput
    posts?: PostCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    questions?: QuestionCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordCreateNestedManyWithoutUserInput
    follows?: FollowCreateNestedManyWithoutFollowingInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    userCommunities?: UserCommunityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMultiProfilesInput = {
    id?: number
    loginId: string
    settingId: number
    username?: string | null
    password?: string | null
    email: string
    nickname?: string | null
    profileImage?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bio?: string | null
    birthDate?: Date | string | null
    isSubscribed?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscribeUncheckedCreateNestedManyWithoutUserInput
    viewings?: ViewingRecordUncheckedCreateNestedManyWithoutUserInput
    follows?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    userCommunities?: UserCommunityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMultiProfilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMultiProfilesInput, UserUncheckedCreateWithoutMultiProfilesInput>
  }

  export type UserUpsertWithoutMultiProfilesInput = {
    update: XOR<UserUpdateWithoutMultiProfilesInput, UserUncheckedUpdateWithoutMultiProfilesInput>
    create: XOR<UserCreateWithoutMultiProfilesInput, UserUncheckedCreateWithoutMultiProfilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMultiProfilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMultiProfilesInput, UserUncheckedUpdateWithoutMultiProfilesInput>
  }

  export type UserUpdateWithoutMultiProfilesInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    setting?: SettingUpdateOneRequiredWithoutUsersNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    questions?: QuestionUpdateManyWithoutUserNestedInput
    answers?: AnswerUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUpdateManyWithoutUserNestedInput
    follows?: FollowUpdateManyWithoutFollowingNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    userCommunities?: UserCommunityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMultiProfilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    settingId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSubscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscribeUncheckedUpdateManyWithoutUserNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutUserNestedInput
    follows?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    userCommunities?: UserCommunityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostCreateManyUserInput = {
    id?: number
    settingId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    actorId?: number | null
    extraField?: string | null
  }

  export type CommentCreateManyUserInput = {
    id?: number
    postId: number
    settingId: number
    communityId: number
    content?: string | null
    createdAt?: Date | string | null
    anonymous?: boolean | null
  }

  export type ReviewCreateManyUserInput = {
    id?: number
    settingId: number
    theaterId: number
    key: number
    postId?: number | null
    content?: string | null
    rating?: number | null
    spoiler?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    liked?: string | null
    likeCount?: number | null
    comment?: string | null
    imageUrl?: string | null
    reported?: boolean | null
    watchDate?: Date | string | null
    watchTime?: Date | string | null
    extraField2?: string | null
  }

  export type PostLikeCreateManyUserInput = {
    id?: number
    postId: number
    likedAt?: Date | string | null
  }

  export type QuestionCreateManyUserInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string | null
  }

  export type AnswerCreateManyUserInput = {
    id?: number
    questionId: number
    content: string
    createdAt?: Date | string | null
  }

  export type SubscribeCreateManyUserInput = {
    id: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean | null
  }

  export type ViewingRecordCreateManyUserInput = {
    id: number
    musicalId: number
    date?: Date | string | null
    seat?: string | null
  }

  export type FollowCreateManyFollowingInput = {
    id: number
    followerId: number
    createdAt?: Date | string | null
  }

  export type FollowCreateManyFollowerInput = {
    id: number
    followingId: number
    createdAt?: Date | string | null
  }

  export type MultiProfileCreateManyUserInput = {
    id?: number
    nickname: string
    image?: string | null
    bio?: string | null
  }

  export type UserCommunityCreateManyUserInput = {
    id?: number
    communityId: number
    joinedAt?: Date | string | null
  }

  export type PostUpdateWithoutUserInput = {
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: ActorUpdateOneWithoutPostsNestedInput
    setting?: SettingUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUpdateManyWithoutPostNestedInput
    images?: ImageUpdateManyWithoutPostNestedInput
    reviews?: ReviewUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    images?: ImageUncheckedUpdateManyWithoutPostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutUserInput = {
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ReviewUpdateWithoutUserInput = {
    settingId?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    spoiler?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liked?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reported?: NullableBoolFieldUpdateOperationsInput | boolean | null
    watchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraField2?: NullableStringFieldUpdateOperationsInput | string | null
    post?: PostUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    spoiler?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liked?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reported?: NullableBoolFieldUpdateOperationsInput | boolean | null
    watchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraField2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    spoiler?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liked?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reported?: NullableBoolFieldUpdateOperationsInput | boolean | null
    watchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraField2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostLikeUpdateWithoutUserInput = {
    likedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutPostLikesNestedInput
  }

  export type PostLikeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    likedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostLikeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    likedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscribeUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SubscribeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SubscribeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ViewingRecordUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seat?: NullableStringFieldUpdateOperationsInput | string | null
    musical?: MusicalUpdateOneRequiredWithoutViewingsNestedInput
  }

  export type ViewingRecordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seat?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewingRecordUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seat?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowUpdateWithoutFollowingInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    id?: IntFieldUpdateOperationsInput | number
    followerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    id?: IntFieldUpdateOperationsInput | number
    followerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FollowUpdateWithoutFollowerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    following?: UserUpdateOneRequiredWithoutFollowsNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowerInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultiProfileUpdateWithoutUserInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MultiProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MultiProfileUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommunityUpdateWithoutUserInput = {
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    community?: CommunityUpdateOneRequiredWithoutUserCommunitiesNestedInput
  }

  export type UserCommunityUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCommunityUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateManyPostInput = {
    id?: number
    userId: number
    settingId: number
    communityId: number
    content?: string | null
    createdAt?: Date | string | null
    anonymous?: boolean | null
  }

  export type PostLikeCreateManyPostInput = {
    id?: number
    userId: number
    likedAt?: Date | string | null
  }

  export type ImageCreateManyPostInput = {
    id?: number
    url?: string | null
    caption?: string | null
  }

  export type ReviewCreateManyPostInput = {
    id?: number
    userId: number
    settingId: number
    theaterId: number
    key: number
    content?: string | null
    rating?: number | null
    spoiler?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    liked?: string | null
    likeCount?: number | null
    comment?: string | null
    imageUrl?: string | null
    reported?: boolean | null
    watchDate?: Date | string | null
    watchTime?: Date | string | null
    extraField2?: string | null
  }

  export type CommentUpdateWithoutPostInput = {
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PostLikeUpdateWithoutPostInput = {
    likedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPostLikesNestedInput
  }

  export type PostLikeUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    likedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostLikeUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    likedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ImageUpdateWithoutPostInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewUpdateWithoutPostInput = {
    settingId?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    spoiler?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liked?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reported?: NullableBoolFieldUpdateOperationsInput | boolean | null
    watchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraField2?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    spoiler?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liked?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reported?: NullableBoolFieldUpdateOperationsInput | boolean | null
    watchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraField2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    theaterId?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    spoiler?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liked?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reported?: NullableBoolFieldUpdateOperationsInput | boolean | null
    watchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extraField2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostCreateManyActorInput = {
    id?: number
    userId: number
    settingId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    extraField?: string | null
  }

  export type CastingCreateManyActorInput = {
    id?: number
    musicalId: number
    role?: string | null
  }

  export type PostUpdateWithoutActorInput = {
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    setting?: SettingUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUpdateManyWithoutPostNestedInput
    images?: ImageUpdateManyWithoutPostNestedInput
    reviews?: ReviewUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    images?: ImageUncheckedUpdateManyWithoutPostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateManyWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CastingUpdateWithoutActorInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    musical?: MusicalUpdateOneRequiredWithoutCastingsNestedInput
  }

  export type CastingUncheckedUpdateWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CastingUncheckedUpdateManyWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CastingCreateManyMusicalInput = {
    id?: number
    actorId: number
    role?: string | null
  }

  export type ViewingRecordCreateManyMusicalInput = {
    id: number
    userId: number
    date?: Date | string | null
    seat?: string | null
  }

  export type MusicalCommunityCreateManyMusicalInput = {
    id?: number
    communityId: number
  }

  export type CastingUpdateWithoutMusicalInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    actor?: ActorUpdateOneRequiredWithoutCastingsNestedInput
  }

  export type CastingUncheckedUpdateWithoutMusicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CastingUncheckedUpdateManyWithoutMusicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewingRecordUpdateWithoutMusicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seat?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutViewingsNestedInput
  }

  export type ViewingRecordUncheckedUpdateWithoutMusicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seat?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewingRecordUncheckedUpdateManyWithoutMusicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seat?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MusicalCommunityUpdateWithoutMusicalInput = {
    community?: CommunityUpdateOneRequiredWithoutMusicalCommunitiesNestedInput
  }

  export type MusicalCommunityUncheckedUpdateWithoutMusicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
  }

  export type MusicalCommunityUncheckedUpdateManyWithoutMusicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
  }

  export type MusicalCreateManyTheaterInput = {
    id: number
    name?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    poster?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SeatCreateManyTheaterInput = {
    id: number
    locationId: number
    field?: string | null
    field2?: string | null
    field3?: string | null
    floor?: string | null
  }

  export type MusicalUpdateWithoutTheaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    castings?: CastingUpdateManyWithoutMusicalNestedInput
    viewings?: ViewingRecordUpdateManyWithoutMusicalNestedInput
    communities?: MusicalCommunityUpdateManyWithoutMusicalNestedInput
  }

  export type MusicalUncheckedUpdateWithoutTheaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    castings?: CastingUncheckedUpdateManyWithoutMusicalNestedInput
    viewings?: ViewingRecordUncheckedUpdateManyWithoutMusicalNestedInput
    communities?: MusicalCommunityUncheckedUpdateManyWithoutMusicalNestedInput
  }

  export type MusicalUncheckedUpdateManyWithoutTheaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poster?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SeatUpdateWithoutTheaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    field?: NullableStringFieldUpdateOperationsInput | string | null
    field2?: NullableStringFieldUpdateOperationsInput | string | null
    field3?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeatUncheckedUpdateWithoutTheaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    field?: NullableStringFieldUpdateOperationsInput | string | null
    field2?: NullableStringFieldUpdateOperationsInput | string | null
    field3?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeatUncheckedUpdateManyWithoutTheaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    field?: NullableStringFieldUpdateOperationsInput | string | null
    field2?: NullableStringFieldUpdateOperationsInput | string | null
    field3?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommunityCreateManyCommunityInput = {
    id?: number
    userId: number
    joinedAt?: Date | string | null
  }

  export type MusicalCommunityCreateManyCommunityInput = {
    id?: number
    musicalId: number
  }

  export type UserCommunityUpdateWithoutCommunityInput = {
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserCommunitiesNestedInput
  }

  export type UserCommunityUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCommunityUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MusicalCommunityUpdateWithoutCommunityInput = {
    musical?: MusicalUpdateOneRequiredWithoutCommunitiesNestedInput
  }

  export type MusicalCommunityUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
  }

  export type MusicalCommunityUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    musicalId?: IntFieldUpdateOperationsInput | number
  }

  export type PostCreateManySettingInput = {
    id?: number
    userId: number
    communityId: number
    title?: string | null
    content?: string | null
    category?: string | null
    like?: string | null
    likeCount?: number | null
    commentCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    repost?: number | null
    bookmark?: number | null
    communityGroup?: string | null
    viewCount?: number | null
    tag?: string | null
    mediaType?: $Enums.ImageOrVideo | null
    isPinned?: boolean | null
    tabCategory?: $Enums.Category | null
    isShared?: boolean | null
    musicalId?: number | null
    actorId?: number | null
    extraField?: string | null
  }

  export type PostUpdateWithoutSettingInput = {
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    actor?: ActorUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUpdateManyWithoutPostNestedInput
    images?: ImageUpdateManyWithoutPostNestedInput
    reviews?: ReviewUpdateManyWithoutPostNestedInput
    tags?: TagUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutSettingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    images?: ImageUncheckedUpdateManyWithoutPostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPostNestedInput
    tags?: TagUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateManyWithoutSettingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUpdateWithoutTagsInput = {
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    actor?: ActorUpdateOneWithoutPostsNestedInput
    setting?: SettingUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUpdateManyWithoutPostNestedInput
    images?: ImageUpdateManyWithoutPostNestedInput
    reviews?: ReviewUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    images?: ImageUncheckedUpdateManyWithoutPostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    like?: NullableStringFieldUpdateOperationsInput | string | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repost?: NullableIntFieldUpdateOperationsInput | number | null
    bookmark?: NullableIntFieldUpdateOperationsInput | number | null
    communityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumImageOrVideoFieldUpdateOperationsInput | $Enums.ImageOrVideo | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tabCategory?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    isShared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    musicalId?: NullableIntFieldUpdateOperationsInput | number | null
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraField?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswerCreateManyQuestionInput = {
    id?: number
    userId: number
    content: string
    createdAt?: Date | string | null
  }

  export type AnswerUpdateWithoutQuestionInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TheaterCreateManyRegionInput = {
    id: number
    name?: string | null
    seatCount?: number | null
    roadAddress?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TheaterUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    seatCount?: NullableIntFieldUpdateOperationsInput | number | null
    roadAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    musicals?: MusicalUpdateManyWithoutTheaterNestedInput
    seats?: SeatUpdateManyWithoutTheaterNestedInput
  }

  export type TheaterUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    seatCount?: NullableIntFieldUpdateOperationsInput | number | null
    roadAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    musicals?: MusicalUncheckedUpdateManyWithoutTheaterNestedInput
    seats?: SeatUncheckedUpdateManyWithoutTheaterNestedInput
  }

  export type TheaterUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    seatCount?: NullableIntFieldUpdateOperationsInput | number | null
    roadAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}